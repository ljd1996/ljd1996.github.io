<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="入门说明在把智能协议传上以太坊之后，它就变得不可更改, 这种永固性意味着你的代码永远不能被调整或更新。你编译的程序会一直，永久的，不可更改的，存在以太坊上。 非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，我们需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/12/20/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="入门说明在把智能协议传上以太坊之后，它就变得不可更改, 这种永固性意味着你的代码永远不能被调整或更新。你编译的程序会一直，永久的，不可更改的，存在以太坊上。 非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，我们需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-12-20T12:23:17.000Z">
<meta property="article:modified_time" content="2021-05-14T06:14:57.912Z">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="智能合约">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2018/12/20/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Solidity学习笔记 | 苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/20/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Solidity学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 20:23:17" itemprop="dateCreated datePublished" datetime="2018-12-20T20:23:17+08:00">2018-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/" itemprop="url" rel="index"><span itemprop="name">区块链</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" itemprop="url" rel="index"><span itemprop="name">智能合约</span></a>
                </span>
            </span>

          
            <span id="/2018/12/20/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Solidity学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/12/20/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/12/20/Solidity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="入门说明"><a href="#入门说明" class="headerlink" title="入门说明"></a>入门说明</h1><p>在把智能协议传上以太坊之后，它就变得不可更改, 这种永固性意味着你的代码永远不能被调整或更新。你编译的程序会一直，永久的，不可更改的，存在以太坊上。</p>
<p>非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心，我们需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门；作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心你，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>；</span><br></pre></td></tr></table></figure>

<ol>
<li>版本要高于0.4才可以编译</li>
<li>表示高于0.5的版本则不可编译，第三位的版本号但可以变，留出来用做bug可以修复（如0.4.1的编译器有bug，可在0.4.2修复，现有合约不用改代码）。</li>
</ol>
<h2 id="引用源文件"><a href="#引用源文件" class="headerlink" title="引用源文件"></a>引用源文件</h2><p>全局引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> “filename”;</span><br></pre></td></tr></table></figure>

<p>自定义命名空间引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> symbolName <span class="keyword">from</span> “filename”</span><br></pre></td></tr></table></figure>

<p>分别定义引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123;symbol1 <span class="keyword">as</span> alias, symbol2&#125; <span class="keyword">from</span> “filename”</span><br></pre></td></tr></table></figure>

<p>非es6兼容的简写语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> “filename” <span class="keyword">as</span> symbolName</span><br><span class="line"><span class="comment">// 等同于上述</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> symbolName <span class="keyword">from</span> “filename”</span><br></pre></td></tr></table></figure>

<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>值类型：</p>
<ul>
<li>布尔(Booleans)</li>
<li>整型(Integer)</li>
<li>地址(Address)</li>
<li>定长字节数组(fixed byte arrays)</li>
<li>有理数和整型(Rational and Integer Literals，String literals)</li>
<li>枚举类型(Enums)</li>
<li>函数(Function Types)</li>
</ul>
<p>引用类型</p>
<ul>
<li>不定长字节数组（bytes）</li>
<li>字符串（string）</li>
<li>数组（Array）</li>
<li>结构体（Struts）</li>
</ul>
<h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>复杂类型，如数组(arrays)和数据结构(struct)在Solidity中有一个额外的属性，数据的存储位置。可选为memory和storage。</p>
<p>memory存储位置同我们普通程序的内存一致。即分配，即使用，越过作用域即不可被访问，等待被回收。而在区块链上，由于底层实现了图灵完备，故而会有非常多的状态需要永久记录下来，那么我们就要使用storage类型了，一旦使用这个类型，数据将永远存在。</p>
<p>基于程序的上下文，大多数时候这样的选择是默认的，我们可以通过指定关键字storage和memory修改它。默认的函数参数，包括返回的参数，他们是memory。默认的局部变量是storage的。默认的状态变量（合约声明的公有变量）是storage。</p>
<p>另外还有第三个存储位置calldata。它存储的是函数参数，是只读的，不会永久存储的一个数据位置。外部函数的参数（不包括返回参数）被强制指定为calldata。效果与memory差不多。</p>
<ul>
<li>storage转换为storage只是修改了它的指针。</li>
<li>将一个memory类型的变量赋值给一个状态变量时，实际是将内存变量拷贝到存储中。</li>
<li>memory赋值给局部变量:局部变量虽然是一个storage的，但它仅仅是一个storage类型的指针,所以直接赋值会报错,不能将memory赋值给局部变量.</li>
<li>将storage转为memory，实际是将数据从storage拷贝到memory中。</li>
<li>将一个memory的引用类型赋值给另一个memory的引用，不会创建拷贝（即：memory之间是引用传递）。</li>
<li>对于值类型，总是会进行拷贝。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DataLocation&#123;</span><br><span class="line">  uint valueType;</span><br><span class="line">  mapping(<span class="function"><span class="params">uint</span> =&gt;</span> uint) public refrenceType;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeMemory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = valueType;</span><br><span class="line">    tmp = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeStorage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = refrenceType;</span><br><span class="line">    tmp[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAll</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint, uint</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (valueType, refrenceType[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强制的数据位置：</p>
<ul>
<li>外部函数(External function)的参数(不包括返回参数)强制为：calldata</li>
<li>状态变量(State variables)强制为: storage</li>
</ul>
<p>默认数据位置：</p>
<ul>
<li>函数参数(包括返回参数)：memory</li>
<li>所有其它的局部变量：storage</li>
</ul>
<h2 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h2><p>bool可能的取值为常量值true和false</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>int/uint:</p>
<ul>
<li>变长的有符号或无符号整型。变量支持的步长以8递增，支持从uint8到uint256，以及int8到int256。uint和int默认代表的是uint256和int256</li>
</ul>
<p>字面量:</p>
<ul>
<li>整数字面量，由包含0-9的数字序列组成，默认被解释成十进制。在Solidity中不支持八进制，前导0会被默认忽略，如0100，会被认为是100。</li>
<li>小数由<code>.</code>组成，在他的左边或右边至少要包含一个数字。如1.，.1，1.3均是有效的小数。</li>
</ul>
<p>字面量本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非字面量类型，如整数或小数。或者将他们与非字面量进行运算，则不能保证精度了。总之就是，字面量怎么都计算都行，但一旦转为对应的变量后，再计算就不保证精度了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract IntegerLiteral&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">integerTest</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint, uint</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//超出运算字长了</span></span><br><span class="line">    <span class="keyword">var</span> i = (<span class="number">2</span>**<span class="number">800</span> + <span class="number">1</span>) - <span class="number">2</span>**<span class="number">800</span>;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">1</span>/<span class="number">3</span>*<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//小数运算</span></span><br><span class="line">    <span class="keyword">var</span> k = <span class="number">0.5</span>*<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> (i, j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>十六进制字面量，以关键字hex打头，后面紧跟用单或双引号包裹的字符串。如hex”001122ff”。在内部会被表示为二进制流。由于一个字节是8位，所以一个hex是由两个[0-9a-z]字符组成的，不是成双的字符串是会报错的。十六进制的字面量与字符串可以进行同样的类似操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract HexLiteralBytes&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">bytes4, bytes1, bytes1, bytes1, bytes1</span>)</span>&#123;</span><br><span class="line">      bytes4 a = hex<span class="string">&quot;001122FF&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (a, a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>address：以太坊地址的长度，大小20个字节，160位，所以可以用一个uint160编码。地址是所有合约的基础，所有的合约都会继承地址对象(注意：从0.5.0开始，合约不再继承自地址类型，但仍然可以显式转换为地址)，也可以随时将一个地址串，得到对应的代码进行调用。当然地址代表一个普通帐户时，就没有这么多丰富的功能了。</p>
<p>地址类型的成员：</p>
<ul>
<li>属性：balance</li>
<li>函数：send()，call()，delegatecall()，callcode()。</li>
</ul>
<p>十六进制的字符串，凡是能通过地址合法性检查（address checksum test）2，就会被认为是地址，如0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF。需要注意的是39到41位长的没有通过地址合法性检查的，会提示一个警告，但会被视为普通的有理数字面量。</p>
<p>如果只是想得到当前合约的余额，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract addressTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h3><p>transfer()用来发送以太币（以wei为单位）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = <span class="number">0x123</span>;</span><br><span class="line">address myAddress = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>) x.transfer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>如果x是合约地址，合约的回退函数（fallback 函数）会随transfer调用一起执行（这个是EVM特性），如果因gas耗光或其他原因失败，转移交易会还原并且合约会抛异常停止。</p>
<h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3><p>用来向某个地址发送货币(货币单位是wei)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract PayTest &#123;</span><br><span class="line">    <span class="comment">//得到当前合约的余额</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBalance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;<span class="comment">//0</span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向当前合约存款</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span>(<span class="params"></span>) <span class="title">payable</span> <span class="title">returns</span>(<span class="params">address addr, uint amount, bool success</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//msg.sender 全局变量，调用合约的发起方</span></span><br><span class="line">        <span class="comment">//msg.value 全局变量，调用合约的发起方转发的货币量，以wei为单位。</span></span><br><span class="line">        <span class="comment">//send() 执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> (msg.sender, msg.value, <span class="built_in">this</span>.send(msg.value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约实现的是充值。this.send(msg.value)意指向合约自身发送msg.value量的以太币。msg.value是合约调用方附带的以太币。</p>
<p>send()方法执行时有一些风险:</p>
<ul>
<li>send与transfer对应，但更底层。如果执行失败，transfer不会因异常停止，而send会返回false。</li>
<li>调用递归深度不能超1024。</li>
<li>如果gas不够，执行会失败。</li>
<li>所以使用这个方法要检查成功与否。或为保险起见，货币操作时要使用一些最佳实践。如果执行失败，将会回撤所有交易，所以务必留意返回结果。</li>
</ul>
<p>为了同一些不支持ABI协议的进行直接交互（一般的web3.js，soldity都是支持的）。可以使用call()函数，用来向另一个合约发送原始数据。参数支持任何类型任意数量。每个参数会按规则(规则是按ABI)打包成32字节并一一拼接到一起。call()方法支持ABI协议定义的函数选择器。如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名。所以如果你只是想发送消息体，需要避免第一个参数是4个字节。call方法返回一个bool值，以表明执行成功还是失败。正常结束返回true，异常终止返回false。我们无法解析返回结果，因为这样我们得事前知道返回的数据的编码和数据大小（这里的潜在假设是不知道对方使用的协议格式，所以也不会知道返回的结果如何解析，有点祼协议测试的感觉）。</p>
<p>同样也可以使用delegatecall()，它与call方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。delegatecall()方法的目的是用来执行另一个合约中的工具库。所以开发者需要保证两个合约中的存储变量能兼容，来保证delegatecall()能顺利执行。</p>
<p>上面的这三个方法call()，delegatecall()，callcode()都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p>
<h2 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组</h2><p>bytes1， … ，bytes32，允许值以步长1递增。byte默认表示byte1。成员变量length。</p>
<h2 id="枚举类型-enum"><a href="#枚举类型-enum" class="headerlink" title="枚举类型(enum)"></a>枚举类型(enum)</h2><p>枚举类型是在Solidity中的一种用户自定义类型。他可以显示的与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGoStraight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span></span><br><span class="line">    <span class="comment">// will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span></span><br><span class="line">    <span class="comment">// for all matters external to Solidity. The integer type used is just</span></span><br><span class="line">    <span class="comment">// large enough to hold all enum values, i.e. if you have more values,</span></span><br><span class="line">    <span class="comment">// `uint16` will be used and so on.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getChoice</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">ActionChoices</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDefaultChoice</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的分类:</p>
<ul>
<li>内部函数(internal):因为不能在当前合约的上下文环境以外的地方执行，内部函数只能在当前合约内被使用。如在当前的代码块内，包括内部库函数，和继承的函数中。</li>
<li>外部函数（External）:外部函数由地址和函数方法签名两部分组成。可作为外部函数调用的参数，或者由外部函数调用返回。</li>
</ul>
<p>函数的定义:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">&lt;parameter types&gt;</span>) </span>&#123;internal(默认)|external&#125; [constant] [payable] [returns (<span class="xml"><span class="tag">&lt;<span class="name">return</span> <span class="attr">types</span>&gt;</span>)]</span></span><br></pre></td></tr></table></figure>

<p>若不写类型，默认的函数类型是internal的。如果函数没有返回结果，则必须省略returns关键字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test&#123;</span><br><span class="line">    <span class="comment">//默认是internal类型的</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">noParameter</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">noReturn1</span>(<span class="params">uint x</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果无返回结果，必须省略`returns`关键字</span></span><br><span class="line">    <span class="comment">//function noReturn2(uint x) returns &#123;&#125; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的internal与external：调用一个函数f()时，我们可以直接调用f()，或者使用this.f()。但两者有一个区别。前者是通过internal的方式在调用，而后者是通过external的方式在调用。请注意，这里关于this的使用与大多数语言相背。下面通过一个例子来了解他们的不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.5</span>;</span><br><span class="line"></span><br><span class="line">contract FuntionTest&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">internalFunc</span>(<span class="params"></span>) <span class="title">internal</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">externalFunc</span>(<span class="params"></span>) <span class="title">external</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//直接使用内部的方式调用</span></span><br><span class="line">        internalFunc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能在内部调用一个外部函数，会报编译错误。</span></span><br><span class="line">        <span class="comment">//Error: Undeclared identifier.</span></span><br><span class="line">        <span class="comment">//externalFunc();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能通过`external`的方式调用一个`internal`</span></span><br><span class="line">        <span class="comment">//Member &quot;internalFunc&quot; not found or not visible after argument-dependent lookup in contract FuntionTest</span></span><br><span class="line">        <span class="comment">//this.internalFunc();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用`this`以`external`的方式调用一个外部函数</span></span><br><span class="line">        <span class="built_in">this</span>.externalFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract FunctionTest1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">externalCall</span>(<span class="params">FuntionTest ft</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//调用另一个合约的外部函数</span></span><br><span class="line">        ft.externalFunc();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不能调用另一个合约的内部函数</span></span><br><span class="line">        <span class="comment">//Error: Member &quot;internalFunc&quot; not found or not visible after argument-dependent lookup in contract FuntionTest</span></span><br><span class="line">        <span class="comment">//ft.internalFunc();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不定长字节数组"><a href="#不定长字节数组" class="headerlink" title="不定长字节数组"></a>不定长字节数组</h2><ul>
<li>bytes：动态长度的字节数组。</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串(string)字面量是指由单引号，或双引号引起来的字符串。字符串并不像C语言，包含结束符，“foo”这个字符串大小仅为三个字节。字符串的长度类型可以是变长的，特殊之处在于，可以隐式的转换为byte1,…byte32。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract StringConvert&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">bytes3</span>)</span>&#123;</span><br><span class="line">      bytes3 a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//bytes3 b = &quot;1234&quot;;</span></span><br><span class="line">      <span class="comment">//Error: Type literal_string &quot;1234&quot; is not implicitly convertible to expected type bytes3.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述的字符串字面量，会隐式转换为bytes3。</span></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    uint[<span class="number">5</span>] arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];<span class="comment">//创建一个定长的数组</span></span><br><span class="line">    uint[] storageArr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        uint[<span class="number">5</span>] memory arr1 = [uint(<span class="number">0</span>),<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];<span class="comment">//uint8显示的转换为uint256，否则会报类型错误。</span></span><br><span class="line">        uint[] memory memoryArr;</span><br><span class="line">        <span class="comment">//storageArr[0] = 12;</span></span><br><span class="line">        <span class="comment">//memoryArr[0] = 13; //执行会报VM error: invalid opcode.，原因是数组还没有执行初始化。</span></span><br><span class="line"></span><br><span class="line">        storageArr = <span class="keyword">new</span> uint[](<span class="number">5</span>);</span><br><span class="line">        memoryArr = <span class="keyword">new</span> uint[](<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        storageArr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">        memoryArr[<span class="number">0</span>] = <span class="number">13</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memory数组"><a href="#Memory数组" class="headerlink" title="Memory数组"></a>Memory数组</h3><p>对于memory的变长数组，不支持修改length属性，来调整数组大小。memory的变长数组虽然可以通过参数灵活指定大小，但一旦创建，大小不可调整。</p>
<h3 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h3><p>变长的storage数组和bytes（不包括string）有一个push()方法。可以将一个新元素附加到数组最后端，返回值为当前长度uint。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line"></span><br><span class="line">    uint[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)  <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        arr.push(<span class="number">1</span>);<span class="comment">// 初始化前调用</span></span><br><span class="line">        arr = <span class="keyword">new</span> uint[](<span class="number">1</span>); </span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        uint len = arr.push(<span class="number">1</span>);<span class="comment">//先数组的最后添加一个元素1，方法返回的是数组的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>memory的数组不可修改，不支持push方法。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>uint[2][3]在大多数语言中，表示的是两行三列的数组，而Solidity切好相反，它表示的是三行两列的数组。但是访问数组的方法与其他语言一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.4</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line"></span><br><span class="line">    uint[<span class="number">2</span>][<span class="number">3</span>] arr = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arr_len</span>(<span class="params"></span>)  <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr.length; <span class="comment">//返回值为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="固定的字节数组和可变的字节数组"><a href="#固定的字节数组和可变的字节数组" class="headerlink" title="固定的字节数组和可变的字节数组"></a>固定的字节数组和可变的字节数组</h3><ul>
<li>bytes和string是一种特殊的数组。bytes类似于byte[],但在外部函数作为参数调用中，会进行压缩打包，更省空间，所以应该尽量使用bytes而不是byte[]. </li>
<li>bytes0~bytes32 表示创建固定字节大小的数组，不可修改。</li>
<li>string是特殊的可变字节数组。可以转换为bytes以通过length获得它的字节长度。也可以通过索引来修改对应的字节内容,通过push方法来增加字节内容。</li>
<li>由于bytes与string，可以自由转换，你可以将字符串s通过bytes(s)转为一个bytes。但需要注意的是通过这种方式访问到的是UTF-8编码的码流，并不是独立的一个个字符。比如中文编码是多字节，变长的，所以你访问到的很有可能只是其中的一个代码点。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    <span class="comment">// 声明一个固定长度的数组，不可修改</span></span><br><span class="line">    bytes9 a = <span class="number">0x6c697975656368756e</span>;</span><br><span class="line">    byte[<span class="number">9</span>] b = [byte(<span class="number">0x6c</span>),<span class="number">0x69</span>,<span class="number">0x79</span>,<span class="number">0x75</span>,<span class="number">0x65</span>,<span class="number">0x63</span>,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x6e</span>];</span><br><span class="line"></span><br><span class="line">    byte[] c = <span class="keyword">new</span> byte[](<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function setAIndex0Byte() public &#123;</span></span><br><span class="line">    <span class="comment">//     // 错误，不可修改</span></span><br><span class="line">    <span class="comment">//     a[0] = 0x89;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBIndex0Byte</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">0x89</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setC</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(uint i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            c.push(b[i]);</span><br><span class="line">            c.push(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul>
<li>不能声明一个struct同时将这个struct作为这个struct的一个成员。这个限制是基于结构体的大小必须是有限的。</li>
<li>在函数中，将一个struct赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值时，会影响到原变量。</li>
<li>通常情况下不会考虑使用 uint 变种，因为无论如何定义 uint的大小，Solidity 都会为它保留256位的存储空间。例如，使用 uint8 而不是uint（uint256）不会节省任何 gas。</li>
<li>而如果一个 struct 中有多个 uint，则尽可能使用较小的 uint, Solidity 会将这些 uint 打包在一起，从而占用较少的存储空间。</li>
<li>结构体是不对外可见的(当前只支持internal)，所以只可以在当前合约，或合约的子类中使用。包含自定义结构体的函数均需要声明为internal或private的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding&#123;</span><br><span class="line">    struct Funder&#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct Campaign&#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint goal;</span><br><span class="line">        uint amount;</span><br><span class="line">        uint funderNum;</span><br><span class="line">        mapping(<span class="function"><span class="params">uint</span> =&gt;</span> Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    uint compaingnID;</span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> Campaign) campaigns;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">candidate</span>(<span class="params">address beneficiary, uint goal</span>) <span class="title">returns</span> (<span class="params">uint compaingnID</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// initialize</span></span><br><span class="line">        campaigns[compaingnID++] = Campaign(beneficiary, goal, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">vote</span>(<span class="params">uint compaingnID</span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        Campaign c = campaigns[compaingnID];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//another way to initialize</span></span><br><span class="line">        c.funders[c.funderNum++] = Funder(&#123;<span class="attr">addr</span>: msg.sender, <span class="attr">amount</span>: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">uint comapingnId</span>) <span class="title">returns</span> (<span class="params">bool</span>)</span>&#123;</span><br><span class="line">        Campaign c = campaigns[comapingnId];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c.amount &lt; c.goal)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        <span class="comment">// incase send much more</span></span><br><span class="line">        c.amount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!c.beneficiary.send(amount))&#123;</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>定义方式为mapping(_KeyType =&gt; _KeyValue)。键的类型允许除映射外的所有类型，如数组，合约，枚举，结构体。值的类型无限制。</p>
<p>在映射表中，我们并不存储键的数据，仅仅存储它的keccak256哈希值，用来查找值时使用。因此，映射并没有长度，键集合（或列表），值集合（或列表）这样的概念。</p>
<p>映射类型，仅能用来定义状态变量，或者是在内部函数中作为storage类型的引用。引用是指你可以声明一个，如var storage mappVal的用于存储状态变量的引用的对象，但你没办法使用非状态变量来初始化这个引用。</p>
<p>可以通过将映射标记为public，来让Solidity创建一个访问器。要想访问这样的映射，需要提供一个键值做为参数。如果映射的值类型也是映射，使用访问器访问时，要提供这个映射值所对应的键，不断重复这个过程。下面来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract MappingExample&#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint amount</span>) <span class="title">returns</span> (<span class="params">address addr</span>)</span>&#123;</span><br><span class="line">        balances[msg.sender] = amount;</span><br><span class="line">        <span class="keyword">return</span> msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于调试时，你不一定方便知道自己的发起地址，所以把这个函数，略微调整了一下，以在调用时，返回调用者的地址。编译上述合同后，可以先调用update()，执行成功后，查看调用信息，能看到你更新的地址，这样再查一下这个地址的在映射里存的值。</p>
<p>如果你想通过合约进行上述调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file indeed for compile</span></span><br><span class="line"><span class="comment">//may store in somewhere and import</span></span><br><span class="line">contract MappingExample&#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">uint amount</span>) <span class="title">returns</span> (<span class="params">address addr</span>)</span>&#123;</span><br><span class="line">        balances[msg.sender] = amount;</span><br><span class="line">        <span class="keyword">return</span> msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser&#123;</span><br><span class="line">    </span><br><span class="line">    address conAddr;</span><br><span class="line">    address userAddr;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint amount</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//address not resolved!</span></span><br><span class="line">    <span class="comment">//tringing</span></span><br><span class="line">        conAddr = hex<span class="string">&quot;0xf2bd5de8b57ebfc45dcee97524a7a08fccc80aef&quot;</span>;</span><br><span class="line">        userAddr = hex<span class="string">&quot;0xca35b7d915458ef540ade6068dfe2f44e8fa733c&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> MappingExample(conAddr).balances(userAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射并未提供迭代输出的方法，可以自行实现一个数据结构。</p>
<h2 id="运算符delete"><a href="#运算符delete" class="headerlink" title="运算符delete"></a>运算符delete</h2><p>delete运算符，用于将某个变量重置为初始值。对于整数，运算符的效果等同于a = 0。而对于定长数组，则是把数组中的每个元素置为初始值，变长数组则是将长度置为0。对于结构体，也是类似，是将所有的成员均重置为初始值。delete对于映射类型几乎无影响，因为键可能是任意的，且往往不可知。所以如果你删除一个结构体，它会递归删除所有非mapping的成员。当然，你是可以单独删除映射里的某个键，以及这个键映射的某个值。</p>
<p>需要强调的是delete a的行为更像赋值，为a赋予一个新对象。我们来看看下文的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//值传递</span></span><br><span class="line">        uint x = data;</span><br><span class="line">        <span class="comment">//删除x不会影响data</span></span><br><span class="line">        <span class="keyword">delete</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除data，同样也不会影响x，因为是值传递，它存的是一份原值的拷贝。</span></span><br><span class="line">        <span class="keyword">delete</span> data; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//引用赋值</span></span><br><span class="line">        uint[] y = dataArray;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除dataArray会影响y，y也将被赋值为初值。</span></span><br><span class="line">        <span class="keyword">delete</span> dataArray;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面的操作为报错，因为删除是一个赋值操作，不能向引用类型的storage直接赋值从而报错</span></span><br><span class="line">        <span class="comment">//delete y;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我们可以看出，对于值类型，是值传递，删除x不会影响到data，同样的删除data也不会影响到x。因为他们都存了一份原值的拷贝。而对于复杂类型略有不同，复杂类型在赋值时使用的是引用传递。删除会影响所有相关变量。比如上述代码中，删除dataArray同样会影响到y。由于delete的行为更像是赋值操作，所以不能在上述代码中执行delete y，因为不能对一个storage的引用赋值</p>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>为了方便，并不总是需要明确指定一个变量的类型，编译器会通过第一个向这个对象赋予的值的类型来进行推断1。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint24 x = <span class="number">0x123</span>;</span><br><span class="line"><span class="keyword">var</span> y = x;</span><br></pre></td></tr></table></figure>

<p>函数的参数，包括返回参数，不可以使用var这种不指定类型的方式。</p>
<p>需要特别注意的是，由于类型推断是根据第一个变量进行的赋值。所以代码for (var i = 0; i &lt; 2000; i++) {}将是一个无限循环，因为一个uint8的i的将小于2000。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.4</span>;</span><br><span class="line"></span><br><span class="line">contract Test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">      uint count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">2100</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h1><h2 id="货币单位"><a href="#货币单位" class="headerlink" title="货币单位"></a>货币单位</h2><p>一个字面量的数字，可以使用后缀wei,finney,szabo或ether来在不同面额中转换。不含任何后缀的默认单位是wei。如2 ether == 2000 finney的结果是true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract EthUnit&#123;</span><br><span class="line">    uint a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">bool</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">2</span> ether == <span class="number">2000</span> finney)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间单位-Time-Units"><a href="#时间单位-Time-Units" class="headerlink" title="时间单位(Time Units)"></a>时间单位(Time Units)</h2><p>seconds,minutes,hours,days,weeks,years均可做为后缀，并进行相互转换，默认是seconds为单位。</p>
<p>变量 now 将返回当前的unix时间戳(自1970年1月1日以来经过的秒数)。Unix时间传统用一个32位的整数进行存储，这会导致“2038年”问题，当这个32位的unix时间戳不够用，产生溢出，使用这个时间的遗留系统就麻烦了。所以，如果我们想让我们的 DApp 跑够20年，我们可以使用64位整数表示时间，但为此我们的用户又得支付更多的 gas。真是个两难的设计啊！</p>
<p>如果你需要进行使用这些单位进行日期计算，需要特别小心，因为不是每年都是365天，且并不是每天都有24小时，因为还有闰秒。由于无法预测闰秒，必须由外部的oracle来更新从而得到一个精确的日历库（内部实现一个日期库也是消耗gas的）。</p>
<p>后缀不能用于变量。如果你想对输入的变量说明其不同的单位，可以使用下面的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract DeleteExample&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nowInSeconds</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint256</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint start, uint daysAfter</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= start + daysAfter * <span class="number">1</span> days) &#123; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内置特性"><a href="#内置特性" class="headerlink" title="内置特性"></a>内置特性</h1><h2 id="特殊变量及函数"><a href="#特殊变量及函数" class="headerlink" title="特殊变量及函数"></a>特殊变量及函数</h2><p>区块和交易的属性：</p>
<ul>
<li>block.blockhash(uint blockNumber) returns (bytes32)，给定区块号的哈希值，只支持最近256个区块，且不包含当前区块。</li>
<li>block.coinbase (address) 当前块矿工的地址。</li>
<li>block.difficulty (uint)当前块的难度。</li>
<li>block.gaslimit (uint)当前块的gaslimit。</li>
<li>block.number (uint)当前区块的块号。</li>
<li>block.timestamp (uint)当前块的时间戳。</li>
<li>msg.data (bytes)完整的调用数据（calldata）。</li>
<li>msg.gas (uint)当前还剩的gas。</li>
<li>msg.sender (address)当前调用发起人的地址,总是存在。</li>
<li>msg.sig (bytes4)调用数据的前四个字节（函数标识符）。</li>
<li>msg.value (uint)这个消息所附带的货币量，单位为wei。</li>
<li>now (uint)当前块的时间戳，等同于block.timestamp</li>
<li>tx.gasprice (uint) 交易的gas价格。</li>
<li>tx.origin (address)交易的发送者（完整的调用链）</li>
</ul>
<p>msg的所有成员值，如msg.sender,msg.value的值可以因为每一次外部函数调用，或库函数调用发生变化（因为msg就是和调用相关的全局变量）。如果你想在库函数中，用msg.sender实现访问控制，你需要将msg.sender做为参数（就是说不能使用默认的msg.value，因为它可能被更改）。为了可扩展性的原因，你只能查最近256个块，所有其它的将返回0.</p>
<h2 id="数学和加密函数"><a href="#数学和加密函数" class="headerlink" title="数学和加密函数"></a>数学和加密函数</h2><ul>
<li>asser(bool condition):如果条件不满足，抛出异常。</li>
<li>addmod(uint x, uint y, uint k) returns (uint):计算(x + y) % k。加法支持任意的精度。但不超过(wrap around？)2**256。</li>
<li>mulmod(uint x, uint y, uint k) returns (uint):计算(x * y) % k。乘法支持任意精度，但不超过(wrap around？)2**256。</li>
<li>keccak256(…) returns (bytes32):使用以太坊的（Keccak-256）计算HASH值。紧密打包。</li>
<li>sha3(…) returns (bytes32):等同于keccak256()。紧密打包。</li>
<li>sha256(…) returns (bytes32):使用SHA-256计算HASH值。紧密打包。</li>
<li>ripemd160(…) returns (bytes20):使用RIPEMD-160计算HASH值。紧密打包。</li>
<li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):通过签名信息恢复非对称加密算法公匙地址。如果出错会返回0，附录提供了一个例子1.</li>
<li>revert()：取消执行，并回撤状态变化。</li>
</ul>
<h2 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h2><ul>
<li><address>.balance (uint256)：Address的余额，以wei为单位。</li>
<li><address>.transfer(uint256 amount)：发送给定数量的ether，以wei为单位，到某个地址。失败时抛出异常。</li>
<li><address>.send(uint256 amount) returns (bool):发送给定数量的ether，以wei为单位，到某个地址。失败时返回false。</li>
<li><address>.call(...) returns (bool)：发起底层的call调用。失败时返回false。</li>
<li><address>.callcode(...) returns (bool)：发起底层的callcode调用，失败时返回false。</li>
<li><address>.delegatecall(...) returns (bool)：发起底层的delegatecall调用，失败时返回false。

</li>
</ul>
<p>使用send方法需要注意，调用栈深不能超过1024，或gas不足，都将导致发送失败。使用为了保证你的ether安全，要始终检查返回结果。当用户取款时，使用transfer或使用最佳实践的模式2。</p>
<h2 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h2><ul>
<li>this（当前合约的类型）：当前合约的类型，可以显式的转换为Address</li>
<li>selfdestruct(address recipt):销毁当前合约，并把它所有资金发送到给定的地址。</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>不支持switch和goto，支持if，else，while，do，for，break，continue，return，?:。条件判断中的括号不可省略，但在单行语句中的大括号可以省略。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>在当前的合约中，函数可以直接调用（内部调用方式），包括也可递归调用。</p>
<h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>表达式this.g(8);和c.g(2)（这里的c是一个合约实例）是外部调用函数的方式。实现上是通过一个消息调用，而不是直接通过EVM的指令跳转。需要注意的是，在合约的构造器中，不能使用this调用函数，因为当前合约还没有创建完成。</p>
<p>其它合约的函数必须通过外部的方式调用。对于一个外部调用，所有函数的参数必须要拷贝到内存中。当调用其它合约的函数时，可以通过选项.value()，和.gas()来分别指定，要发送的ether量（以wei为单位），和gas值。</p>
<h3 id="命名参数调用和匿名函数参数"><a href="#命名参数调用和匿名函数参数" class="headerlink" title="命名参数调用和匿名函数参数"></a>命名参数调用和匿名函数参数</h3><p>函数调用的参数，可以通过指定名字的方式调用，但可以以任意的顺序，使用方式是{}包含。但参数的类型和数量要与定义一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint val1, uint val2</span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123; <span class="keyword">return</span> val1 + val2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// named arguments</span></span><br><span class="line">        <span class="keyword">return</span> add(&#123;<span class="attr">val2</span>: <span class="number">2</span>, <span class="attr">val1</span>: <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略函数名称"><a href="#省略函数名称" class="headerlink" title="省略函数名称"></a>省略函数名称</h3><p>没有使用的参数名可以省略(一般常见于返回值)。这些名字在栈(stack)上存在，但不可访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="comment">// omitted name for parameter</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">uint k, uint</span>) <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建合约实例"><a href="#创建合约实例" class="headerlink" title="创建合约实例"></a>创建合约实例</h2><p>一个合约可以通过new关键字来创建一个合约。要创建合约的完整代码，必须提前知道，所以递归创建依赖是不可能的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Account&#123;</span><br><span class="line">    uint accId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//construction?</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Account</span>(<span class="params">uint accountId</span>) <span class="title">payable</span></span>&#123;</span><br><span class="line">        accId = accountId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Initialize&#123;</span><br><span class="line">    Account account = <span class="keyword">new</span> Account(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newAccount</span>(<span class="params">uint accountId</span>)</span>&#123;</span><br><span class="line">        account = <span class="keyword">new</span> Account(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">newAccountWithEther</span>(<span class="params">uint accountId, uint amount</span>)</span>&#123;</span><br><span class="line">        account = (<span class="keyword">new</span> Account).value(amount)(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出来，可以在创建合约中，发送ether，但不能限制gas的使用。如果创建因为out-of-stack，或无足够的余额以及其它任何问题，会抛出一个异常。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>Solidity内置支持元组(tuple)，可以同时返回多个结果，也可用于同时赋值给多个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint, bool, uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">7</span>, <span class="literal">true</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Declares and assigns the variables. Specifying the type explicitly is not possible.</span></span><br><span class="line">        <span class="keyword">var</span> (x, b, y) = f();</span><br><span class="line">        <span class="comment">// Assigns to a pre-existing variable.</span></span><br><span class="line">        (x, y) = (<span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">        <span class="comment">// Common trick to swap values -- does not work for non-value storage types.</span></span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        <span class="comment">// Components can be left out (also for variable declarations).</span></span><br><span class="line">        <span class="comment">// If the tuple ends in an empty component,</span></span><br><span class="line">        <span class="comment">// the rest of the values are discarded.</span></span><br><span class="line">        (data.length,) = f(); <span class="comment">// Sets the length to 7</span></span><br><span class="line">        <span class="comment">// The same can be done on the left side.</span></span><br><span class="line">        (,data[<span class="number">3</span>]) = f(); <span class="comment">// Sets data[3] to 2</span></span><br><span class="line">        <span class="comment">// Components can only be left out at the left-hand-side of assignments, with</span></span><br><span class="line">        <span class="comment">// one exception:</span></span><br><span class="line">        (x,) = (<span class="number">1</span>,);</span><br><span class="line">        <span class="comment">// (1,) is the only way to specify a 1-component tuple, because (1) is</span></span><br><span class="line">        <span class="comment">// equivalent to 1.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用范围和声明"><a href="#作用范围和声明" class="headerlink" title="作用范围和声明"></a>作用范围和声明</h2><p>函数内定义的变量，在整个函数中均可用，无论它在哪里定义，因为Solidity使用了javascript的变量作用范围的规则。与常规语言语法从定义处开始，到当前块结束为止不同。由此，下述代码编译时会抛出一个异常，Identifier already declared。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract ScopingErrors &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">scoping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        uint i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            uint same1 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            uint same1 = <span class="number">0</span>;<span class="comment">// Illegal, second declaration of same1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">minimalScoping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = <span class="number">0</span>;<span class="comment">// Illegal, second declaration of same2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">forLoopScoping</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint same3 = <span class="number">0</span>; same3 &lt; <span class="number">1</span>; same3++) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (uint same3 = <span class="number">0</span>; same3 &lt; <span class="number">1</span>; same3++) &#123;<span class="comment">// Illegal, second declaration of same3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">crossFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       uint same1 = <span class="number">0</span>;<span class="comment">//Illegal</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外的，如果一个变量被声明了，它会在函数开始前被初始化为默认值。所以下述例子是合法的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// baz is implicitly initialized as 0</span></span><br><span class="line">        uint bar = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            bar += baz;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uint baz = <span class="number">10</span>;<span class="comment">// never executes</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bar;<span class="comment">// returns 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>在Solidity中无法安全地生成随机数，Solidity 中最好的随机数生成器是 keccak256 哈希函数，可以这样来生成一些随机数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个0到100的随机数:</span></span><br><span class="line">uint randNonce = <span class="number">0</span>;</span><br><span class="line">uint random = uint(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br><span class="line">randNonce++;</span><br><span class="line">uint random2 = uint(keccak256(now, msg.sender, randNonce)) % <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法可以被不诚实的节点攻击，假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (random &gt;= 50 算正面, random &lt; 50 算反面)。如果我正运行一个节点，我可以只对我自己的节点发布一个事务，且不分享它。我可以运行硬币翻转方法来偷窥我的输赢：如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。</p>
<p>当然，这需要很大的算力来保证自己可以挖矿成功。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>可以使用throw来手动抛出一个异常。抛出异常的效果是当前的执行被终止且被撤销(值的改变和帐户余额的变化都会被回退)。异常还会通过Solidity的函数调用向上冒泡(bubbled up)传递。（send，和底层的函数调用call,delegatecall，callcode是一个例外，当发生异常时，这些函数返回false）。捕捉异常是不可能的。</p>
<p>require使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHiToVitalik</span>(<span class="params">string _name</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 比较 _name 是否等于 &quot;Vitalik&quot;. 如果不成立，抛出异常并终止程序</span></span><br><span class="line">  <span class="comment">// (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较</span></span><br><span class="line">  <span class="comment">// 两字符串的 keccak256 哈希值来进行判断)</span></span><br><span class="line">  <span class="built_in">require</span>(keccak256(_name) == keccak256(<span class="string">&quot;Vitalik&quot;</span>));</span><br><span class="line">  <span class="comment">// 如果返回 true, 运行如下语句</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hi!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sendHalf</span>(<span class="params">address addr</span>) <span class="title">payable</span> <span class="title">returns</span> (<span class="params">uint balance</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!addr.send(msg.value / <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// also reverts the transfer to Sharer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以通过下述方式触发一个异常：</p>
<ul>
<li>调用throw。</li>
<li>调用require，但参数值为false。</li>
</ul>
<p>通过assert判断内部条件是否达成，require验证输入的有效性。这样的分析工具，可以假设正确的输入，减少错误。这样无效的操作码将永远不会出现。</p>
<p>assert 和 require 区别在于，require 若失败则会返还给用户剩下的 gas， assert 则不会。</p>
<h1 id="合约详解"><a href="#合约详解" class="headerlink" title="合约详解"></a>合约详解</h1><h2 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h2><p>Solidity中合约有点类似面向对象语言中的类。合约中有用于数据持久化的状态变量(state variables)，和可以操作他们的函数。调用另一个合约实例的函数时，会执行一个EVM函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量(state variables)就不能访问了。</p>
<p>合约可以通过Solidity，或不通过Solidity创建。当合约创建时，一个和合约同名的函数(构造器函数)会调用一次，用于初始化。构造器函数是可选的。仅能有一个构造器，所以不支持重载。</p>
<p>如果不通过Solidity，我们可以通过web3.js，使用JavaScript的API来完成合约创建。</p>
<p>当一个文件中有多个contract时，默认将合约名大写的那个合约当做主合约。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>修改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Test &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (owner == msg.sender) &#123; <span class="comment">// 检查谁在调用</span></span><br><span class="line">        selfdestruct(owner); <span class="comment">// 销毁合约</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可见性和权限控制"><a href="#可见性和权限控制" class="headerlink" title="可见性和权限控制"></a>可见性和权限控制</h2><p>Solidity有两种函数调用方式，一种是内部调用，不会创建一个EVM调用（也叫做消息调用），另一种则是外部调用，会创建EVM调用（会发起消息调用）。Solidity对函数和状态变量提供了四种可见性。分别是external,public,internal,private。其中函数默认是public。状态变量默认的可见性是internal。</p>
<ul>
<li>external: 外部函数是合约接口的一部分，所以我们可以从其它合约或通过交易来发起调用。一个外部函数f，不能通过内部的方式来发起调用，（如f()不可以，但可以通过this.f()）。外部函数在接收大的数组数据时更加有效。</li>
<li>public: 可以在任何地方调用，不管是内部还是外部。对于public类型的状态变量，会自动创建一个访问器（详见下文）。</li>
<li>internal：这样声明的函数和状态变量只能通过内部访问。如在当前合约中调用，或继承的合约里调用。需要注意的是不能加前缀this，前缀this是表示通过外部方式访问。</li>
<li>private：私有函数和状态变量仅在当前合约中可以访问，在继承的合约内，不可访问。private修饰的函数名一般以”_”开头.</li>
</ul>
<p>备注：</p>
<ul>
<li>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</li>
<li>所有在合约内的东西对外部的观察者来说都是可见，将某些东西标记为private仅仅阻止了其它合约来进行访问和修改，但并不能阻止其它人看到相关的信息。</li>
<li>可见性的标识符的定义位置，对于state variable是在类型后面，函数是在参数列表和返回关键字中间。来看一个定义的例子：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a</span>) <span class="title">private</span> <span class="title">returns</span> (<span class="params">uint b</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params">uint a</span>) <span class="title">internal</span> </span>&#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，D可以调用c.getData()来访问data的值，但不能调用f。合约E继承自C，所以它可以访问compute函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint private data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a</span>) <span class="title">private</span> <span class="title">returns</span>(<span class="params">uint b</span>) </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params">uint a</span>) </span>&#123; data = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params">uint a, uint b</span>) <span class="title">internal</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        uint local = c.f(<span class="number">7</span>); <span class="comment">// error: member &quot;f&quot; is not visible</span></span><br><span class="line">        c.setData(<span class="number">3</span>);</span><br><span class="line">        local = c.getData();</span><br><span class="line">        local = c.compute(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// error: member &quot;compute&quot; is not visible</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract E is C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        uint val = compute(<span class="number">3</span>, <span class="number">5</span>);  <span class="comment">// acces to internal member (from derivated to parent contract)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问函数"><a href="#访问函数" class="headerlink" title="访问函数"></a>访问函数</h2><p>编译器为自动为所有的public的状态变量创建访问函数。下面的合约例子中，编译器会生成一个名叫data的无参，返回值是uint的类型的值data。状态变量的初始化可以在定义时完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract C&#123;</span><br><span class="line">    uint public c = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDataUsingAccessor</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.c();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h2><p>modifier 可以用来改变一个函数的行为。比如用于在函数执行前检查某种前置条件。修改器是一种合约属性，可被继承，同时还可被派生的合约重写(override)。下面我们来看一段示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">owned</span>(<span class="params"></span>) </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This contract only defines a modifier but does not use</span></span><br><span class="line">    <span class="comment">// it - it will be used in derived contracts.</span></span><br><span class="line">    <span class="comment">// The function body is inserted where the special symbol</span></span><br><span class="line">    <span class="comment">// &quot;_;&quot; in the definition of a modifier appears.</span></span><br><span class="line">    <span class="comment">// This means that if the owner calls this function, the</span></span><br><span class="line">    <span class="comment">// function is executed and otherwise, an exception is</span></span><br><span class="line">    <span class="comment">// thrown.</span></span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender != owner)</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        <span class="comment">// require(msg.sender == owner);</span></span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    <span class="comment">// This contract inherits the &quot;onlyOwner&quot;-modifier from</span></span><br><span class="line">    <span class="comment">// &quot;owned&quot; and applies it to the &quot;close&quot;-function, which</span></span><br><span class="line">    <span class="comment">// causes that calls to &quot;close&quot; only have an effect if</span></span><br><span class="line">    <span class="comment">// they are made by the stored owner.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    <span class="comment">// Modifiers can receive arguments:</span></span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Register</span>(<span class="params">uint initialPrice</span>) </span>&#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is important to also provide the</span></span><br><span class="line">    <span class="comment">// &quot;payable&quot; keyword here, otherwise the function will</span></span><br><span class="line">    <span class="comment">// automatically reject all Ether sent to it.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) <span class="title">payable</span> <span class="title">costs</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">        registeredAddresses[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changePrice</span>(<span class="params">uint _price</span>) <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改器可以被继承，使用将modifier置于参数后，返回值前即可。</li>
<li>特殊_表示使用修改符的函数体的替换位置。</li>
<li>从合约Register可以看出全约可以多继承，通过<code>,</code>号分隔两个被继承的对象。</li>
<li>修改器也是可以接收参数的，如priced的costs。</li>
</ul>
<p>使用修改器实现的一个防重复进入的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        <span class="keyword">if</span> (locked) <span class="keyword">throw</span>;</span><br><span class="line">        locked = <span class="literal">true</span>;</span><br><span class="line">        _;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// This function is protected by a mutex, which means that</span></span><br><span class="line">    <span class="comment">/// reentrant calls from within msg.sender.call cannot call f again.</span></span><br><span class="line">    <span class="comment">/// The `return 7` statement assigns 7 to the return value but still</span></span><br><span class="line">    <span class="comment">/// executes the statement `locked = false` in the modifier.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) <span class="title">noReentrancy</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!msg.sender.call()) <span class="keyword">throw</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中，由于call()方法有可能会调回当前方法，修改器实现了防重入的检查。如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。需要注意的是，在Solidity的早期版本中，有修改器的函数，它的return语句的行为有些不同。在修改器中和函数体内的显式的return语句，仅仅跳出当前的修改器和函数体。返回的变量会被赋值，但整个执行逻辑会在前一个修改器后面定义的”_”后继续执行。修改器的参数可以是任意表达式。在对应的上下文中，所有的函数中引入的符号，在修改器中均可见。但修改器中引入的符号在函数中不可见，因为它们有可能被重写。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p>状态变量可以被定义为constant，常量。这样的话，它必须在编译期间通过一个表达式赋值。赋值的表达式不允许：1）访问storage；2）区块链数据，如now，this.balance，block.number；3）合约执行的中间数据，如msg.gas；4）向外部合约发起调用。也许会造成内存分配副作用表达式是允许的，但不允许产生其它内存对象的副作用的表达式。内置的函数keccak256，keccak256，ripemd160，ecrecover，addmod，mulmod可以允许调用，即使它们是调用的外部合约。</p>
<p>允许内存分配，从而带来可能的副作用的原因是因为这将允许构建复杂的对象，比如，查找表。虽然当前的特性尚未完整支持。</p>
<p>编译器并不会为常量在storage上预留空间，每个使用的常量都会被对应的常量表达式所替换（也许优化器会直接替换为常量表达式的结果值）。</p>
<p>不是所有的类型都支持常量，当前支持的仅有值类型和字符串。</p>
<p>新版本中:</p>
<ul>
<li>view: 把函数定义为 view, 意味着它只能读取数据不能更改数据</li>
<li>pure: pure 函数表明这个函数不访问应用里的数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = <span class="number">32</span>**<span class="number">22</span> + <span class="number">8</span>;</span><br><span class="line">    string constant text = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    bytes32 constant myHash = keccak256(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h3><p>函数也可被声明为常量，这类函数将承诺自己不修改区块链上任何状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">uint a, uint b</span>) <span class="title">constant</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * (b + <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问器(Accessor)方法默认被标记为constant。当前编译器并未强制一个constant的方法不能修改状态。但建议大家对于不会修改数据的标记为constant。</p>
<h2 id="回退函数"><a href="#回退函数" class="headerlink" title="回退函数"></a>回退函数</h2><p>每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。</p>
<p>下述提供给回退函数可执行的操作会比常规的花费得多一点。</p>
<ul>
<li>写入到存储(storage)</li>
<li>创建一个合约</li>
<li>执行一个外部(external)函数调用，会花费非常多的gas</li>
<li>发送ether</li>
</ul>
<p>请在部署合约到网络前，保证透彻的测试你的回退函数，来保证函数执行的花费控制在2300gas以内。一个没有定义一个回退函数的合约。如果接收ether，会触发异常，并返还ether（solidity v0.4.0开始）。所以合约要接收ether，必须实现回退函数。下面来看个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    <span class="comment">// This function is called for all messages sent to</span></span><br><span class="line">    <span class="comment">// this contract (there is no other function).</span></span><br><span class="line">    <span class="comment">// Sending Ether to this contract will cause an exception,</span></span><br><span class="line">    <span class="comment">// because the fallback function does not have the &quot;payable&quot;</span></span><br><span class="line">    <span class="comment">// modifier.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; x = <span class="number">1</span>; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This contract keeps all Ether sent to it with no way to get it back.</span></span><br><span class="line">contract Sink &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callTest</span>(<span class="params">Test test</span>) </span>&#123;</span><br><span class="line">        test.call(<span class="number">0xabcdef01</span>); <span class="comment">// hash does not exist</span></span><br><span class="line">        <span class="comment">// results in test.x becoming == 1.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The following call will fail, reject the</span></span><br><span class="line">        <span class="comment">// Ether and return false:</span></span><br><span class="line">        test.send(<span class="number">2</span> ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="payable"><a href="#payable" class="headerlink" title="payable"></a>payable</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract OnlineStore &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">buySomething</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查以确定0.001以太发送出去来运行函数:</span></span><br><span class="line">    <span class="built_in">require</span>(msg.value == <span class="number">0.001</span> ether);</span><br><span class="line">    <span class="comment">// 如果为真，一些用来向函数调用者发送数字内容的逻辑</span></span><br><span class="line">    transferThing(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提现"><a href="#提现" class="headerlink" title="提现"></a>提现</h2><p>在发送以太之后，它将被存储进合约的以太坊账户中，并冻结在哪里，可以写一个函数来从合约中提现以太，类似这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract GetPaid is Ownable &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    owner.transfer(<span class="built_in">this</span>.balance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是合约和区块链通讯的一种机制。前端应用“监听”某些事件，并做出反应。(触发事件需要添加emit关键字)</p>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里建立事件</span></span><br><span class="line">event IntegersAdded(uint x, uint y, uint result);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint _x, uint _y</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">  uint result = _x + _y;</span><br><span class="line">  <span class="comment">//触发事件，通知app</span></span><br><span class="line">  emit IntegersAdded(_x, _y, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app前端可以监听这个事件,JavaScript 实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourContract.IntegersAdded(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 干些事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">owned</span>(<span class="params"></span>) </span>&#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use &quot;is&quot; to derive from another contract. Derived</span></span><br><span class="line"><span class="comment">// contracts can access all non-private members including</span></span><br><span class="line"><span class="comment">// internal functions and state variables. These cannot be</span></span><br><span class="line"><span class="comment">// accessed externally via `this`, though.</span></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// These abstract contracts are only provided to make the</span></span><br><span class="line"><span class="comment">// interface known to the compiler. Note the function</span></span><br><span class="line"><span class="comment">// without body. If a contract does not implement all</span></span><br><span class="line"><span class="comment">// functions it can only be used as an interface.</span></span><br><span class="line">contract Config &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lookup</span>(<span class="params">uint id</span>) <span class="title">returns</span> (<span class="params">address adr</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">NameReg</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">bytes32 name</span>);</span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">unregister</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"> &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Multiple</span> <span class="title">inheritance</span> <span class="title">is</span> <span class="title">possible</span>. <span class="title">Note</span> <span class="title">that</span> &quot;<span class="title">owned</span>&quot; <span class="title">is</span></span></span><br><span class="line"><span class="function">// <span class="title">also</span> <span class="title">a</span> <span class="title">base</span> <span class="title">class</span> <span class="title">of</span> &quot;<span class="title">mortal</span>&quot;, <span class="title">yet</span> <span class="title">there</span> <span class="title">is</span> <span class="title">only</span> <span class="title">a</span> <span class="title">single</span></span></span><br><span class="line"><span class="function">// <span class="title">instance</span> <span class="title">of</span> &quot;<span class="title">owned</span>&quot; (<span class="params">as for virtual inheritance in C++</span>).</span></span><br><span class="line"><span class="function"><span class="title">contract</span> <span class="title">named</span> <span class="title">is</span> <span class="title">owned</span>, <span class="title">mortal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params">bytes32 name</span>) </span>&#123;</span><br><span class="line">        Config config = Config(<span class="number">0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970</span>);</span><br><span class="line">        NameReg(config.lookup(<span class="number">1</span>)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Functions can be overridden by another function with the same name and</span></span><br><span class="line">    <span class="comment">// the same number/types of inputs.  If the overriding function has different</span></span><br><span class="line">    <span class="comment">// types of output parameters, that causes an error.</span></span><br><span class="line">    <span class="comment">// Both local and message-based function calls take these overrides</span></span><br><span class="line">    <span class="comment">// into account.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">kill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(<span class="number">0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970</span>);</span><br><span class="line">            NameReg(config.lookup(<span class="number">1</span>)).unregister();</span><br><span class="line">            <span class="comment">// It is still possible to call a specific</span></span><br><span class="line">            <span class="comment">// overridden function.</span></span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// If a constructor takes an argument, it needs to be</span></span><br><span class="line"><span class="comment">// provided in the header (or modifier-invocation-style at</span></span><br><span class="line"><span class="comment">// the constructor of the derived contract (see below)).</span></span><br><span class="line">contract PriceFeed is owned, mortal, named(<span class="string">&quot;GoldFeed&quot;</span>) &#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">updateInfo</span>(<span class="params">uint newInfo</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">returns</span>(<span class="params">uint r</span>) </span>&#123; <span class="keyword">return</span> info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基类构造器的方法"><a href="#基类构造器的方法" class="headerlink" title="基类构造器的方法"></a>基类构造器的方法</h3><p>派生的合约需要提供所有父合约需要的所有参数，所以用两种方式来做，见下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params">uint _x</span>) </span>&#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Derived is Base(<span class="number">7</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Derived</span>(<span class="params">uint _y</span>) <span class="title">Base</span>(<span class="params">_y * _y</span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接在继承列表中使用is Base(7)，或像修改器(modifier)使用方式一样，做为派生构造器定义头的一部分Base(_y * _y)。第一种方式对于构造器是常量的情况比较方便，可以大概说明合约的行为。第二种方式适用于构造的参数值由派生合约的指定的情况。在上述两种都用的情况下，第二种方式优先(一般情况只用其中一种方式就好了)。</p>
<h3 id="继承有相同名字的不同类型成员"><a href="#继承有相同名字的不同类型成员" class="headerlink" title="继承有相同名字的不同类型成员"></a>继承有相同名字的不同类型成员</h3><p>当继承最终导致一个合约同时存在多个相同名字的修改器或函数，它将被视为一个错误。同新的如果事件与修改器重名，或者函数与事件重名都将产生错误。作为一个例外，状态变量的getter可以覆盖一个public的函数。</p>
<h2 id="抽象-Abstract-Contracts"><a href="#抽象-Abstract-Contracts" class="headerlink" title="抽象(Abstract Contracts)"></a>抽象(Abstract Contracts)</h2><p>抽象函数是没有函数体的的函数。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">utterance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">bytes32</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样的合约不能通过编译，即使合约内也包含一些正常的函数。但它们可以做为基合约被继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">utterance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">bytes32</span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">function</span> <span class="title">getContractName</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">string</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Feline&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">utterance</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">bytes32</span>) </span>&#123; <span class="keyword">return</span> <span class="string">&quot;miaow&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个合约从一个抽象合约里继承，但却没实现所有函数，那么它也是一个抽象合约。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口与抽象合约类似，与之不同的是，接口内没有任何函数是已实现的，同时还有如下限制：</p>
<ul>
<li>不能继承其它合约，或接口。</li>
<li>不能定义构造器</li>
<li>不能定义变量</li>
<li>不能定义结构体</li>
<li>不能定义枚举类</li>
<li>其中的一些限制可能在未来放开。</li>
</ul>
<p>接口基本上限制为合约ABI定义可以表示的内容，ABI和接口定义之间的转换应该是可能的，不会有任何信息丢失。接口用自己的关键词表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Token &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address recipient, uint amount</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>合约可以继承于接口，因为他们可以继承于其它的合约。</p>
<h1 id="Gas优化"><a href="#Gas优化" class="headerlink" title="Gas优化"></a>Gas优化</h1><ul>
<li>结构体中尽量使用uint的少位数，且考虑字节对其</li>
<li>“view” 函数不花 “gas”，这是因为 view 函数不会真正改变区块链上的任何数据。如果一个 view 函数在另一个函数的内部被调用，而调用函数与 view 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 view 的函数只有在外部调用时才是免费的(当玩家从web.js外部调用)。</li>
<li>在大多数编程语言中，遍历大数据集合都是昂贵的。但是在 Solidity 中，使用一个标记了external view的函数，遍历比 storage 要便宜太多，因为 view 函数不会产生任何花销。</li>
<li>为了降低成本，不到万不得已，避免将数据写入存储。这也会导致效率低下的编程逻辑：比如每次调用一个函数，都需要在 memory(内存) 中重建一个数组，而不是简单地将上次计算的数组给存储下来以便快速查找。</li>
</ul>
<h1 id="智能合约升级"><a href="#智能合约升级" class="headerlink" title="智能合约升级"></a>智能合约升级</h1><p>将合约进行分离，先部署数据合约，部署后不变。业务合约调用数据合约读取修改数据。保证数据类型不变的情况下，可以对业务合约进行修改，新增。之后部署新的业务合约，废除旧的业务合约。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line"></span><br><span class="line">contract DataContract &#123;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256) public balanceOf;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> bool) accessAllowed;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">DataContract</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[msg.sender] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBlance</span>(<span class="params">address _address,uint256 v</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balanceOf[_address] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    modifier platform() &#123;</span><br><span class="line">        <span class="built_in">require</span>(accessAllowed[msg.sender] == <span class="literal">true</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">denyAccess</span>(<span class="params">address _addr</span>) <span class="title">platform</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        accessAllowed[_addr] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract ControlContract &#123;</span><br><span class="line"></span><br><span class="line">    DataContract dataContract;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ControlContract</span>(<span class="params">address _dataContractAddr</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        dataContract = DataContract(_dataContractAddr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">address addr</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataContract.balanceOf(addr) + <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署方法如下：</p>
<ol>
<li>先部署DataContract合约。</li>
<li>使用DataContract合约地址作为部署ControlContract合约的参数。</li>
<li>用ControlContract合约地址作为参数调用DataContract合约的allowAccess方法。</li>
</ol>
<p>如果需要更新控制合约(如修复了addTen)则重新执行第2-3步，同时对老的控制合约执行denyAccess()。</p>
<h1 id="代币"><a href="#代币" class="headerlink" title="代币"></a>代币</h1><p>一个代币在以太坊上就是一个遵循一些共同规则的智能合约：以太坊代币标准(ERC-Token Standard)。建立在以太坊网络上的区块链项目代币，需要遵从以下几种代币标准：ERC-20，ERC-223，ERC-621，ERC-721，ERC-827。其中 ERC 是 Ethereum Request for Comments 的简称。</p>
<h2 id="ERC-20"><a href="#ERC-20" class="headerlink" title="ERC-20"></a>ERC-20</h2><p>这是最广泛被大家认可的一种代币形式，简单的列举一些通用的标准函数：</p>
<ul>
<li>function totalSupply() 定义 Token 的总量；</li>
<li>function balanceOf(address tokenOwner) 显示用户账户余额；</li>
<li>function allowance(address tokenOwner, address spender) 返回剩余金额，显示 address spender 能从 address tokenOwner 里提取的数量；</li>
<li>function transfer(address to, uint tokens) 转移对应的金额到指定地址；</li>
<li>function approve(address spender, uint tokens)  returns (bool success) 允许  address spender 提取部分 Token；</li>
<li>function transferFrom(address from, address to, uint tokens) returns (bool success) 从一个地址转移 token 到另一个地址；</li>
</ul>
<p>拥有以上所有必要的函数实现我们称为兼容 ERC-20 标准，但在具体实现中会做一些扩展，比如 ERC-223。</p>
<h2 id="ERC-223"><a href="#ERC-223" class="headerlink" title="ERC-223"></a>ERC-223</h2><p>这个标准支持所有 ERC-20 的函数、智能合约以及服务，并解决了一些 ERC-20 的缺陷，比如说：在 ERC-20 标准下如果你输入了错误的收款地址，你转账的费用可能会永远丢失，但在 ERC-223 里这个问题被避免了，同时在这个标准下你需要消耗的 GAS 费用只有 ERC-20 的一半。</p>
<h2 id="ERC-621"><a href="#ERC-621" class="headerlink" title="ERC-621"></a>ERC-621</h2><p>ERC-621 也是一个基于 ERC-20 升级的标准，解决了 ERC-20 不允许 Token 总量更改的问题，不过为了解决这个问题，ERC-621 增加了两种新的函数：</p>
<p>increaseSupply 和 decreaseSupply</p>
<h2 id="ERC-827"><a href="#ERC-827" class="headerlink" title="ERC-827"></a>ERC-827</h2><p>这个标准比 ERC-20 更加灵活，除用于转账外，还可以转移数据和让第三方在获取用户允许的情况下为用户转账。</p>
<h2 id="ERC-721"><a href="#ERC-721" class="headerlink" title="ERC-721"></a>ERC-721</h2><p>ERC-721 与 ERC-20 有很大的区别，如果说 ERC-20 与 ERC-223，ERC-621 能够在使用中自由转换的话，ERC-721 是不可与 ERC-20 Token 互相转换的，因为 ERC-721 拥有唯一性。这种 Token 依然可以在交易所里交易，只不过无法分割是一个独立的整体。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract ERC721 &#123;</span><br><span class="line">  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);</span><br><span class="line">  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _owner</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256 _balance</span>);</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">ownerOf</span>(<span class="params">uint256 _tokenId</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address _owner</span>);</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _tokenId</span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">approve</span>(<span class="params">address _to, uint256 _tokenId</span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">  <span class="title">function</span> <span class="title">takeOwnership</span>(<span class="params">uint256 _tokenId</span>) <span class="title">public</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>ERC721 规范有两种不同的方法来转移代币：</p>
<ol>
<li>第一种方法是代币的拥有者调用transfer 方法，传入他想转移到的 address 和他想转移的代币的 _tokenId。</li>
<li>第二种方法是代币拥有者首先调用 approve，然后传入与以上相同的参数。接着，该合约会存储谁被允许提取代币，通常存储到一个 mapping (uint256 =&gt; address) 里。然后，当有人调用 takeOwnership 时，合约会检查 msg.sender 是否得到拥有者的批准来提取代币，如果是，则将代币转移给他。<ul>
<li>所有者，用新主人的 address 和你希望他获取的 _tokenId 来调用 approve</li>
<li>新主人用 _tokenId 来调用 takeOwnership，合约会检查确保他获得了批准，然后把代币转移给他。</li>
</ul>
</li>
</ol>
<h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1><h2 id="Ownable"><a href="#Ownable" class="headerlink" title="Ownable"></a>Ownable</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title <span class="variable">Ownable</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev </span>The Ownable contract has an owner address, and provides basic authorization control</span></span><br><span class="line"><span class="comment"> * functions, this simplifies the implementation of &quot;user permissions&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev </span>The Ownable constructor sets the original `owner` of the contract to the sender</span></span><br><span class="line"><span class="comment">   * account.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Ownable</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev </span>Throws if called by any account other than the owner.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    <span class="built_in">require</span>(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@dev </span>Allows the current owner to transfer control of the contract to a newOwner.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>newOwner The address to transfer ownership to.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transferOwnership</span>(<span class="params">address newOwner</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(newOwner != address(<span class="number">0</span>));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner = newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SafeMath"><a href="#SafeMath" class="headerlink" title="SafeMath"></a>SafeMath</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">library SafeMath &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">uint256 a, uint256 b</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uint256 c = a * b;</span><br><span class="line">    assert(c / a == b);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">uint256 a, uint256 b</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// assert(b &gt; 0); // Solidity automatically throws when dividing by 0</span></span><br><span class="line">    uint256 c = a / b;</span><br><span class="line">    <span class="comment">// assert(a == b * c + a % b); // There is no case in which this doesn&#x27;t hold</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">uint256 a, uint256 b</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">    assert(b &lt;= a);</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">uint256 a, uint256 b</span>) <span class="title">internal</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">    uint256 c = a + b;</span><br><span class="line">    assert(c &gt;= a);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SafeMath 库允许使用 using 关键字，它可以自动把库的所有方法添加给一个数据类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">using SafeMath <span class="keyword">for</span> uint;</span><br><span class="line"><span class="comment">// 这下我们可以为任何 uint 调用这些方法了</span></span><br><span class="line">uint test = <span class="number">2</span>;</span><br><span class="line">test = test.mul(<span class="number">3</span>); <span class="comment">// test 等于 6 了</span></span><br><span class="line">test = test.add(<span class="number">5</span>); <span class="comment">// test 等于 11 了</span></span><br></pre></td></tr></table></figure>

<p>所以简而言之， SafeMath 的 add， sub， mul， 和 div 方法只做简单的四则运算，然后在发生溢出或下溢的时候抛出错误。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"># 区块链</a>
              <a href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" rel="tag"># 智能合约</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/10/%E8%BF%85%E9%9B%B7%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/" rel="prev" title="迅雷案例分析">
      <i class="fa fa-chevron-left"></i> 迅雷案例分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/28/%E4%BB%A5%E5%A4%AA%E5%9D%8ADApp%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" rel="next" title="以太坊DApp实战笔记">
      以太坊DApp实战笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">1.</span> <span class="nav-text">入门说明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">文件结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">引用源文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">数据位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B0%94"><span class="nav-number">2.2.</span> <span class="nav-text">布尔</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">2.3.</span> <span class="nav-text">整型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80"><span class="nav-number">2.4.</span> <span class="nav-text">地址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#transfer"><span class="nav-number">2.4.1.</span> <span class="nav-text">transfer()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send"><span class="nav-number">2.4.2.</span> <span class="nav-text">send()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="nav-number">2.5.</span> <span class="nav-text">定长字节数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B-enum"><span class="nav-number">2.6.</span> <span class="nav-text">枚举类型(enum)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="nav-number">2.8.</span> <span class="nav-text">不定长字节数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.9.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.1.</span> <span class="nav-text">创建一个数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.2.</span> <span class="nav-text">Memory数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push%E6%96%B9%E6%B3%95"><span class="nav-number">2.10.3.</span> <span class="nav-text">push方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.4.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E5%92%8C%E5%8F%AF%E5%8F%98%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="nav-number">2.10.5.</span> <span class="nav-text">固定的字节数组和可变的字节数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.11.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">2.12.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6delete"><span class="nav-number">2.13.</span> <span class="nav-text">运算符delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">2.14.</span> <span class="nav-text">类型推断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BD%8D"><span class="nav-number">3.</span> <span class="nav-text">单位</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%A7%E5%B8%81%E5%8D%95%E4%BD%8D"><span class="nav-number">3.1.</span> <span class="nav-text">货币单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D-Time-Units"><span class="nav-number">3.2.</span> <span class="nav-text">时间单位(Time Units)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">内置特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F%E5%8F%8A%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">特殊变量及函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%92%8C%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">数学和加密函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-number">4.3.</span> <span class="nav-text">地址相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E7%BA%A6%E7%9B%B8%E5%85%B3"><span class="nav-number">4.4.</span> <span class="nav-text">合约相关</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6"><span class="nav-number">5.</span> <span class="nav-text">进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">5.1.</span> <span class="nav-text">控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.1.</span> <span class="nav-text">内部函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">外部函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">5.2.3.</span> <span class="nav-text">命名参数调用和匿名函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E5%87%BD%E6%95%B0%E5%90%8D%E7%A7%B0"><span class="nav-number">5.2.4.</span> <span class="nav-text">省略函数名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E5%AE%9E%E4%BE%8B"><span class="nav-number">5.3.</span> <span class="nav-text">创建合约实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC"><span class="nav-number">5.4.</span> <span class="nav-text">赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="nav-number">5.5.</span> <span class="nav-text">作用范围和声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">5.6.</span> <span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">5.7.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E7%BA%A6%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.</span> <span class="nav-text">合约详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E7%BA%A6"><span class="nav-number">6.1.</span> <span class="nav-text">合约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">构造函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-number">7.1.</span> <span class="nav-text">可见性和权限控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">访问函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">7.3.</span> <span class="nav-text">函数修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">7.4.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-1"><span class="nav-number">7.4.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.2.</span> <span class="nav-text">常函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">回退函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#payable"><span class="nav-number">7.6.</span> <span class="nav-text">payable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%90%E7%8E%B0"><span class="nav-number">7.7.</span> <span class="nav-text">提现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">7.8.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">7.9.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">7.9.1.</span> <span class="nav-text">基类构造器的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%89%E7%9B%B8%E5%90%8C%E5%90%8D%E5%AD%97%E7%9A%84%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-number">7.9.2.</span> <span class="nav-text">继承有相同名字的不同类型成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1-Abstract-Contracts"><span class="nav-number">7.10.</span> <span class="nav-text">抽象(Abstract Contracts)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.11.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Gas%E4%BC%98%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">Gas优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%8D%87%E7%BA%A7"><span class="nav-number">9.</span> <span class="nav-text">智能合约升级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E5%B8%81"><span class="nav-number">10.</span> <span class="nav-text">代币</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ERC-20"><span class="nav-number">10.1.</span> <span class="nav-text">ERC-20</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ERC-223"><span class="nav-number">10.2.</span> <span class="nav-text">ERC-223</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ERC-621"><span class="nav-number">10.3.</span> <span class="nav-text">ERC-621</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ERC-827"><span class="nav-number">10.4.</span> <span class="nav-text">ERC-827</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ERC-721"><span class="nav-number">10.5.</span> <span class="nav-text">ERC-721</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%93"><span class="nav-number">11.</span> <span class="nav-text">库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ownable"><span class="nav-number">11.1.</span> <span class="nav-text">Ownable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SafeMath"><span class="nav-number">11.2.</span> <span class="nav-text">SafeMath</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
