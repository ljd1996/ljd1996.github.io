<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ljd1996.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述构建流程    典型 Android 应用模块的构建流程通常依循下列步骤：  编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括 Android 设备上运行的字节码），将所有其他内容转换成已编译资源。 APK 打包器将 DEX 文件和已编译资源合并成单个 APK。 不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。 APK 打包器使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-Gradle笔记">
<meta property="og:url" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="概述构建流程    典型 Android 应用模块的构建流程通常依循下列步骤：  编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括 Android 设备上运行的字节码），将所有其他内容转换成已编译资源。 APK 打包器将 DEX 文件和已编译资源合并成单个 APK。 不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。 APK 打包器使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/构建流程.png">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/Android%20Build%20Process.png">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/解决与变体匹配相关的构建错误.png">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/依赖项版本号.png">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/abi分类.png">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/合并Manifest.png">
<meta property="og:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/清单元素合并策略和匹配键.png">
<meta property="article:published_time" content="2019-08-21T13:33:11.000Z">
<meta property="article:modified_time" content="2021-05-14T06:14:57.731Z">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="Gradle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/构建流程.png">

<link rel="canonical" href="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android-Gradle笔记 | 苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ljd1996.github.io/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android-Gradle笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-21 21:33:11" itemprop="dateCreated datePublished" datetime="2019-08-21T21:33:11+08:00">2019-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Gradle/" itemprop="url" rel="index"><span itemprop="name">Gradle</span></a>
                </span>
            </span>

          
            <span id="/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Android-Gradle笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/21/Android-Gradle%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><img src="构建流程.png" width="70%"/>

<img src="Android Build Process.png"/>

<p>典型 Android 应用模块的构建流程通常依循下列步骤：</p>
<ol>
<li>编译器将您的源代码转换成 DEX（Dalvik Executable) 文件（其中包括 Android 设备上运行的字节码），将所有其他内容转换成已编译资源。</li>
<li>APK 打包器将 DEX 文件和已编译资源合并成单个 APK。 不过，必须先签署 APK，才能将应用安装并部署到 Android 设备上。</li>
<li>APK 打包器使用调试或发布密钥库签署您的 APK：</li>
<li>在生成最终 APK 之前，打包器会使用 zipalign 工具对应用进行优化，减少其在设备上运行时占用的内存。</li>
</ol>
<p>简要步骤：</p>
<ul>
<li><code>Merged Manifest, Merged Resource, Merged Assets --&gt; aapt --&gt; R.java, Compiled Resource</code></li>
<li><code>R.java, Source Code --&gt; Java Compiler --&gt; .class files --&gt; proguard --&gt; proguarded.jar file --&gt; dex --&gt; .dex files</code></li>
<li><code>Compiled Resource, .dex files, .so files... --&gt; apkbuilder --&gt; .apk file --&gt; sign --&gt; sign.apk file --&gt; zipalign</code></li>
</ul>
<h2 id="构建配置文件"><a href="#构建配置文件" class="headerlink" title="构建配置文件"></a>构建配置文件</h2><p>Android Plugin for Gradle 引入了许多 DSL 元素，具体可参考：<a target="_blank" rel="noopener" href="http://google.github.io/android-gradle-dsl/current/index.html">DSL 参考文档</a></p>
<p>settings.gradle 文件位于项目根目录，用于指示 Gradle 在构建应用时应将哪些模块包括在内。对大多数项目而言，该文件很简单，只包括以下内容：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&#x27;:app&#x27;</span></span><br></pre></td></tr></table></figure>

<p>顶级 build.gradle 文件位于项目根目录，用于定义适用于项目中所有模块的构建配置。 默认情况下，此顶级构建文件使用 buildscript 代码块来定义项目中所有模块共用的 Gradle 存储区和依赖项。 </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The buildscript block is where you configure the repositories and</span></span><br><span class="line"><span class="comment"> * dependencies for Gradle itself—meaning, you should not include dependencies</span></span><br><span class="line"><span class="comment"> * for your modules here. For example, this block includes the Android plugin for</span></span><br><span class="line"><span class="comment"> * Gradle as a dependency because it provides the additional instructions Gradle</span></span><br><span class="line"><span class="comment"> * needs to build Android app modules.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The repositories block configures the repositories Gradle uses to</span></span><br><span class="line"><span class="comment">     * search or download the dependencies. Gradle pre-configures support for remote</span></span><br><span class="line"><span class="comment">     * repositories such as JCenter, Maven Central, and Ivy. You can also use local</span></span><br><span class="line"><span class="comment">     * repositories or define your own remote repositories. The code below defines</span></span><br><span class="line"><span class="comment">     * JCenter as the repository Gradle should use to look for its dependencies.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * New projects created using Android Studio 3.0 and higher also include</span></span><br><span class="line"><span class="comment">     * Google&#x27;s Maven repository.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The dependencies block configures the dependencies Gradle needs to use</span></span><br><span class="line"><span class="comment">     * to build your project. The following line adds Android plugin for Gradle</span></span><br><span class="line"><span class="comment">     * version 3.4.2 as a classpath dependency.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:3.4.2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The allprojects block is where you configure the repositories and</span></span><br><span class="line"><span class="comment"> * dependencies used by all modules in your project, such as third-party plugins</span></span><br><span class="line"><span class="comment"> * or libraries. However, you should configure module-specific dependencies in</span></span><br><span class="line"><span class="comment"> * each module-level build.gradle file. For new projects, Android Studio</span></span><br><span class="line"><span class="comment"> * includes JCenter and Google&#x27;s Maven repository by default, but it does not</span></span><br><span class="line"><span class="comment"> * configure any dependencies (unless you select a template that requires some).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">   repositories &#123;</span><br><span class="line">       google()</span><br><span class="line">       jcenter()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于包含多个模块的 Android 项目，在项目级别定义某些属性，并在所有模块间共享这些属性可能会非常有用。为此，可以将额外属性添加到顶级 build.gradle 文件的 ext 代码块中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;...&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This block encapsulates custom properties and makes them available to all</span></span><br><span class="line"><span class="comment">// modules in the project.</span></span><br><span class="line">ext &#123;</span><br><span class="line">    <span class="comment">// The following are only a few examples of the types of properties you can define.</span></span><br><span class="line">    compileSdkVersion = <span class="number">28</span></span><br><span class="line">    <span class="comment">// You can also create properties to specify versions for dependencies.</span></span><br><span class="line">    <span class="comment">// Having consistent versions between modules can avoid conflicts with behavior.</span></span><br><span class="line">    supportLibVersion = <span class="string">&quot;28.0.0&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要从相同项目中的模块访问这些属性，在模块的 build.gradle 文件中使用以下语法（虽然 Gradle 可在模块级别定义项目范围的属性，但应避免这样做，因为这样会导致共享这些属性的模块进行耦合）。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  <span class="comment">// Use the following syntax to access properties you defined at the project level:</span></span><br><span class="line">  <span class="comment">// rootProject.ext.property_name</span></span><br><span class="line">  compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&quot;com.android.support:appcompat-v7:$&#123;rootProject.ext.supportLibVersion&#125;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块级 build.gradle 文件位于各 project/module/ 目录中，用于配置适用于其所在模块的构建设置。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The first line in the build configuration applies the Android plugin for</span></span><br><span class="line"><span class="comment"> * Gradle to this build and makes the android block available to specify</span></span><br><span class="line"><span class="comment"> * Android-specific build options.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The android block is where you configure all your Android-specific</span></span><br><span class="line"><span class="comment"> * build options.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * compileSdkVersion specifies the Android API level Gradle should use to</span></span><br><span class="line"><span class="comment">   * compile your app. This means your app can use the API features included in</span></span><br><span class="line"><span class="comment">   * this API level and lower.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  compileSdkVersion <span class="number">28</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * buildToolsVersion specifies the version of the SDK build tools, command-line</span></span><br><span class="line"><span class="comment">   * utilities, and compiler that Gradle should use to build your app. You need to</span></span><br><span class="line"><span class="comment">   * download the build tools using the SDK Manager.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This property is optional because the plugin uses a recommended version of</span></span><br><span class="line"><span class="comment">   * the build tools by default.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  buildToolsVersion <span class="string">&quot;29.0.0&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The defaultConfig block encapsulates default settings and entries for all</span></span><br><span class="line"><span class="comment">   * build variants, and can override some attributes in main/AndroidManifest.xml</span></span><br><span class="line"><span class="comment">   * dynamically from the build system. You can configure product flavors to override</span></span><br><span class="line"><span class="comment">   * these values for different versions of your app.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  defaultConfig &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * applicationId uniquely identifies the package for publishing.</span></span><br><span class="line"><span class="comment">     * However, your source code should still reference the package name</span></span><br><span class="line"><span class="comment">     * defined by the package attribute in the main/AndroidManifest.xml file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    applicationId <span class="string">&#x27;com.example.myapp&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines the minimum API level required to run the app.</span></span><br><span class="line">    minSdkVersion <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specifies the API level used to test the app.</span></span><br><span class="line">    targetSdkVersion <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines the version number of your app.</span></span><br><span class="line">    versionCode <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Defines a user-friendly version name for your app.</span></span><br><span class="line">    versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The buildTypes block is where you can configure multiple build types.</span></span><br><span class="line"><span class="comment">   * By default, the build system defines two build types: debug and release. The</span></span><br><span class="line"><span class="comment">   * debug build type is not explicitly shown in the default build configuration,</span></span><br><span class="line"><span class="comment">   * but it includes debugging tools and is signed with the debug key. The release</span></span><br><span class="line"><span class="comment">   * build type applies Proguard settings and is not signed by default.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  buildTypes &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * By default, Android Studio configures the release build type to enable code</span></span><br><span class="line"><span class="comment">     * shrinking, using minifyEnabled, and specifies the Proguard settings file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    release &#123;</span><br><span class="line">        minifyEnabled <span class="literal">true</span> <span class="comment">// Enables code shrinking for the release build type.</span></span><br><span class="line">        proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The productFlavors block is where you can configure multiple product flavors.</span></span><br><span class="line"><span class="comment">   * This allows you to create different versions of your app that can</span></span><br><span class="line"><span class="comment">   * override the defaultConfig block with their own settings. Product flavors</span></span><br><span class="line"><span class="comment">   * are optional, and the build system does not create them by default.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This example creates a free and paid product flavor. Each product flavor</span></span><br><span class="line"><span class="comment">   * then specifies its own application ID, so that they can exist on the Google</span></span><br><span class="line"><span class="comment">   * Play Store, or an Android device, simultaneously.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If you declare product flavors, you must also declare flavor dimensions</span></span><br><span class="line"><span class="comment">   * and assign each flavor to a flavor dimension.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  flavorDimensions <span class="string">&quot;tier&quot;</span></span><br><span class="line">  productFlavors &#123;</span><br><span class="line">    free &#123;</span><br><span class="line">      dimension <span class="string">&quot;tier&quot;</span></span><br><span class="line">      applicationId <span class="string">&#x27;com.example.myapp.free&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    paid &#123;</span><br><span class="line">      dimension <span class="string">&quot;tier&quot;</span></span><br><span class="line">      applicationId <span class="string">&#x27;com.example.myapp.paid&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The splits block is where you can configure different APK builds that</span></span><br><span class="line"><span class="comment">   * each contain only code and resources for a supported screen density or</span></span><br><span class="line"><span class="comment">   * ABI. You&#x27;ll also need to configure your build so that each APK has a</span></span><br><span class="line"><span class="comment">   * different versionCode.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  splits &#123;</span><br><span class="line">    <span class="comment">// Settings to build multiple APKs based on screen density.</span></span><br><span class="line">    density &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Enable or disable building multiple APKs.</span></span><br><span class="line">      enable <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Exclude these densities when building multiple APKs.</span></span><br><span class="line">      exclude <span class="string">&quot;ldpi&quot;</span>, <span class="string">&quot;tvdpi&quot;</span>, <span class="string">&quot;xxxhdpi&quot;</span>, <span class="string">&quot;400dpi&quot;</span>, <span class="string">&quot;560dpi&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The dependencies block in the module-level build configuration file</span></span><br><span class="line"><span class="comment"> * specifies dependencies required to build only the module itself.</span></span><br><span class="line"><span class="comment"> * To learn more, go to Add build dependencies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">&quot;:lib&quot;</span>)</span><br><span class="line">    implementation <span class="string">&#x27;com.android.support:appcompat-v7:28.0.0&#x27;</span></span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gradle 还包括两个属性文件，均位于项目根目录中，可用于指定适用于 Gradle 构建工具包本身的设置：</p>
<ul>
<li>gradle.properties：可以在其中配置项目范围 Gradle 设置，例如 Gradle 后台进程的最大堆大小。 如需了解详细信息，请参阅构建环境。</li>
<li>local.properties：为构建系统配置本地环境属性，例如 SDK 安装路径。由于该文件的内容由 Android Studio 自动生成并且专用于本地开发者环境，因此不应手动修改该文件，或将其纳入版本控制系统。</li>
</ul>
<p>Android Studio 按逻辑关系将每个模块的源代码和资源分组为源集。模块的 main/ 源集包括其所有构建变体使用的代码和资源。其他源集目录为可选项，在配置新的构建变体时，Android Studio 不会自动为您创建这些目录。不过，创建类似于 main/ 的源集有助于让 Gradle 仅在构建特定应用版本时才应使用的文件和资源井然有序：</p>
<ul>
<li>src/main/：此源集包括所有构建变体共用的代码和资源。</li>
<li>src/buildType/：创建此源集可加入特定构建类型专用的代码和资源。</li>
<li>src/productFlavor/：创建此源集可加入特定产品风格专用的代码和资源。（注：如果配置构建以组合多个产品风格，则可为风格维度间产品风格的各个组合创建源集目录： src/productFlavor1ProductFlavor2/）</li>
<li>src/productFlavorBuildType/：创建此源集可加入特定构建变体专用的代码和资源。</li>
</ul>
<p>例如，要生成应用的“完整调试”版本，构建系统需要合并来自以下源集的代码、设置和资源：</p>
<ul>
<li>src/fullDebug/（构建变体源集）</li>
<li>src/debug/（构建类型源集）</li>
<li>src/full/（产品风格源集）</li>
<li>src/main/（主源集）</li>
</ul>
<p>注：当在 Android Studio 中使用 File &gt; New 菜单选项新建文件或目录时，可以针对特定源集进行创建。 可供您选择的源集取决于您的构建配置，如果所需目录尚不存在，Android Studio 会自动创建。</p>
<p>如果不同源集包含同一文件的不同版本，Gradle 将按以下优先顺序决定使用哪一个文件（左侧源集替换右侧源集的文件和设置）：</p>
<ul>
<li>构建变体 &gt; 构建类型 &gt; 产品风格 &gt; 主源集 &gt; 库依赖项</li>
</ul>
<p>这样一来，Gradle 便可使用专用于您试图构建的构建变体的文件，同时对与其他应用版本共用的 Activity、应用逻辑和资源加以重复利用。 在合并多个清单时，Gradle 使用同一优先顺序，这样每个构建变体都能在最终清单中定义不同的组件或权限。 </p>
<p>android对象为我们提供了3个属性：</p>
<ul>
<li>applicationVariants (仅仅适用于Android应用Gradle插件)</li>
<li>libraryVariants (仅仅适用于Android库Gradle插件)</li>
<li>testVariants (以上两种Gradle插件都使用)</li>
</ul>
<h1 id="SDK-Version"><a href="#SDK-Version" class="headerlink" title="SDK Version"></a>SDK Version</h1><h2 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h2><p>compileSdkVersion仅仅是告诉Gradle使用哪个版本的SDK编译应用，不会被包含到apk中，完全不影响应用的运行结果，关注compileSdkVersion版本的原因：</p>
<ul>
<li>应用想兼容新版本、使用了新版本API，此时就必须使用新版本及以上版本编译，否则就会编译报错；</li>
<li>如果使用了新版本的Support Library，此时也必须使用新版本及以上版本编译；</li>
<li>推荐使用最新版本编译，用新的编译检查，可以看到很多新版本相关的警告，提前预研新版本开发；</li>
</ul>
<h2 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h2><ol>
<li>minSdkVersion表明此应用兼容的最低版本，在低于该版本的手机上安装时会报错，无法安装；</li>
<li>如果最低版本设置为19，在代码中使用了API 23中的API，就会有警告。使用运行时检查系统版本的方式可解决；</li>
<li>如果使用的某个Support Library的最低版本为7，那minSdkVersion就必须大于等于7了，否则该Support Library在低于7的手机中就要报错了。</li>
</ol>
<h2 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h2><ol>
<li>如果targetSdkVersion为19（对应为Android4.4），应用运行时，最高只能使用API 19的新特性。即使代码中使用了API 23的新特性，实际运行时，也不会使用该新特性；</li>
<li>同样的API，比如AlarmManger的set()和get()方法，在API 19和之前的效果是不一样的，如果targetSdkVersion为18，无论运行手机是什么版本，都是旧效果；如果targetSdkVersion为19，那么在4.4以上的手机上运行时，就是新效果了。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所诉，compileSdkVersion决定了编译期间能否使用新版本的API。targetSDKVersion决定了运行期间使用哪种特性。建议用较低的minSdkVersion来覆盖最大的人群，用最新的compileSdkVersion和targetSDKVersion来获得最好的外观和行为。即：maxSdkVersion &gt;= buildToolsVersion &gt;= compileSdkVersion&gt;= targetSdkVersion &gt;= minSdkVersion</p>
<h1 id="Set-the-Application-ID"><a href="#Set-the-Application-ID" class="headerlink" title="Set the Application ID"></a>Set the Application ID</h1><h2 id="设置Application-ID"><a href="#设置Application-ID" class="headerlink" title="设置Application ID"></a>设置Application ID</h2><p>应用 ID 通过模块的 build.gradle 文件中的 applicationId 属性定义，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">24</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用 ID 和软件包名称彼此无关，可以更改代码的软件包名称（代码命名空间），这不会影响应用 ID，反之亦然。Application ID的命名规则的限制：</p>
<ul>
<li>必须至少包含两段（一个或多个圆点）。</li>
<li>每段必须以字母开头。</li>
<li>所有字符必须为字母数字或下划线 [a-zA-Z0-9_]。</li>
</ul>
<p>注意：</p>
<ul>
<li>应用 ID 过去直接关联到代码的软件包名称；所以，有些 Android API 会在其方法名称和参数名称中使用“package name”一词，但这实际上是Application ID。例如，Context.getPackageName() 方法会返回您的应用 ID。</li>
<li>使用 WebView的话，Application ID 中应将软件包名称用作前缀；否则，可能会遇到如<a target="_blank" rel="noopener" href="https://code.google.com/p/android/issues/detail?id=211768&hl=zh-CN">问题 211768</a> 中所述的问题。</li>
</ul>
<h2 id="更改用于编译变体的Application-ID"><a href="#更改用于编译变体的Application-ID" class="headerlink" title="更改用于编译变体的Application ID"></a>更改用于编译变体的Application ID</h2><p>每个编译变体应定义为单独的产品特性。对于 productFlavors 块中的每个类型，可以重新定义 applicationId 属性，也可以使用 applicationIdSuffix 在默认的应用 ID 上追加一段，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        free &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.free&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        pro &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.pro&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以根据自己的版本类型使用 applicationIdSuffix 追加一段，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.debug&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Gradle 会在产品特性后面应用版本类型配置，因此“free debug”编译变体的应用 ID 现在是“com.example.myapp.free.debug”。</p>
<p>注意：</p>
<ul>
<li>为了与以前的 SDK 工具兼容，如果未在 build.gradle 文件中定义 applicationId 属性，构建工具会将 AndroidManifest.xml 文件中的软件包名称用作应用 ID。在这种情况下，重构软件包名称也会更改您的应用 ID。</li>
<li>如果需要在清单文件中引用应用 ID，可以在任何清单属性中使用 ${applicationId} 占位符。在编译期间，Gradle 会将此标记替换为实际的应用 ID。</li>
</ul>
<h2 id="更改用于测试的应用-ID"><a href="#更改用于测试的应用-ID" class="headerlink" title="更改用于测试的应用 ID"></a>更改用于测试的应用 ID</h2><p>默认情况下，构建工具会将应用 ID 应用到您的测试 APK，该 APK 将应用 ID 用于给定的编译变体，同时追加 .test。例如，com.example.myapp.free 编译变体的测试 APK 的应用 ID 为 com.example.myapp.free.test。</p>
<p>可以通过在 defaultConfig 或 productFlavor 块中定义 testApplicationId 属性来更改应用 ID，不过应该没有必要这样做。</p>
<p>注意：为了避免与受测应用发生名称冲突，构建工具会为您的测试 APK 生成 R 类，其命名空间基于测试应用 ID，而不是清单文件中定义的软件包名称。</p>
<h2 id="更改软件包名称"><a href="#更改软件包名称" class="headerlink" title="更改软件包名称"></a>更改软件包名称</h2><p>默认情况下，项目的软件包名称与应用 ID 匹配，但您可以更改软件包名称。不过，如果您要更改软件包名称，需要注意的是，软件包名称（由项目目录结构定义）应始终与 AndroidManifest.xml 文件中的 package 属性匹配，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.myapp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">&quot;1.0&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>Android 构建工具使用 package 属性来发挥两种作用：</p>
<ul>
<li>它会将此名称用作应用生成的 R.java 类的命名空间。示例：对于上面的清单，R 类将为 com.example.myapp.R。</li>
<li>它会使用此名称解析清单文件中声明的任何相关类名。示例：对于上面的清单，声明为 <code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;</code> 的 Activity 将解析为 com.example.myapp.MainActivity。</li>
</ul>
<p>因此，package 属性中的名称应始终与项目的基础软件包名称匹配，基础软件包中保存着您的 Activity 及其他应用代码。当然，您的项目中可以包含子软件包，但是这些文件必须从 package 属性导入使用命名空间的 R.java 类，而且清单中声明的任何应用组件都必须添加缺失的子软件包名称（或者使用完全限定软件包名称）。</p>
<p>如果您要完全重构您的软件包名称，请确保也更新 package 属性。只要您使用 Android Studio 的工具重命名和重构您的软件包，那么这些就会自动保持同步。（如果它们未保持同步，您的应用代码将无法解析 R 类，因为它不再位于同一软件包中，并且清单无法识别您的 Activity 或其他组件。）</p>
<p>您必须始终在项目的主 AndroidManifest.xml 文件中指定 package 属性。如果您有其他清单文件（如产品特性或版本类型的清单文件），请注意，优先级最高的清单文件提供的软件包名称始终用于最终合并的清单。</p>
<p>还有一点需要了解：虽然清单 package 和 Gradle applicationId 可以具有不同的名称，但构建工具会在编译结束时将应用 ID 复制到 APK 的最终清单文件中。所以，如果您在编译后检查 AndroidManifest.xml 文件，发现 package 属性发生更改就不足为奇了。实际上，Google Play 商店和 Android 平台会查看 package 属性来识别您的应用。所以，编译系统利用原始值（设置 R 类的命名空间并解析清单类名称）后，它会舍弃该值并将其替换为应用 ID。</p>
<h1 id="Add-the-dependencies"><a href="#Add-the-dependencies" class="headerlink" title="Add the dependencies"></a>Add the dependencies</h1><p>指定依赖项时，不应使用动态版本号，比如 <code>&#39;com.android.tools.build:gradle:3.+&#39;</code>。 使用此功能，可能会导致意外版本更新和难以解析版本差异。</p>
<h2 id="依赖项类型"><a href="#依赖项类型" class="headerlink" title="依赖项类型"></a>依赖项类型</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"></span><br><span class="line">android &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Dependency on a local library module</span></span><br><span class="line">    implementation project(<span class="string">&quot;:mylibrary&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dependency on local binaries</span></span><br><span class="line">    implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dependency on a remote binary</span></span><br><span class="line">    implementation <span class="string">&#x27;com.example.android:app-magic:12.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="本地库模块依赖项"><a href="#本地库模块依赖项" class="headerlink" title="本地库模块依赖项"></a>本地库模块依赖项</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(<span class="string">&#x27;:mylibrary&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码声明名为“mylibrary”的 Android 库模块的依赖项（该名称必须匹配使用 settings.gradle 文件中的 include: 定义的库名称）。在构建应用时，构建系统会编译库模块，并将生成的编译内容打包到 APK中。</p>
<h3 id="本地二进制文件依赖项"><a href="#本地二进制文件依赖项" class="headerlink" title="本地二进制文件依赖项"></a>本地二进制文件依赖项</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>Gradle 声明项目 module_name/libs/ 目录中 JAR 文件的依赖项（因为 Gradle 会读取 build.gradle 文件的相对路径）。或者，也可以像下面这样指定单独的文件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation files(<span class="string">&#x27;libs/foo.jar&#x27;</span>, <span class="string">&#x27;libs/bar.jar&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="远程二进制文件依赖项"><a href="#远程二进制文件依赖项" class="headerlink" title="远程二进制文件依赖项"></a>远程二进制文件依赖项</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.example.android:app-magic:12.3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以上代码实际上是下列代码的缩写形式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="attr">group:</span> <span class="string">&#x27;com.example.android&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;app-magic&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;12.3&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这段代码声明<code>com.example.android</code>命名空间组内“app-magic”库 12.3 版本的依赖项。</p>
<p>注：与此类似的远程依赖项要求您声明相应的远程代码库，Gradle 应在其中寻找该库。如果本地尚不存在该库，Gradle 会在构建需要它时（例如，当您点击 Sync Project with Gradle Files 或当您运行构建时）从远程站点获取该库。</p>
<h2 id="依赖项配置"><a href="#依赖项配置" class="headerlink" title="依赖项配置"></a>依赖项配置</h2><table>
<thead>
<tr>
<th align="left">新配置</th>
<th align="left">已弃用配置</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="left">implementation</td>
<td align="left">compile</td>
<td align="left">Gradle 会将依赖项添加到编译类路径，并将依赖项打包到构建输出。但是，当您的模块配置 implementation 依赖项时，会告知 Gradle 您不想模块在编译时将依赖项泄露给其他模块。也就是说，依赖项只能在运行时供其他模块使用。使用此依赖项配置而不是api 或 compile（已弃用），可以显著缩短构建时间，因为它可以减少构建系统需要重新编译的模块数量。例如，如果 implementation 依赖项更改了其 API，Gradle 只会重新编译该依赖项和直接依赖它的模块。大多数应用和测试模块都应使用此配置。</td>
</tr>
<tr>
<td align="left">api</td>
<td align="left">compile</td>
<td align="left">Gradle 会将依赖项添加到编译类路径，并构建输出。当模块包括 api 依赖项时，会告知 Gradle 模块想将该依赖项间接导出至其他模块，以使这些模块在运行时和编译时均可使用该依赖项。此配置的行为类似于 compile （现已弃用），但您应仅对需要间接导出至其他上游消费者的依赖项慎重使用它。 这是因为，如果 api 依赖项更改了其外部 API，Gradle 会重新编译可以在编译时访问该依赖项的所有模块。 因此，拥有大量 api 依赖项会显著增加构建时间。 如果不想向不同的模块公开依赖项的 API，库模块应改用 implementation 依赖项。</td>
</tr>
<tr>
<td align="left">compileOnly</td>
<td align="left">provided</td>
<td align="left">Gradle 只会将依赖项添加到编译类路径（即不会将其添加到构建输出）。如果是创建 Android 模块且在编译期间需要使用该依赖项，在运行时可选择呈现该依赖项，则此配置会很有用。如果使用此配置，则您的库模块必须包含运行时条件，以便检查是否提供该依赖项，然后妥善更改其行为，以便模块在未提供依赖项的情况下仍可正常工作。这样做不会添加不重要的瞬时依赖项，有助于缩减最终 APK 的大小。 此配置的行为类似于 provided （现已弃用）。</td>
</tr>
<tr>
<td align="left">runtimeOnly</td>
<td align="left">apk</td>
<td align="left">Gradle 只会将依赖项添加到构建输出，供运行时使用。也就是说，不会将其添加到编译类路径。 此配置的行为类似于 apk（现已弃用）。</td>
</tr>
<tr>
<td align="left">annotationProcessor</td>
<td align="left">compile</td>
<td align="left">要在库中添加注解处理器依赖项，则必须使用 annotationProcessor 配置将其添加到注解处理器类路径。这是因为使用此配置可分离编译类路径与注解处理器类路径，从而提升构建性能。如果 Gradle 在编译类路径上找到注解处理器，则会停用 避免编译功能，这样会增加构建时间（Gradle 5.0 和更高版本会忽略编译类路径上的注解处理器）。如果 JAR 文件包含以下文件，则 Android Gradle Plugin 会假定依赖项是注解处理器：META-INF/services/javax.annotation.processing.Processor。如果插件检测到编译类路径上包含注解处理器，则会生成构建错误。</td>
</tr>
</tbody></table>
<p>以上配置适用于您的项目的主源集，该源集应用于所有构建不同类型。 如果您改为只想为特定构建不同类型源集或测试源集声明依赖项，则必须大写配置名称并在其前面加上构建不同类型或测试源集的名称作为前缀。</p>
<p>例如，要仅将 implementation 依赖项添加到您的“free”产品风格（使用远程二进制文件依赖项），需要使用下面这样的代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    freeImplementation <span class="string">&#x27;com.google.firebase:firebase-ads:9.8.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果想要为组合产品风格和构建类型的变体添加依赖项，则必须在 configurations 代码块中初始化配置名称。 以下示例向您的“freeDebug”构建变体添加 runtimeOnly 依赖项（使用本地二进制文件依赖项）：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    <span class="comment">// Initializes a placeholder for the freeDebugRuntimeOnly dependency</span></span><br><span class="line">    <span class="comment">// configuration.</span></span><br><span class="line">    freeDebugRuntimeOnly &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    freeDebugRuntimeOnly fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要为您的本地测试和设备化测试添加 implementation 依赖项，需要使用下面这样的代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Adds a remote binary dependency only for local tests.</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a remote binary dependency only for the instrumented test APK.</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;com.android.support.test.espresso:espresso-core:3.0.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但某些配置在这种情况下没有意义。 例如，由于其他模块无法依赖 androidTest，因此如果使用 androidTestApi 配置，则会收到以下警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Configuration &#39;androidTestApi&#39; is obsolete and has been replaced with &#39;androidTestImplementation&#39;.</span><br></pre></td></tr></table></figure>

<h3 id="添加注解处理器"><a href="#添加注解处理器" class="headerlink" title="添加注解处理器"></a>添加注解处理器</h3><p>如果将注解处理器添加到您的编译类路径，您将看到一条与以下消息类似的错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Annotation processors must be explicitly declared now.</span><br></pre></td></tr></table></figure>

<p>要解决此错误问题，请使用 annotationProcessor 配置您的依赖项，以在您的项目中添加注解处理器，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Adds libraries defining annotations to only the compile classpath.</span></span><br><span class="line">    compileOnly <span class="string">&#x27;com.google.dagger:dagger:version-number&#x27;</span></span><br><span class="line">    <span class="comment">// Adds the annotation processor dependency to the annotation processor classpath.</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;com.google.dagger:dagger-compiler:version-number&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要向注解处理器传递参数，您可以在您的模块构建配置中使用 AnnotationProcessorOptions 代码块。 例如，如果要以键值对形式传递原始数据类型，则可使用 argument 属性，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                argument <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span></span><br><span class="line">                argument <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在使用 Android Gradle Plugin 3.2.0 和更高版本时，您需要使用 Gradle CommandLineArgumentProvider 接口传递表示文件或目录的处理器参数。使用 CommandLineArgumentProvider 可让您或注解处理器作者将增量构建属性类型注解应用于每个参数，从而提高增量构建和缓存干净构建的正确性和性能。</p>
<p>例如，下面的类可实现 CommandLineArgumentProvider 并注解处理器的每个参数。 此外，此示例也使用 Groovy 语言语法，且直接包含在模块的 build.gradle 文件中。</p>
<p>注：通常，注解处理器作者会提供此类或有关如何编写这种类的说明。这是因为每个参数均需指定正确的构建属性类型注解，才能按预期运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArgsProvider</span> <span class="keyword">implements</span> <span class="title">CommandLineArgumentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotates each directory as either an input or output for the</span></span><br><span class="line">    <span class="comment">// annotation processor.</span></span><br><span class="line">    <span class="meta">@InputFiles</span></span><br><span class="line">    <span class="comment">// Using this annotation helps Gradle determine which part of the file path</span></span><br><span class="line">    <span class="comment">// should be considered during up-to-date checks.</span></span><br><span class="line">    <span class="meta">@PathSensitive(PathSensitivity.RELATIVE)</span></span><br><span class="line">    FileCollection inputDir</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OutputDirectory</span></span><br><span class="line">    File outputDir</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The class constructor sets the paths for the input and output directories.</span></span><br><span class="line">    MyArgsProvider(FileCollection input, File output) &#123;</span><br><span class="line">        inputDir = input</span><br><span class="line">        outputDir = output</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specifies each directory as a command line argument for the processor.</span></span><br><span class="line">    <span class="comment">// The Android plugin uses this method to pass the arguments to the</span></span><br><span class="line">    <span class="comment">// annotation processor.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Iterable&lt;String&gt; <span class="title">asArguments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use the form &#x27;-Akey[=value]&#x27; to pass your options to the Java compiler.</span></span><br><span class="line">        [<span class="string">&quot;-AinputDir=$&#123;inputDir.singleFile.absolutePath&#125;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;-AoutputDir=$&#123;outputDir.absolutePath&#125;&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在创建实现 CommandLineArgumentProvider 的类后，您需要使用 annotationProcessorOptions.compilerArgumentProvider 属性初始化并将其传递至 Android 插件，如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is in your module&#x27;s build.gradle file.</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                <span class="comment">// Creates a new MyArgsProvider object, specifies the input and</span></span><br><span class="line">                <span class="comment">// output paths for the constructor, and passes the object</span></span><br><span class="line">                <span class="comment">// to the Android plugin.</span></span><br><span class="line">                compilerArgumentProvider <span class="keyword">new</span> MyArgsProvider(files(<span class="string">&quot;input/path&quot;</span>),</span><br><span class="line">                                         <span class="keyword">new</span> File(<span class="string">&quot;output/path&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译类路径中的依赖项包含您不需要的注解处理器，您可以将以下代码添加到 build.gradle 文件中，停用错误检查。 请记住，您添加到编译类路径中的注解处理器仍不会添加到处理器类路径中。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                includeCompileClasspath <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您将项目的注解处理器迁移到处理器类路径后遇到问题，可通过将 includeCompileClasspath 设置为 true，允许编译类路径上包含注解处理器。 但是，我们不建议将此属性设置为 true，并且我们将在以后的 Android plugin 更新版本中移除这种操作的相关选项。</p>
<h3 id="排除传递依赖项"><a href="#排除传递依赖项" class="headerlink" title="排除传递依赖项"></a>排除传递依赖项</h3><p>随着应用范围的扩大，其中可包含许多依赖项，包括直接依赖项和传递依赖项（应用的导入库所依赖的库）。 要排除不再需要的传递依赖项，您可以使用 exclude 关键字，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&#x27;some-library&#x27;</span>) &#123;</span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&#x27;com.example.imgtools&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;native&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要从您的测试中排除某些传递依赖项，上文所示的代码示例可能无法按预期发挥作用。 这是因为测试配置（例如 androidTestImplementation）扩展了模块的 implementation 配置。 也就是说，在 Gradle 解析配置时其中始终包含 implementation 依赖项。</p>
<p>因此，要从测试中排除传递依赖项，必须在执行代码时执行此操作，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android.testVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.getCompileConfiguration().exclude <span class="attr">group:</span> <span class="string">&#x27;com.jakewharton.threetenabp&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;threetenabp&#x27;</span></span><br><span class="line">    variant.getRuntimeConfiguration().exclude <span class="attr">group:</span> <span class="string">&#x27;com.jakewharton.threetenabp&#x27;</span>, <span class="attr">module:</span> <span class="string">&#x27;threetenabp&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-variant-aware-依赖项管理"><a href="#使用-variant-aware-依赖项管理" class="headerlink" title="使用 variant-aware 依赖项管理"></a>使用 variant-aware 依赖项管理</h2><p>Android 插件 3.0.0 及更高版本包含一项新的依赖项机制，这种机制可以在消费库时自动匹配不同类型。 也就是说，应用的 debug 不同类型将自动消费库的 debug 不同类型，依此类推。 这种机制也适用于使用风格的情况—应用的 freeDebug 变体将使用库的 freeDebug 变体。</p>
<p>要让插件准确匹配变体，您需要为无法直接匹配的情况提供匹配回退。 假设您的应用配置一个名为“staging”的构建类型，但其库依赖项之一没有进行相应配置。 在插件尝试构建您的“staging”版本的应用时，它将无法了解库要使用哪一个版本，您将看到一条类似以下消息的错误消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:Failed to resolve: Could not resolve project :mylibrary.</span><br><span class="line">Required by:</span><br><span class="line">    project :app</span><br></pre></td></tr></table></figure>

<img src="解决与变体匹配相关的构建错误.png"/>

<h2 id="远程代码库"><a href="#远程代码库" class="headerlink" title="远程代码库"></a>远程代码库</h2><p>如果您的依赖项并非本地库或文件树，Gradle 会在您的 build.gradle 文件 repositories 程序块中指定的任何一个在线代码库中寻找文件。 列出各代码库的顺序决定了 Gradle 在这些代码库中搜索各项目依赖项的顺序。 例如，如果代码库 A 和 B 都提供某依赖项，而您先列出代码库 A，则 Gradle 会从代码库 A 下载此依赖项。</p>
<p>默认情况下，Android Studio 新项目会在项目的顶级 build.gradle 文件中指定 Google 的 Maven 代码库和 JCenter 作为代码库位置，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您需要的内容来自 Maven 中央代码库，则添加 mavenCentral()；如果来自本地代码库，则使用 mavenLocal()，或者也可像下面这样声明特定 Maven 或 Ivy 代码库：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;https://repo.example.com/maven2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;file://local/repo/&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ivy &#123;</span><br><span class="line">            url <span class="string">&quot;https://repo.example.com/ivy&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="依赖项顺序"><a href="#依赖项顺序" class="headerlink" title="依赖项顺序"></a>依赖项顺序</h2><p>例如，如果您的项目声明以下内容：</p>
<ul>
<li>LIB_A 和 LIB_B 上的依赖项（按照该顺序）</li>
<li>并且 LIB_A 依赖 LIB_C 和 LIB_D （按照该顺序）</li>
<li>并且 LIB_B 还依赖 LIB_C</li>
</ul>
<p>然后，扁平型依赖项顺序将如下所示：</p>
<ul>
<li>LIB_A</li>
<li>LIB_D</li>
<li>LIB_B</li>
<li>LIB_C</li>
</ul>
<h2 id="查看依赖项树"><a href="#查看依赖项树" class="headerlink" title="查看依赖项树"></a>查看依赖项树</h2><p>运行<code>gradle androidDependencies</code>即可查看依赖项树。</p>
<h2 id="修复依赖项解析错误"><a href="#修复依赖项解析错误" class="headerlink" title="修复依赖项解析错误"></a>修复依赖项解析错误</h2><h3 id="修复重复类错误"><a href="#修复重复类错误" class="headerlink" title="修复重复类错误"></a>修复重复类错误</h3><p>如果某类多次出现在运行时类路径中，您会收到一条与以下内容相似的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program type already present com.example.MyClass</span><br></pre></td></tr></table></figure>

<p>该错误通常是下列其中一种情况所致：</p>
<ul>
<li>二进制文件依赖项包括您的应用同时作为直接依赖项包括的库。 例如，您的应用在库 A 和库 B 上声明了直接依赖项，但库 A 的二进制文件中已包括库 B：要解决此问题，请取消将库 B 作为直接依赖项。</li>
<li>您的应用在同一库上具有本地二进制文件依赖项和远程二进制文件依赖项：要解决此问题，请移除其中一个二进制文件依赖项。</li>
</ul>
<h3 id="解决类路径之间的冲突问题"><a href="#解决类路径之间的冲突问题" class="headerlink" title="解决类路径之间的冲突问题"></a>解决类路径之间的冲突问题</h3><p>当 Gradle 解析编译类路径时，会先解析运行时类路径，然后使用此结果确定应添加到编译类路径的依赖项版本。 换言之，运行时类路径决定下游类路径的相同依赖项所需的版本号。</p>
<p>应用的运行时类路径还决定 Gradle 匹配运行类路径中应用测试 APK 的依赖项所需要的版本号：</p>
<img src="依赖项版本号.png"/>

<p>如果相同依赖项的冲突版本出现在多个类路径中，您可能会看到与以下内容相似的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conflict with dependency &#39;com.example.library:some-lib:2.0&#39; in project &#39;my-library&#39;.</span><br><span class="line">Resolved versions for runtime classpath (1.0) and compile classpath (2.0) differ.</span><br></pre></td></tr></table></figure>

<p>例如，当您的应用使用 implementation 依赖项配置加入某依赖项版本，并且库模块使用 runtimeOnly 配置加入此依赖项的不同版本时，可能会发生该冲突。 要解决此问题，请执行以下其中一项操作：</p>
<ul>
<li>将所需版本的依赖项作为 api 依赖项加入您的库模块。 也就是说，仅库模块声明此依赖项，但应用模块也可间接访问其 API。</li>
<li>或者，您也可以同时在两个模块中声明此依赖项，但应确保每个模块使用的版本相同。 请考虑配置项目范围的属性，以确保各依赖项的多个版本在整个项目中都保持一致。</li>
</ul>
<h2 id="应用自定义构建逻辑"><a href="#应用自定义构建逻辑" class="headerlink" title="应用自定义构建逻辑"></a>应用自定义构建逻辑</h2><p>本节介绍的内容在您想要扩展 Android Gradle Plugin 或编写自己的插件时很有用。</p>
<h3 id="为自定义逻辑发布变体依赖项"><a href="#为自定义逻辑发布变体依赖项" class="headerlink" title="为自定义逻辑发布变体依赖项"></a>为自定义逻辑发布变体依赖项</h3><p>库可以包含其他项目或子项目可能要使用的功能。 发布库是为其消费者提供库的流程。 库可以控制其消费者在编译时和运行时可访问的依赖项。现有两种不同的配置，其中包含消费者为使用库而必须使用的各类路径的传递依赖项，如下所述：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variant_nameApiElements：此配置包含编译时消费者可使用的传递依赖项。</span><br><span class="line">variant_nameRuntimeElements：此配置包含运行时消费者可使用的传递依赖项。</span><br></pre></td></tr></table></figure>

<h3 id="自定义依赖项解析策略"><a href="#自定义依赖项解析策略" class="headerlink" title="自定义依赖项解析策略"></a>自定义依赖项解析策略</h3><p>项目包含的依赖项可能包含在相同库的两个不同版本中，这样会导致依赖项冲突。例如，如果您的项目依赖于模块 A 的版本 1 和模块 B 的版本 2，模块 A 间接依赖于模块 B 的版本 3，则会出现依赖项版本冲突。</p>
<p>要解决此冲突问题，Android Gradle Plugin 需使用以下依赖项解析策略：当插件检测到依赖图中包含相同模块的不同版本时，会默认选择版本最高的模块。但此策略可能无法按预期发挥作用。 要自定义依赖项解析策略，请使用以下配置解析您任务所需变体的特定依赖项：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variant_nameCompileClasspath：此配置包含适用于给定变体编译类路径的解析策略。</span><br><span class="line">variant_nameRuntimeClasspath：此配置包含适用于给定变体运行时类路径的解析策略。</span><br></pre></td></tr></table></figure>

<p>Android Gradle Plugin 包含可用于访问各变体配置对象的 getter。 因此，您可以使用变体 API 查询依赖项解析策略，如下例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        <span class="comment">// Return compile configuration objects of a variant.</span></span><br><span class="line">        variant.getCompileConfiguration().resolutionStrategy &#123;</span><br><span class="line">        <span class="comment">// Use Gradle&#x27;s ResolutionStrategy API</span></span><br><span class="line">        <span class="comment">// to customize how this variant resolves dependencies.</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return runtime configuration objects of a variant.</span></span><br><span class="line">        variant.getRuntimeConfiguration().resolutionStrategy &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Return annotation processor configuration of a variant.</span></span><br><span class="line">        variant.getAnnotationProcessorConfiguration().resolutionStrategy &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置编译变体"><a href="#配置编译变体" class="headerlink" title="配置编译变体"></a>配置编译变体</h1><h2 id="配置版本类型"><a href="#配置版本类型" class="headerlink" title="配置版本类型"></a>配置版本类型</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        manifestPlaceholders = [<span class="attr">hostName:</span><span class="string">&quot;www.example.com&quot;</span>]</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.debug&quot;</span></span><br><span class="line">            debuggable <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * The `initWith` property allows you to copy configurations from other build types,</span></span><br><span class="line"><span class="comment">            * then configure only the settings you want to change. This one copies the debug build</span></span><br><span class="line"><span class="comment">            * type, and then changes the manifest placeholder and application ID.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        staging &#123;</span><br><span class="line">            initWith debug</span><br><span class="line">            manifestPlaceholders = [<span class="attr">hostName:</span><span class="string">&quot;internal.example.com&quot;</span>]</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.debugStaging&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置产品特性"><a href="#配置产品特性" class="headerlink" title="配置产品特性"></a>配置产品特性</h2><h3 id="配置产品特性-1"><a href="#配置产品特性-1" class="headerlink" title="配置产品特性"></a>配置产品特性</h3><p>创建产品特性与创建版本类型类似：将其添加到编译配置中的 productFlavors 代码块并添加所需的设置。产品特性支持与 defaultConfig 相同的属性，这是因为 defaultConfig 实际上属于 ProductFlavor 类。这意味着，您可以在 defaultConfig 代码块中为所有类型提供基本配置，并且每个类型都可以更改其中任何默认值.</p>
<p>所有类型都必须属于一个指定的类型维度，即一个产品特性组。即使您打算只使用一个维度，也必须将类型分配到类型维度.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;...&#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug&#123;...&#125;</span><br><span class="line">        release&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Specifies one flavor dimension.</span></span><br><span class="line">    flavorDimensions <span class="string">&quot;version&quot;</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">            <span class="comment">// Assigns this product flavor to the &quot;version&quot; flavor dimension.</span></span><br><span class="line">            <span class="comment">// This property is optional if you are using only one dimension.</span></span><br><span class="line">            dimension <span class="string">&quot;version&quot;</span></span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.demo&quot;</span></span><br><span class="line">            versionNameSuffix <span class="string">&quot;-demo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        full &#123;</span><br><span class="line">            dimension <span class="string">&quot;version&quot;</span></span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.full&quot;</span></span><br><span class="line">            versionNameSuffix <span class="string">&quot;-full&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将多个产品特性与类型维度结合使用"><a href="#将多个产品特性与类型维度结合使用" class="headerlink" title="将多个产品特性与类型维度结合使用"></a>将多个产品特性与类型维度结合使用</h3><p>在编译应用时，Gradle 会结合使用您定义的每个类型维度的产品特性配置以及版本类型配置，以创建最终的编译变体。Gradle 不会将属于同一类型维度的产品特性组合在一起。</p>
<p>以下代码示例使用 flavorDimensions 属性来创建“mode”类型维度和“api”类型维度，前者用于将“full”和“demo”产品特性进行分组，后者用于根据 API 级别对产品特性配置进行分组：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;...&#125;</span><br><span class="line">        release &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Specifies the flavor dimensions you want to use. The order in which you</span></span><br><span class="line">    <span class="comment">// list each dimension determines its priority, from highest to lowest,</span></span><br><span class="line">    <span class="comment">// when Gradle merges variant sources and configurations. You must assign</span></span><br><span class="line">    <span class="comment">// each product flavor you configure to one of the flavor dimensions.</span></span><br><span class="line">    flavorDimensions <span class="string">&quot;api&quot;</span>, <span class="string">&quot;mode&quot;</span></span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">            <span class="comment">// Assigns this product flavor to the &quot;mode&quot; flavor dimension.</span></span><br><span class="line">            dimension <span class="string">&quot;mode&quot;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        full &#123;</span><br><span class="line">            dimension <span class="string">&quot;mode&quot;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configurations in the &quot;api&quot; product flavors override those in &quot;mode&quot;</span></span><br><span class="line">        <span class="comment">// flavors and the defaultConfig block. Gradle determines the priority</span></span><br><span class="line">        <span class="comment">// between flavor dimensions based on the order in which they appear next</span></span><br><span class="line">        <span class="comment">// to the flavorDimensions property above--the first dimension has a higher</span></span><br><span class="line">        <span class="comment">// priority than the second, and so on.</span></span><br><span class="line">        minApi24 &#123;</span><br><span class="line">            dimension <span class="string">&quot;api&quot;</span></span><br><span class="line">            minSdkVersion <span class="number">24</span></span><br><span class="line">            <span class="comment">// To ensure the target device receives the version of the app with</span></span><br><span class="line">            <span class="comment">// the highest compatible API level, assign version codes in increasing</span></span><br><span class="line">            <span class="comment">// value with API level. To learn more about assigning version codes to</span></span><br><span class="line">            <span class="comment">// support app updates and uploading to Google Play, read Multiple APK Support</span></span><br><span class="line">            versionCode <span class="number">30000</span> + android.defaultConfig.versionCode</span><br><span class="line">            versionNameSuffix <span class="string">&quot;-minApi24&quot;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minApi23 &#123;</span><br><span class="line">            dimension <span class="string">&quot;api&quot;</span></span><br><span class="line">            minSdkVersion <span class="number">23</span></span><br><span class="line">            versionCode <span class="number">20000</span>  + android.defaultConfig.versionCode</span><br><span class="line">            versionNameSuffix <span class="string">&quot;-minApi23&quot;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        minApi21 &#123;</span><br><span class="line">            dimension <span class="string">&quot;api&quot;</span></span><br><span class="line">            minSdkVersion <span class="number">21</span></span><br><span class="line">            versionCode <span class="number">10000</span>  + android.defaultConfig.versionCode</span><br><span class="line">            versionNameSuffix <span class="string">&quot;-minApi21&quot;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面的编译配置为例，Gradle 使用以下命名方案创建了总共 12 个编译变体：</p>
<ul>
<li>编译变体：[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]</li>
<li>对应的 APK：app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk</li>
</ul>
<p>除了可以为各个产品特性和编译变体创建源集目录外，您还可以为每个产品特性组合创建源集目录。例如，您可以创建 Java 源文件并将其添加到 src/demoMinApi24/java/ 目录中，这样 Gradle 就只会在编译同时对应这两种产品特性的变体时才使用这些源文件。您为产品特性组合创建的源集的优先级高于属于各个产品特性的源集。</p>
<h3 id="过滤变体"><a href="#过滤变体" class="headerlink" title="过滤变体"></a>过滤变体</h3><p>Gradle 会为您配置的产品特性和版本类型的每种可能组合创建编译变体。但是，某些编译变体可能并不是您需要的，或者在项目上下文中没有意义。您可以通过在模块级 build.gradle 文件中创建变体过滤器来移除某些编译变体配置。</p>
<p>以上一部分中的编译配置为例，假设您打算让“demo”版应用仅支持 API 级别 23 及更高级别。您可以使用 variantFilter 代码块过滤掉所有将“minApi21”和“demo”产品特性组合在一起的编译变体配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    flavorDimensions <span class="string">&quot;api&quot;</span>, <span class="string">&quot;mode&quot;</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">    demo &#123;...&#125;</span><br><span class="line">    full &#123;...&#125;</span><br><span class="line">    minApi24 &#123;...&#125;</span><br><span class="line">    minApi23 &#123;...&#125;</span><br><span class="line">    minApi21 &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    variantFilter &#123; variant -&gt;</span><br><span class="line">        <span class="keyword">def</span> names = variant.flavors*.name</span><br><span class="line">        <span class="comment">// To check for a certain build type, use variant.buildType.name == &quot;&lt;buildType&gt;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (names.contains(<span class="string">&quot;minApi21&quot;</span>) &amp;&amp; names.contains(<span class="string">&quot;demo&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// Gradle ignores any variants that satisfy the conditions above.</span></span><br><span class="line">            setIgnore(<span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="维度回退"><a href="#维度回退" class="headerlink" title="维度回退"></a>维度回退</h3><p><strong>情况1：app中有某个build type但module中没有。</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the app&#x27;s build.gradle file.</span></span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;&#125;</span><br><span class="line">        release &#123;&#125;</span><br><span class="line">        staging &#123;</span><br><span class="line">            <span class="comment">// 下面[]中的qa、debug、release是module中配置的buildType，必须含有其中一个或更多，</span></span><br><span class="line">            <span class="comment">// 若module中buildType没有staging，gradle会根据matchingFallbacks的配置，</span></span><br><span class="line">            <span class="comment">// 依次按顺序去匹配</span></span><br><span class="line">            <span class="comment">// 注意：module与module之间存在依赖关系的话，也要在特定的build types中指定匹配关系</span></span><br><span class="line">            matchingFallbacks = [<span class="string">&#x27;qa&#x27;</span>, <span class="string">&#x27;debug&#x27;</span>, <span class="string">&#x27;release&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：module中有但app中没有的build type是不会报错的，因为gradle插件根本不会去module中请求build type。</p>
<p><strong>情况2：在app和它的module中都有同一个维度（比如：flavorDimensions ‘tier’），但你的app有的flavors在module中没有。</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">&#x27;tier&#x27;</span></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    paid &#123;</span><br><span class="line">        <span class="comment">// 因为依赖app的module在&#x27;tier&#x27;维度下也有&#x27;paid&#x27;这个flavor，所以你不用去管，</span></span><br><span class="line">        <span class="comment">// gradle会自动为你匹配</span></span><br><span class="line">        dimension <span class="string">&#x27;tier&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    free &#123;</span><br><span class="line">        <span class="comment">// 因为module在&#x27;tier&#x27;维度下没有&#x27;free&#x27;这个flavor，所以需要指定matchingFallbacks</span></span><br><span class="line">        <span class="comment">// 让gradle知道怎么去匹配</span></span><br><span class="line">        <span class="comment">// 像下面这样配置，gradle会按顺序依次去匹配module中&#x27;tier&#x27;维度下的flavor，</span></span><br><span class="line">        <span class="comment">// 直到匹配到，否则会报错</span></span><br><span class="line">        matchingFallbacks = [<span class="string">&#x27;demo&#x27;</span>, <span class="string">&#x27;trial&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：对于在同一个维度下，module中有的flavors但app中没有是不会报错的，因为gradle插件根本不会去module中请求flavors。</p>
<p><strong>情况3：module中有某个dimension维度，但app中没有。</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the app&#x27;s build.gradle file.</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig&#123;</span><br><span class="line">        <span class="comment">// 下面这句话告诉gradle，当遇到一个module中有个app中没有的&#x27;minApi&#x27;维度时，</span></span><br><span class="line">        <span class="comment">// 它应该按照下面这个顺序去匹配module中这个维度的flavors</span></span><br><span class="line">        missingDimensionStrategy <span class="string">&#x27;minApi&#x27;</span>, <span class="string">&#x27;minApi18&#x27;</span>, <span class="string">&#x27;minApi23&#x27;</span></span><br><span class="line">        <span class="comment">// 若其他module中还有更多app中没有的维度，你必须为所有的维度定义回退策略</span></span><br><span class="line">        missingDimensionStrategy <span class="string">&#x27;abi&#x27;</span>, <span class="string">&#x27;x86&#x27;</span>, <span class="string">&#x27;arm64&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavorDimensions <span class="string">&#x27;tier&#x27;</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        free &#123;</span><br><span class="line">            dimension <span class="string">&#x27;tier&#x27;</span></span><br><span class="line">            <span class="comment">// 你可以在一个特定的flavor中覆盖defaultConfig的配置</span></span><br><span class="line">            missingDimensionStrategy <span class="string">&#x27;minApi&#x27;</span>, <span class="string">&#x27;minApi23&#x27;</span>, <span class="string">&#x27;minApi18&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        paid &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当一个维度app中有但module中没有的时候是不会报错，因为gradle插件只会匹配已经在module中存在的维度，比如module中没有abi这个维度，当app为freeX86Debug时，你的module就用freeDebug。</p>
<p><strong>情况4：若module中没有某个dimension，则app不需要在这个dimension下做任何处理。</strong></p>
<h2 id="创建源集"><a href="#创建源集" class="headerlink" title="创建源集"></a>创建源集</h2><h3 id="创建源集-1"><a href="#创建源集-1" class="headerlink" title="创建源集"></a>创建源集</h3><p>默认情况下，Android Studio 会为您希望在所有编译变体之间共享的所有内容创建 main/ 源集和目录。但是，您可以创建新的源集来精确控制 Gradle 为特定版本类型、产品特性（以及使用类型维度时的产品特性组合）和编译变体编译和打包的文件。例如，您可以在 main/ 源集中定义基本功能，并使用产品特性源集来为不同客户端更改应用的品牌，或仅为使用“debug”版本类型的编译变体添加特殊权限和日志记录功能。</p>
<p>Gradle 要求您以某种类似于 main/ 源集的方式组织源集文件和目录。例如，Gradle 要求将“debug”版本类型特有的 Java 类文件放在 src/debug/java/ 目录中。</p>
<p>可通过<code>gradle sourceSets</code>查看不同变体期望的源集路径；可通过Android Studio自带功能创建源集。</p>
<h3 id="更改默认源集配置"><a href="#更改默认源集配置" class="headerlink" title="更改默认源集配置"></a>更改默认源集配置</h3><p>可以使用sourceSets修改默认源集路径。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        <span class="comment">// Encapsulates configurations for the main source set.</span></span><br><span class="line">        main &#123;</span><br><span class="line">            <span class="comment">// Changes the directory for Java sources. The default directory is</span></span><br><span class="line">            <span class="comment">// &#x27;src/main/java&#x27;.</span></span><br><span class="line">            java.srcDirs = [<span class="string">&#x27;other/java&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If you list multiple directories, Gradle uses all of them to collect</span></span><br><span class="line">            <span class="comment">// sources. Because Gradle gives these directories equal priority, if</span></span><br><span class="line">            <span class="comment">// you define the same resource in more than one directory, you get an</span></span><br><span class="line">            <span class="comment">// error when merging resources. The default directory is &#x27;src/main/res&#x27;.</span></span><br><span class="line">            res.srcDirs = [<span class="string">&#x27;other/res1&#x27;</span>, <span class="string">&#x27;other/res2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note: You should avoid specifying a directory which is a parent to one</span></span><br><span class="line">            <span class="comment">// or more other directories you specify. For example, avoid the following:</span></span><br><span class="line">            <span class="comment">// res.srcDirs = [&#x27;other/res1&#x27;, &#x27;other/res1/layouts&#x27;, &#x27;other/res1/strings&#x27;]</span></span><br><span class="line">            <span class="comment">// You should specify either only the root &#x27;other/res1&#x27; directory, or only the</span></span><br><span class="line">            <span class="comment">// nested &#x27;other/res1/layouts&#x27; and &#x27;other/res1/strings&#x27; directories.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// For each source set, you can specify only one Android manifest.</span></span><br><span class="line">            <span class="comment">// By default, Android Studio creates a manifest for your main source</span></span><br><span class="line">            <span class="comment">// set in the src/main/ directory.</span></span><br><span class="line">            manifest.srcFile <span class="string">&#x27;other/AndroidManifest.xml&#x27;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create additional blocks to configure other source sets.</span></span><br><span class="line">        androidTest &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If all the files for a source set are located under a single root</span></span><br><span class="line">            <span class="comment">// directory, you can specify that directory using the setRoot property.</span></span><br><span class="line">            <span class="comment">// When gathering sources for the source set, Gradle looks only in locations</span></span><br><span class="line">            <span class="comment">// relative to the root directory you specify. For example, after applying the</span></span><br><span class="line">            <span class="comment">// configuration below for the androidTest source set, Gradle looks for Java</span></span><br><span class="line">            <span class="comment">// sources only in the src/tests/java/ directory.</span></span><br><span class="line">            setRoot <span class="string">&#x27;src/tests&#x27;</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用源集编译"><a href="#使用源集编译" class="headerlink" title="使用源集编译"></a>使用源集编译</h3><p>可以使用源集目录来添加只希望与某些配置打包在一起的代码和资源。例如，如果您要编译“demoDebug”这个变体（“demo”产品特性和“debug”版本类型的混合产物），则 Gradle 会查看这些目录，并为它们指定以下优先级：</p>
<ol>
<li>src/demoDebug/（编译变体源集）</li>
<li>src/debug/（版本类型源集）</li>
<li>src/demo/（产品特性源集）</li>
<li>src/main/（主源集）</li>
</ol>
<p>注意：如果您结合使用多个产品特性，那么这些产品特性的优先级由它们所属的类型维度决定。使用 android.flavorDimensions 属性列出类型维度时，属于您列出的第一个类型维度的产品特性的优先级高于属于第二个类型维度的产品特性，依此类推。此外，您为产品特性组合创建的源集的优先级高于属于各个产品特性的源集。</p>
<p>上面列出的顺序决定了 Gradle 组合代码和资源时哪个源集的优先级更高。由于 demoDebug/ 源集目录可能包含该编译变体特有的文件，因此，如果 demoDebug/ 包含在 debug/ 中也定义了的文件，则 Gradle 会使用 demoDebug/ 源集中的文件。类似地，Gradle 会为版本类型和产品特性源集中的文件提供比 main/ 中的相同文件更高的优先级。在应用以下编译规则时，Gradle 会考虑这种优先顺序：</p>
<ul>
<li>java/ 目录中的所有源代码将一起编译以生成单个输出。<br>  注意：对于给定的编译变体，如果 Gradle 遇到两个或更多个源集目录定义了同一个 Java 类的情况，则会抛出编译错误。例如，在编译调试 APK 时，您不能同时定义 src/debug/Utility.java 和 src/main/Utility.java。这是因为 Gradle 在编译过程中会查看这两个目录并抛出“重复类”错误。如果您要为不同的版本类型使用不同版本的 Utility.java，则可以让每个版本类型定义各自的文件版本，而不是将其包含在 main/ 源集中。</li>
<li>所有清单都将合并为一个清单，优先级将按照上面列出的顺序提供。也就是说，版本类型的清单设置会替换产品特性的清单设置，依此类推。</li>
<li>同样，values/ 目录中的文件也会合并在一起。如果两个文件（如两个 strings.xml 文件）的名称相同，将按照上面列表中的顺序指定优先级。也就是说，在版本类型源集的文件中定义的值会重写在产品特性的同一文件中定义的值，依此类推。</li>
<li>res/ 和 asset/ 目录中的资源会打包在一起。如果在两个或更多个源集中定义了同名的资源，将按照上面列表中的顺序指定优先级。</li>
<li>最后，在编译 APK 时，Gradle 会为库模块依赖项随附的资源和清单指定最低优先级。</li>
</ul>
<h2 id="声明依赖项"><a href="#声明依赖项" class="headerlink" title="声明依赖项"></a>声明依赖项</h2><p>可以为特定编译变体或测试源集配置依赖项，方法是在 Implementation 关键字前面加上编译变体或测试源集的名称作为前缀，如以下示例所示。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Adds the local &quot;mylibrary&quot; module as a dependency to the &quot;free&quot; flavor.</span></span><br><span class="line">    freeImplementation project(<span class="string">&quot;:mylibrary&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a remote binary dependency only for local tests.</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a remote binary dependency only for the instrumented test APK.</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;com.android.support.test.espresso:espresso-core:3.0.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置签名设置"><a href="#配置签名设置" class="headerlink" title="配置签名设置"></a>配置签名设置</h2><p>除非您明确定义此版本的签名配置，否则 Gradle 不会为该版本的 APK 签名。您可以轻松创建发布密钥并使用 Android Studio 为发布版本类型签名。要使用 Gradle 编译配置为您的发布版本类型手动配置签名，请执行以下操作：</p>
<ol>
<li>创建一个密钥库。密钥库是一个包含一组私钥的二进制文件。您必须将密钥库保存在安全可靠的地方。</li>
<li>创建一个私钥。私钥代表将通过应用识别的实体，如个人或公司。</li>
<li>将签名配置添加到模块级 build.gradle 文件中：</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;...&#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(<span class="string">&quot;myreleasekey.keystore&quot;</span>)</span><br><span class="line">            storePassword <span class="string">&quot;password&quot;</span></span><br><span class="line">            keyAlias <span class="string">&quot;MyReleaseKey&quot;</span></span><br><span class="line">            keyPassword <span class="string">&quot;password&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            ...</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在编译文件中添加发布密钥和密钥存储区的密码并不是一种好的安全做法。作为替代方案，您可以配置编译文件以从环境变量获取这些密码，或让编译流程提示您输入这些密码。</p>
<p>要从环境变量获取这些密码，请编写以下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">storePassword System.getenv(<span class="string">&quot;KSTOREPWD&quot;</span>)</span><br><span class="line">keyPassword System.getenv(<span class="string">&quot;KEYPWD&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>要让编译流程在您要从命令行调用此编译时提示您输入这些密码，请编写以下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">storePassword System.console().readLine(<span class="string">&quot;\nKeystore password: &quot;</span>)</span><br><span class="line">keyPassword System.console().readLine(<span class="string">&quot;\nKey password: &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>警告：请将密钥库和私钥保存在安全可靠的地方，并确保您为其创建了安全的备份。如果您将应用发布到 Google Play，随后丢失了用于为应用签名的密钥，那么您将无法向您的应用发布任何更新，因为您必须始终使用相同的密钥为应用的所有版本签名。</p>
<p>注意：当buildType.debug中没有指定signingConfig时，即使productFlavors中提供了签名配置，也会默认使用Android Studio提供的签名，因此如果要使debug下的flavor签名生效，需要指定debug的signingConfig为null，如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> flavorSigns = [</span><br><span class="line">        <span class="string">&quot;base&quot;</span>     : readSigningConfig(file(<span class="string">&#x27;../signing1.properties&#x27;</span>)),</span><br><span class="line">        <span class="string">&quot;flavorA&quot;</span>: readSigningConfig(file(<span class="string">&#x27;../signing2.properties&#x27;</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        flavorSigns.forEach &#123; key, value -&gt;</span><br><span class="line">            <span class="string">&quot;$key&quot;</span> &#123;</span><br><span class="line">                keyAlias value.keyAlias</span><br><span class="line">                keyPassword value.keyPassword</span><br><span class="line">                storeFile value.storeFile</span><br><span class="line">                storePassword value.storePassword</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        signingConfig signingConfigs.base</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// Android Studio adds a default signingConfig for debug builds and we can remove it by passing null.</span></span><br><span class="line">            <span class="comment">// By doing this, I delegate the signingConfig to the product flavors.</span></span><br><span class="line">            signingConfig <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flavorDimensions <span class="string">&quot;version&quot;</span>, <span class="string">&quot;channel&quot;</span></span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        stable &#123;</span><br><span class="line">            dimension <span class="string">&quot;version&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        alpha &#123;</span><br><span class="line">            dimension <span class="string">&quot;version&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        base &#123;</span><br><span class="line">            dimension <span class="string">&quot;channel&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        flavorA &#123;</span><br><span class="line">            dimension <span class="string">&quot;channel&quot;</span></span><br><span class="line">            signingConfig signingConfigs.flavorA</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构建多应用"><a href="#构建多应用" class="headerlink" title="构建多应用"></a>构建多应用</h1><h2 id="构建多应用-1"><a href="#构建多应用-1" class="headerlink" title="构建多应用"></a>构建多应用</h2><h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>以下为compatibleScreens列出的每个屏幕密度生成单独的APK，但ldpi，xxhdpi和xxxhdpi除外：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  splits &#123;</span><br><span class="line">    <span class="comment">// Configures multiple APKs based on screen density.</span></span><br><span class="line">    density &#123;</span><br><span class="line">      <span class="comment">// Configures multiple APKs based on screen density.</span></span><br><span class="line">      enable <span class="literal">true</span></span><br><span class="line">      <span class="comment">// Specifies a list of screen densities Gradle should not create multiple APKs for.</span></span><br><span class="line">      exclude <span class="string">&quot;ldpi&quot;</span>, <span class="string">&quot;xxhdpi&quot;</span>, <span class="string">&quot;xxxhdpi&quot;</span></span><br><span class="line">      <span class="comment">// Specifies a list of compatible screen size settings for the manifest.</span></span><br><span class="line">      compatibleScreens <span class="string">&#x27;small&#x27;</span>, <span class="string">&#x27;normal&#x27;</span>, <span class="string">&#x27;large&#x27;</span>, <span class="string">&#x27;xlarge&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>enable：如果将此元素设置为true，Gradle会根据您定义的屏幕密度生成多个APK。默认值为false。</p>
</li>
<li><p>exclude：指定以逗号分隔的密度列表，Gradle不应为其生成单独的APK。</p>
</li>
<li><p>reset()：清除默认的屏幕密度列表，仅在与include元素组合时使用， 以指定要添加的密度。</p>
</li>
<li><p>include：指定Gradle应为其生成APK的密度列表。只能结合使用reset()来指定密度的确切列表。</p>
</li>
<li><p>compatibleScreens：指定兼容屏幕尺寸的逗号分隔列表，这会为每个APK在manifest中注入一个匹配的 <code>&lt;compatible-screens&gt;</code>节点。此设置提供了在同一build.gradle中管理屏幕密度和屏幕大小的便捷方法。但是，使用<code>&lt;compatible-screens&gt;</code>限制了应用程序可以使用的设备类型。</p>
  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reset()  <span class="comment">// Clears the default list from all densities to no densities.</span></span><br><span class="line">include <span class="string">&quot;ldpi&quot;</span>, <span class="string">&quot;xxhdpi&quot;</span> <span class="comment">// Specifies the two densities we want to generate APKs for.</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>因为基于屏幕密度的每个APK都包含<code>&lt;compatible-screens&gt;</code>标记，其中包含有关APK支持的屏幕类型的特定限制，即使您发布了多个APK，某些新设备也无法匹配您的多个APK过滤器。因此，Gradle始终会生成一个额外的通用APK，其中包含所有屏幕密度的资源，并且不包含<code>&lt;compatible-screens&gt;</code>标记。您应该发布此通用APK以及每个密度的APK，以便为与APK兼容的设备提供后备兼容的<code>&lt;compatible-screens&gt;</code>标记。</p>
<h3 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  splits &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configures multiple APKs based on ABI.</span></span><br><span class="line">    abi &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Enables building multiple APKs per ABI.</span></span><br><span class="line">      enable <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// By default all ABIs are included, so use reset() and include to specify that we only</span></span><br><span class="line">      <span class="comment">// want APKs for x86 and x86_64.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Resets the list of ABIs that Gradle should create APKs for to none.</span></span><br><span class="line">      reset()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Specifies a list of ABIs that Gradle should create APKs for.</span></span><br><span class="line">      include <span class="string">&quot;x86&quot;</span>, <span class="string">&quot;x86_64&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Specifies that we do not want to also generate a universal APK that includes all ABIs.</span></span><br><span class="line">      universalApk <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ABI 包含以下信息：</p>
<ul>
<li>机器代码应使用的 CPU 指令集。</li>
<li>运行时内存存储和加载的字节顺序。</li>
<li>可执行二进制文件（例如程序和共享库）的格式，以及它们支持的内容类型。</li>
<li>用于解析内容与系统之间数据的各种约定。这些约定包括对齐限制，以及系统如何使用堆栈和在调用函数时注册。</li>
<li>运行时可用于机器代码的函数符号列表 - 通常来自非常具体的库集。</li>
</ul>
<img src="abi分类.png"/>

<ul>
<li>enable：如果您将此元素设置为true，Gradle会根据您定义的ABI生成多个APK。默认值是false</li>
<li>exclude：指定用逗号分隔的ABI的名单不生成单独的APK。</li>
<li>reset：清除ABI的默认列表。仅在与include元素结合使用时才使用， 以指定要添加的ABI。</li>
<li>include：指定Gradle应为其生成APK的ABI的逗号分隔列表。只能结合使用reset()来指定ABI的确切列表。</li>
<li>universalApk：如果true，除了per-ABI APK，Gradle还生成通用APK。通用APK包含单个APK中所有ABI的代码和资源。默认值是false。请注意，该选项仅在该splits.abi块中可用。当根据屏幕密度构建多个APK时，Gradle始终会生成一个通用APK，其中包含用于所有屏幕密度的代码和资源。</li>
</ul>
<p>在Gradle 3.1.0及更高版本中不再默认生成支持mips, mips64, 和armeabi的apk，因为 NDK r17 及更高版本不再支持这些abi。因此如果使用Gradle版本低于3.1.0，NDK高于r17，则会报错。</p>
<h2 id="配置版本"><a href="#配置版本" class="headerlink" title="配置版本"></a>配置版本</h2><p>默认生成的多个apk的版本信息是一样的，但是GP不允许同一应用的多apk拥有相同的版本信息，因此需要为其生成不同的版本。</p>
<p>如果您的构建包含通用APK，则应为其分配一个低于任何其他APK的版本代码。 由于Google Play商店会安装与目标设备兼容且版本编号最高的应用版本，因此将较低版本的代码分配给通用APK可确保Google Play商店尝试安装其中一个APK，然后再回到通用版本APK。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    versionCode <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  splits &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map for the version code that gives each ABI a value.</span></span><br><span class="line">ext.abiCodes = [<span class="string">&#x27;armeabi-v7a&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;x86&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;x86_64&#x27;</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// For per-density APKs, create a similar map like this:</span></span><br><span class="line"><span class="comment">// ext.densityCodes = [&#x27;mdpi&#x27;: 1, &#x27;hdpi&#x27;: 2, &#x27;xhdpi&#x27;: 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.OutputFile</span><br><span class="line"></span><br><span class="line"><span class="comment">// For each APK output variant, override versionCode with a combination of</span></span><br><span class="line"><span class="comment">// ext.abiCodes * 1000 + variant.versionCode. In this example, variant.versionCode</span></span><br><span class="line"><span class="comment">// is equal to defaultConfig.versionCode. If you configure product flavors that</span></span><br><span class="line"><span class="comment">// define their own versionCode, variant.versionCode uses that value instead.</span></span><br><span class="line">android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assigns a different version code for each output APK</span></span><br><span class="line">  <span class="comment">// other than the universal APK.</span></span><br><span class="line">  variant.outputs.each &#123; output -&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stores the value of ext.abiCodes that is associated with the ABI for this variant.</span></span><br><span class="line">    <span class="keyword">def</span> baseAbiVersionCode =</span><br><span class="line">            <span class="comment">// Determines the ABI for this variant and returns the mapped value.</span></span><br><span class="line">            project.ext.abiCodes.get(output.getFilter(OutputFile.ABI))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Because abiCodes.get() returns null for ABIs that are not mapped by ext.abiCodes,</span></span><br><span class="line">    <span class="comment">// the following code does not override the version code for universal APKs.</span></span><br><span class="line">    <span class="comment">// However, because we want universal APKs to have the lowest version code,</span></span><br><span class="line">    <span class="comment">// this outcome is desirable.</span></span><br><span class="line">    <span class="keyword">if</span> (baseAbiVersionCode != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Assigns the new version code to versionCodeOverride, which changes the version code</span></span><br><span class="line">      <span class="comment">// for only the output APK, not for the variant itself. Skipping this step simply</span></span><br><span class="line">      <span class="comment">// causes Gradle to use the value of variant.versionCode for the APK.</span></span><br><span class="line">      output.versionCodeOverride =</span><br><span class="line">              baseAbiVersionCode * <span class="number">1000</span> + variant.versionCode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="格式化apk名"><a href="#格式化apk名" class="headerlink" title="格式化apk名"></a>格式化apk名</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.all &#123;</span><br><span class="line">            outputFileName = <span class="string">&quot;$&#123;variant.applicationId&#125;-$&#123;variant.name&#125;-$&#123;variant.versionName&#125;.apk&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Manifest合并"><a href="#Manifest合并" class="headerlink" title="Manifest合并"></a>Manifest合并</h1><h2 id="合并优先级"><a href="#合并优先级" class="headerlink" title="合并优先级"></a>合并优先级</h2><p>合并工具会根据每个清单文件的优先级按顺序合并，将所有清单文件组合到一个文件中。</p>
<img src="合并Manifest.png"/>

<p>有三种基本的清单文件可以互相合并，它们的合并优先级如下（按优先级由高到低的顺序）：</p>
<ol>
<li><p>编译变体的清单文件<br> 如果您的变体有多个源集，则其清单优先级如下：</p>
<ul>
<li>编译变体清单（如 src/demoDebug/）</li>
<li>版本类型清单（如 src/debug/）</li>
<li>产品类型清单（如 src/demo/）<br>如果您使用的是类型维度，则清单优先级将与每个维度在 flavorDimensions 属性中的列示顺序（按优先级由高到低的顺序）对应。</li>
</ul>
</li>
<li><p>应用模块的主清单文件</p>
</li>
<li><p>所包含的库中的清单文件<br> 如果您有多个库，则其清单优先级与依赖顺序（库出现在 Gradle dependencies 块中的顺序）匹配。例如，先将库清单合并到主清单中，然后再将主清单合并到编译变体清单中。</p>
</li>
</ol>
<p>注：build.gradle 文件中的编译配置将替换合并后的清单文件中的所有对应属性。例如，build.gradle 文件中的 minSdkVersion 将替换 <code>&lt;uses-sdk&gt;</code> 清单元素中的匹配属性。为了避免混淆，您只需省去 <code>&lt;uses-sdk&gt;</code> 元素并在 build.gradle 文件中定义这些属性。</p>
<h2 id="合并冲突启发式算法"><a href="#合并冲突启发式算法" class="headerlink" title="合并冲突启发式算法"></a>合并冲突启发式算法</h2><p>合并工具可以在逻辑上将一个清单中的每个 XML 元素与另一个清单中的对应元素相匹配。如果优先级较低的清单中的某个元素与优先级较高的清单中的任何元素都不匹配，则会将该元素添加到合并后的清单。不过，如果有匹配的元素，则合并工具会尝试将每个元素的所有属性组合到同一元素中。如果该工具发现两个清单包含相同的属性，但值不同，则会发生合并冲突。</p>
<table>
<thead>
<tr>
<th align="center">高优先级属性</th>
<th align="center">低优先级属性</th>
<th align="center">属性的合并结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有值</td>
<td align="center">没有值</td>
<td align="center">没有值（使用默认值）</td>
</tr>
<tr>
<td align="center">没有值</td>
<td align="center">值 B</td>
<td align="center">值 B</td>
</tr>
<tr>
<td align="center">值 A</td>
<td align="center">没有值</td>
<td align="center">值 A</td>
</tr>
<tr>
<td align="center">值 A</td>
<td align="center">值 A</td>
<td align="center">值 A</td>
</tr>
<tr>
<td align="center">值 A</td>
<td align="center">值 B</td>
<td align="center">冲突错误 - 您必须添加合并规则标记</td>
</tr>
</tbody></table>
<p>不过，在某些情况下，合并工具会采取其他行为方式以避免合并冲突：</p>
<ul>
<li><code>&lt;manifest&gt;</code> 元素中的属性绝不会合并在一起 - 仅使用优先级最高的清单中的属性。</li>
<li><code>&lt;uses-feature&gt;</code> 和 <code>&lt;uses-library&gt;</code> 元素中的 android:required 属性使用 OR 合并，这样一来，如果发生冲突，系统将应用 “true” 并始终包含某个清单所需的功能或库。</li>
<li><code>&lt;uses-sdk&gt;</code> 元素中的属性始终使用优先级较高的清单中的值，但以下情况除外：<ul>
<li>如果优先级较低的清单的 minSdkVersion 值较高，除非您应用 overrideLibrary 合并规则，否则会发生错误。</li>
<li>如果优先级较低的清单的 targetSdkVersion 值较低，合并工具将使用优先级较高的清单中的值，但也会添加所有必要的系统权限，以确保所导入的库继续正常工作（适用于较高的 Android 版本具有更多权限限制的情况）。</li>
</ul>
</li>
<li>绝不会在清单之间匹配 <code>&lt;intent-filter&gt;</code> 元素。每个该元素都被视为唯一的元素，并添加到合并后的清单中共同的父元素。</li>
</ul>
<p>对于属性之间的其他所有冲突，您将收到一条错误，并且必须通过在优先级较高的清单文件中添加一个特殊属性来指示合并工具如何解决此错误（请参阅有关合并规则标记的下一部分）。</p>
<p>不依赖于默认属性值：由于所有唯一属性都组合到同一元素中，因此如果优先级较高的清单实际上依赖于某个属性的默认值而不声明该属性，则可能会导致意外结果。例如，如果优先级较高的清单不声明 android:launchMode 属性，则会使用默认值 “standard”；但如果优先级较低的清单声明此属性具有其他值，则该值将应用于合并后的清单（替换默认值）。因此，您应该按期望明确定义每个属性。（清单参考文档中介绍了每个属性的默认值。）</p>
<h2 id="合并规则标记"><a href="#合并规则标记" class="headerlink" title="合并规则标记"></a>合并规则标记</h2><p>合并规则标记是一个 XML 属性，可用于表达您对如何解决合并冲突或移除不需要的元素和属性的偏好。您可以对整个元素应用标记，也可以只对元素中的特定属性应用标记。</p>
<p>合并两个清单文件时，合并工具会在优先级较高的清单文件中查找这些标记。</p>
<p>所有标记都属于 Android tools 命名空间，因此您必须先在 <code>&lt;manifest&gt;</code> 元素中声明此命名空间，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.myapp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="节点标记"><a href="#节点标记" class="headerlink" title="节点标记"></a>节点标记</h3><p>向整个 XML 元素（给定清单元素中的所有属性及其所有子标记）应用合并规则：</p>
<ol>
<li><p><code>tools:node=&quot;merge&quot;</code>：如果使用合并冲突启发式算法时没有冲突，则合并此标记中的所有属性以及所有嵌套元素。这是元素的默认行为。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;merge&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:node=&quot;merge-only-attributes&quot;</code>：仅合并此标记中的属性，不合并嵌套元素。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:type</span>=<span class="string">&quot;image/*&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;merge-only-attributes&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:node=&quot;remove&quot;</code>：从合并后的清单中移除此元素。虽然您似乎应该只删除此元素，但如果您发现合并后的清单中有不需要的元素，而且该元素是由不受您控制的优先级较低的清单文件（如导入的库）提供的，则必须使用此属性。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;cow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/moo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;duck&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/quack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;cow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;duck&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/quack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:node=&quot;removeAll&quot;</code>：与 tools:node=”remove” 类似，但它会移除与此元素类型匹配的所有元素（同一父元素内）。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;cow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/moo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;duck&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/quack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">tools:node</span>=<span class="string">&quot;removeAll&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:node=&quot;replace&quot;</code>：完全替换优先级较低的元素。也就是说，如果优先级较低的清单中有匹配的元素，会将其忽略并完全按照此元素在此清单中显示的样子来使用它。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;cow&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/moo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;duck&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/quack&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;replace&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;fox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/dingeringeding&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.alias&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;fox&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">&quot;@string/dingeringeding&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:node=&quot;strict&quot;</code>：每当此元素在优先级较低的清单中与在优先级较高的清单中不完全匹配时，都会导致编译失败（除非已通过其他合并规则标记解决）。这将替换合并冲突启发式算法。例如，如果优先级较低的清单只是包含一个额外的属性，则编译将会失败（而默认行为会将该额外属性添加到合并后的清单）。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;strict&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 这会生成清单合并错误。 这两个清单元素在严格模式下完全无法区分。因此，您必须应用其他合并规则标记来解决这些差异。（通常，这两个元素会很好地合并在一起，如上面的 tools:node=”merge” 示例中所示。）</p>
</li>
</ol>
<h3 id="属性标记"><a href="#属性标记" class="headerlink" title="属性标记"></a>属性标记</h3><ol>
<li><p><code>tools:remove=&quot;attr, ...&quot;</code>：从合并后的清单中移除指定属性。虽然您似乎可以只删除这些属性，但如果优先级较低的清单文件不包含这些属性，而且您希望确保不将它们纳入合并后的清单，则必须使用此属性。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:remove</span>=<span class="string">&quot;android:windowSoftInputMode&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:replace=&quot;attr, ...&quot;</code>：将优先级较低的清单中的指定属性替换为此清单中的属性。换句话说，始终保留优先级较高的清单的值。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@oldtheme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@newtheme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:replace</span>=<span class="string">&quot;android:theme,android:exported&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@newtheme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tools:strict=&quot;attr, ...&quot;</code>：每当这些属性在优先级较低的清单中与在优先级较高的清单中不完全匹配时，都会导致编译失败。这是所有属性的默认行为，但具有特殊行为的属性除外，如合并冲突启发式算法中所述。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;landscape&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:strict</span>=<span class="string">&quot;android:screenOrientation&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 这会生成清单合并错误。 您必须应用其他合并规则标记来解决冲突。（切记：这是默认行为，因此如果您移除 tools:strict=”screenOrientation”，上面的示例将具有相同的结果。）</p>
</li>
<li><p>也可以对一个元素应用多个标记</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 低优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@oldtheme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowTaskReparenting</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnchanged&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 高优先级</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@newtheme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:replace</span>=<span class="string">&quot;android:theme,android:exported&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:remove</span>=<span class="string">&quot;android:windowSoftInputMode&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//合并后</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.ActivityOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@newtheme&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowTaskReparenting</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="标记选择器"><a href="#标记选择器" class="headerlink" title="标记选择器"></a>标记选择器</h3><p>如果要仅对导入的特定库应用合并规则标记，请添加带有库软件包名称的 tools:selector 属性。例如，对于下面的清单，只有在优先级较低的清单文件来自 com.example.lib1 库时，才会应用 remove 合并规则。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;permissionOne&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:node</span>=<span class="string">&quot;remove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:selector</span>=<span class="string">&quot;com.example.lib1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果优先级较低的清单来自其他任何来源，系统将会忽略 remove 合并规则。</p>
<p>注意：如果将此属性与某个属性标记一起使用，则它会应用于该标记中指定的所有属性。</p>
<h3 id="替换导入的库的-lt-uses-sdk-gt"><a href="#替换导入的库的-lt-uses-sdk-gt" class="headerlink" title="替换导入的库的 &lt;uses-sdk&gt;"></a>替换导入的库的 <code>&lt;uses-sdk&gt;</code></h3><p>默认情况下，导入 minSdkVersion 值高于主清单文件的库时会出错，而且无法导入该库。要使合并工具忽略此冲突并导入库，同时保留应用的较低 minSdkVersion 值，请将 overrideLibrary 属性添加到 <code>&lt;uses-sdk&gt;</code> 标记。属性值可以是一个或多个库软件包名称（用英文逗号分隔），指明可以替换主清单的 minSdkVersion 的库。</p>
<p>例如，如果应用的主清单按如下方式应用 overrideLibrary：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">package</span>=<span class="string">&quot;com.example.app&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">tools:overrideLibrary</span>=<span class="string">&quot;com.example.lib1, com.example.lib2&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>则以下清单可以合并，而不会出现与 <code>&lt;uses-sdk&gt;</code> 标记相关的错误，合并后的清单将保留应用清单中的 minSdkVersion=”2”。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">package</span>=<span class="string">&quot;com.example.lib1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span> <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式系统权限"><a href="#隐式系统权限" class="headerlink" title="隐式系统权限"></a>隐式系统权限</h3><p>一些曾经可由应用自由访问的 Android API 在最新的 Android 版本中受到了系统权限的限制。为了避免中断预期会访问这些 API 的应用，最新的 Android 版本允许应用在无权限的情况下继续访问这些 API，前提是它们已将 targetSdkVersion 设为低于添加限制的版本的值。此行为会有效地向应用授予隐式权限，以允许访问这些 API。因此，这可能会对具有不同 targetSdkVersion 值的合并后的清单产生以下影响。</p>
<p>如果优先级较低的清单文件具有较低的 targetSdkVersion 值，因而为其提供了一项隐式权限，但优先级较高的清单不具备相同的隐式权限（因为它的 targetSdkVersion 等于或高于添加限制的版本），则合并工具会向合并后的清单明确添加相应的系统权限。</p>
<p>例如，如果您的应用将 targetSdkVersion 设为 4 或更高的值，但导入的某个库将 targetSdkVersion 设为 3 或更低的值，则合并工具会向合并后的清单添加 WRITE_EXTERNAL_STORAGE 权限。</p>
<p>注意：如果您已将应用的 targetSdkVersion 设为 23 或更高的值，那么当应用试图访问受任何危险权限保护的 API 时，您必须对这些权限执行运行时权限请求。</p>
<table>
<thead>
<tr>
<th align="center">优先级较低的清单声明</th>
<th align="center">向合并后的清单添加的权限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">targetSdkVersion 为 3 或更低的值</td>
<td align="center">WRITE_EXTERNAL_STORAGE、READ_PHONE_STATE</td>
</tr>
<tr>
<td align="center">targetSdkVersion 为 15 或更低的值，并且使用 READ_CONTACTS</td>
<td align="center">READ_CALL_LOG</td>
</tr>
<tr>
<td align="center">targetSdkVersion 为 15 或更低的值，并且使用 WRITE_CONTACTS</td>
<td align="center">WRITE_CALL_LOG</td>
</tr>
</tbody></table>
<h2 id="检查合并后的清单并查找冲突"><a href="#检查合并后的清单并查找冲突" class="headerlink" title="检查合并后的清单并查找冲突"></a>检查合并后的清单并查找冲突</h2><p>可以通过Android Studio提供的工具查看合并后的Manifest文件。</p>
<h2 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h2><p>清单合并工具可以在逻辑上将一个清单文件中的每个 XML 元素与另一个文件中的对应元素匹配。合并工具会使用“匹配键”来匹配每个元素，匹配键可以是唯一的属性值（如 android:name），也可以是标记本身的自然唯一性（例如，只能有一个 &lt;<code>supports-screen&gt;</code> 元素）。如果两个清单具有相同的 XML 元素，则该工具会采用三种合并策略中的一种，将这两个元素合并在一起：</p>
<ul>
<li>合并：将所有非冲突属性组合到同一标记中，并按各自的合并策略合并子元素。如果任何属性相互冲突，使用合并规则标记将它们合并在一起。</li>
<li>仅合并子元素：不组合或合并属性（仅保留优先级最高的清单文件提供的属性），并按各自的合并策略合并子元素。</li>
<li>保留：将元素“按原样”保留，并将其添加到合并后的文件中的共同父元素。只有在可接受同一元素的多个声明时，才会采用此策略。</li>
</ul>
<img src="清单元素合并策略和匹配键.png"/>

<h1 id="将构建变量注入Manifest"><a href="#将构建变量注入Manifest" class="headerlink" title="将构建变量注入Manifest"></a>将构建变量注入Manifest</h1><p>如果需要将build.gradle中的变量注入到Manifest中，可以使用manifestPlaceholders属性：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        manifestPlaceholders = [<span class="attr">hostName:</span><span class="string">&quot;www.example.com&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Manifest中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span> <span class="attr">android:host</span>=<span class="string">&quot;$&#123;hostName&#125;&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，构建工具还会在${applicationId}占位符中提供应用程序的应用程序ID，该值始终与当前构建的最终应用程序ID匹配（包括构建变体的更改）。</p>
<p>例如，如果build.gradle中如下配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.myapp&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        free &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.free&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        pro &#123;</span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.pro&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Manifest中可以如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;$&#123;applicationId&#125;.TRANSMOGRIFY&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="自定义BuildConfig"><a href="#自定义BuildConfig" class="headerlink" title="自定义BuildConfig"></a>自定义BuildConfig</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            buildConfigField(<span class="string">&quot;String&quot;</span>, <span class="string">&quot;PLUGIN_NAME&quot;</span>, <span class="string">&quot;\&quot;$&#123;plugin_name&#125;\&quot;&quot;</span>)</span><br><span class="line">            buildConfigField(<span class="string">&quot;int&quot;</span>, <span class="string">&quot;PLUGIN_VERSION&quot;</span>, <span class="string">&quot;$&#123;plugin_version&#125;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="压缩代码和资源"><a href="#压缩代码和资源" class="headerlink" title="压缩代码和资源"></a>压缩代码和资源</h1><p>代码压缩通过 ProGuard 提供，ProGuard 会检测和移除封装应用中未使用的类、字段、方法和属性，包括自带代码库中的未使用项（这使其成为以变通方式解决 64k 引用限制的有用工具）。ProGuard 还可优化字节码，移除未使用的代码指令，以及用短名称混淆其余的类、字段和方法。混淆过的代码可令您的 APK 难以被逆向工程，这在应用使用许可验证等安全敏感性功能时特别有用。</p>
<h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><h3 id="压缩代码-1"><a href="#压缩代码-1" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>要通过 ProGuard 启用代码压缩，请在 build.gradle 文件内相应的构建类型中添加 <code>minifyEnabled true</code>。请注意，代码压缩会拖慢构建速度，因此您应该尽可能避免在调试构建中使用。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getDefaultProguardFile(‘proguard-android.txt’) 方法可从 Android SDK tools/proguard/ 文件夹获取默认的 ProGuard 设置。提示：要想做进一步的代码压缩，请尝试使用位于同一位置的 proguard-android-optimize.txt 文件。它包括相同的 ProGuard 规则，但还包括其他在字节码一级（方法内和方法间）执行分析的优化，以进一步减小 APK 大小和帮助提高其运行速度。</li>
<li>proguard-rules.pro 文件用于添加自定义 ProGuard 规则。默认情况下，该文件位于模块根目录（build.gradle 文件旁）。</li>
</ul>
<p>要添加更多各构建变体专用的 ProGuard 规则，请在相应的 productFlavor 代码块中再添加一个 proguardFiles 属性。例如，以下 Gradle 文件会向 flavor2 产品定制添加 flavor2-rules.pro。现在 flavor2 使用所有三个 ProGuard 规则，因为还应用了来自 release 代码块的规则。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),</span><br><span class="line">                   <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        flavor1 &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        flavor2 &#123;</span><br><span class="line">            proguardFile <span class="string">&#x27;flavor2-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次构建时 ProGuard 都会输出下列文件：</p>
<ul>
<li>dump.txt：说明 APK 中所有类文件的内部结构。</li>
<li>mapping.txt：提供原始与混淆过的类、方法和字段名称之间的转换。</li>
<li>seeds.txt：列出未进行混淆的类和成员。</li>
<li>usage.txt：列出从 APK 移除的代码。</li>
</ul>
<p>这些文件保存在 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code> 中。</p>
<h3 id="自定义要保留的代码"><a href="#自定义要保留的代码" class="headerlink" title="自定义要保留的代码"></a>自定义要保留的代码</h3><p>对于某些情况，默认 ProGuard 配置文件 (proguard-android.txt) 足以满足需要，ProGuard 会移除所有（并且只会移除）未使用的代码。不过，ProGuard 难以对许多情况进行正确分析，可能会移除应用真正需要的代码。举例来说，它可能错误移除代码的情况包括：</p>
<ul>
<li>当应用引用的类只来自 AndroidManifest.xml 文件时</li>
<li>当应用调用的方法来自 Java 原生接口 (JNI) 时</li>
<li>当应用在运行时（例如使用反射或自检）操作代码时</li>
</ul>
<p>测试应用应该能够发现因不当移除的代码而导致的错误，但您也可以通过查看 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code> 中保存的 usage.txt 输出文件来检查移除了哪些代码。</p>
<p>要修正错误并强制 ProGuard 保留特定代码，请在 ProGuard 配置文件中添加一行 -keep 代码。例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br></pre></td></tr></table></figure>

<p>或者，您可以向您想保留的代码添加 @Keep 注解。在类上添加 @Keep 可原样保留整个类。在方法或字段上添加它可完整保留方法/字段（及其名称）以及类名称。请注意，只有在使用注解支持库时，才能使用此注解。</p>
<p>在使用 -keep 选项时，有许多事项需要考虑；如需了解有关自定义配置文件的详细信息，请阅读 <a target="_blank" rel="noopener" href="http://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/introduction.html">ProGuard 手册</a>。<a target="_blank" rel="noopener" href="http://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/troubleshooting.html">问题排查</a>一章概述了您可能会在混淆代码时遇到的其他常见问题。</p>
<h3 id="解码混淆后的代码"><a href="#解码混淆后的代码" class="headerlink" title="解码混淆后的代码"></a>解码混淆后的代码</h3><p>ProGuard 每次运行时都会创建一个 mapping.txt 文件，其中显示了与混淆过的名称对应的原始类名称、方法名称和字段名称。ProGuard 将该文件保存在应用的 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code> 目录中。</p>
<p>要自行将混淆过的堆栈追踪转换成可读的堆栈追踪，请使用 retrace 脚本（在 Windows 上为 retrace.bat；在 Mac/Linux 上为 retrace.sh）。它位于 <code>&lt;sdk-root&gt;/tools/proguard/</code> 目录中。该脚本利用 mapping.txt 文件和您的堆叠追踪生成新的可读堆叠追踪。使用 retrace 工具的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retrace.bat -verbose mapping.txt obfuscated_trace.txt</span><br></pre></td></tr></table></figure>

<p>如果您不指定堆栈追踪文件，retrace 工具会从标准输入读取。</p>
<h3 id="通过-Instant-Run-启用代码压缩"><a href="#通过-Instant-Run-启用代码压缩" class="headerlink" title="通过 Instant Run 启用代码压缩"></a>通过 Instant Run 启用代码压缩</h3><p>Android 插件压缩器不会对您的代码进行混淆处理或优化，它只会删除未使用的代码。因此，您应该仅将其用于调试构建，并为发布构建启用 ProGuard，以便对发布 APK 的代码进行混淆处理和优化。</p>
<p>要启用 Android 插件压缩器，只需在 “debug” 构建类型中将 useProguard 设置为 false（并保留 minifyEnabled 设置 true）：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            useProguard <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="压缩资源"><a href="#压缩资源" class="headerlink" title="压缩资源"></a>压缩资源</h2><h3 id="压缩资源-1"><a href="#压缩资源-1" class="headerlink" title="压缩资源"></a>压缩资源</h3><p>资源压缩只与代码压缩协同工作。代码压缩器移除所有未使用的代码后，资源压缩器便可确定应用仍然使用的资源。这在您添加包含资源的代码库时体现得尤为明显 - 您必须移除未使用的库代码，使库资源变为未引用资源，才能通过资源压缩器将它们移除。</p>
<p>要启用资源压缩，请在 build.gradle 文件中将 shrinkResources 属性设置为 true（在用于代码压缩的 minifyEnabled 旁边）。例如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),</span><br><span class="line">                    <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您尚未使用代码压缩用途的 minifyEnabled 构建应用，请先尝试使用它，然后再启用 shrinkResources，因为您可能需要编辑 proguard-rules.pro 文件以保留动态创建或调用的类或方法，然后再开始移除资源。</p>
<p>注：资源压缩器目前不会移除 values/ 文件夹中定义的资源（例如字符串、尺寸、样式和颜色）。这是因为 Android 资源打包工具 (AAPT) 不允许 Gradle 插件为资源指定预定义版本。</p>
<h3 id="自定义要保留的资源"><a href="#自定义要保留的资源" class="headerlink" title="自定义要保留的资源"></a>自定义要保留的资源</h3><p>如果您有想要保留或舍弃的特定资源，请在您的项目中创建一个包含 <code>&lt;resources&gt;</code> 标记的 XML 文件，并在 tools:keep 属性中指定每个要保留的资源，在 tools:discard 属性中指定每个要舍弃的资源。这两个属性都接受逗号分隔的资源名称列表。您可以使用星号字符作为通配符。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:keep</span>=<span class="string">&quot;@layout/l_used*_c,@layout/l_used_a,@layout/l_used_b*&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:discard</span>=<span class="string">&quot;@layout/unused2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>将该文件保存在项目资源中，例如，保存在 res/raw/keep.xml。构建不会将该文件打包到 APK 之中。</p>
<p>指定要舍弃的资源可能看似愚蠢，因为您本可将它们删除，但在使用构建变体时，这样做可能很有用。例如，如果您明知给定资源表面上会在代码中使用（并因此不会被压缩器移除），但实际不会用于给定构建变体，就可以将所有资源放入公用项目目录，然后为每个构建变体创建一个不同的 keep.xml 文件。构建工具也可能无法根据需要正确识别资源，这是因为编译器会添加内联资源 ID，而资源分析器可能不知道真正引用的资源和恰巧具有相同值的代码中的整数值之间的差别。</p>
<h3 id="启用严格引用检查"><a href="#启用严格引用检查" class="headerlink" title="启用严格引用检查"></a>启用严格引用检查</h3><p>正常情况下，资源压缩器可准确判定系统是否使用了资源。不过，如果您的代码调用 Resources.getIdentifier()（或您的任何库进行了这一调用 - AppCompat 库会执行该调用），这就表示您的代码将根据动态生成的字符串查询资源名称。当您执行这一调用时，默认情况下资源压缩器会采取防御性行为，将所有具有匹配名称格式的资源标记为可能已使用，无法移除。</p>
<p>例如，以下代码会使所有带 img_ 前缀的资源标记为已使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = String.format(<span class="string">&quot;img_%1d&quot;</span>, angle + <span class="number">1</span>);</span><br><span class="line">res = getResources().getIdentifier(name, <span class="string">&quot;drawable&quot;</span>, getPackageName());</span><br></pre></td></tr></table></figure>

<p>资源压缩器还会浏览代码以及各种 res/raw/ 资源中的所有字符串常量，寻找格式类似于 <code>file:///android_res/drawable//ic_plus_anim_016.png</code> 的资源网址。如果它找到与其类似的字符串，或找到其他看似可用来构建与其类似的网址的字符串，则不会将它们移除。</p>
<p>这些是默认情况下启用的安全压缩模式的示例。但您可以停用这一“有备无患”处理方式，并指定资源压缩器只保留其确定已使用的资源。要执行此操作，请在 keep.xml 文件中将 shrinkMode 设置为 strict，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:shrinkMode</span>=<span class="string">&quot;strict&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您确已启用严格压缩模式，并且代码也引用了包含动态生成字符串的资源（如上所示），则必须利用 tools:keep 属性手动保留这些资源。</p>
<h3 id="移除未使用的备用资源"><a href="#移除未使用的备用资源" class="headerlink" title="移除未使用的备用资源"></a>移除未使用的备用资源</h3><p>Gradle 资源压缩器只会移除未被您的应用代码引用的资源，这意味着它不会移除用于不同设备配置的备用资源。必要时，您可以使用 Android Gradle 插件的 resConfigs 属性来移除您的应用不需要的备用资源文件。</p>
<p>例如，如果您使用的库包含语言资源（例如使用的是 AppCompat 或 Google Play 服务），则 APK 将包括这些库中消息的所有已翻译语言字符串，无论应用的其余部分是否翻译为同一语言。如果您想只保留应用正式支持的语言，则可以利用 resConfig 属性指定这些语言。系统会移除未指定语言的所有资源。</p>
<p>下面这段代码展示了如何将语言资源限定为仅支持英语和法语：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        resConfigs <span class="string">&quot;en&quot;</span>, <span class="string">&quot;fr&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，您也可以利用 APK 拆分为不同设备构建不同的 APK，自定义在 APK 中包括的屏幕密度或 ABI 资源。</p>
<h3 id="合并重复资源"><a href="#合并重复资源" class="headerlink" title="合并重复资源"></a>合并重复资源</h3><p>默认情况下，Gradle 还会合并同名资源，例如可能位于不同资源文件夹中的同名可绘制对象。这一行为不受 shrinkResources 属性控制，也无法停用，因为在有多个资源匹配代码查询的名称时，有必要利用这一行为来避免错误。</p>
<p>只有在两个或更多个文件具有完全相同的资源名称、类型和限定符时，才会进行资源合并。Gradle 会在重复项中选择其视为最佳选择的文件（根据下述优先顺序），并只将这一个资源传递给 AAPT，以供在 APK 文件中分发。</p>
<p>Gradle 会在下列位置寻找重复资源：</p>
<ul>
<li><p>与主源集关联的主资源，一般位于 src/main/res/ 中。</p>
</li>
<li><p>变体叠加，来自构建类型和构建风味。</p>
</li>
<li><p>库项目依赖项。<br>G<br>radle 会按以下级联优先顺序合并重复资源：</p>
</li>
<li><p>依赖项 → 主资源 → 构建风格 → 构建类型</p>
</li>
</ul>
<p>例如，如果某个重复资源同时出现在主资源和构建风味中，Gradle 会选择构建风格中的重复资源。</p>
<p>如果完全相同的资源出现在同一源集中，Gradle 无法合并它们，并且会发出资源合并错误。如果您在 build.gradle 文件的 sourceSet 属性中定义了多个源集，则可能会发生这种情况，例如，如果 src/main/res/ 和 src/main/res2/ 包含完全相同的资源，就可能会发生这种情况。</p>
<h3 id="排查资源压缩问题"><a href="#排查资源压缩问题" class="headerlink" title="排查资源压缩问题"></a>排查资源压缩问题</h3><p>当您压缩资源时，Gradle Console 会显示它从应用软件包中移除的资源的摘要。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:android:shrinkDebugResources</span><br><span class="line">Removed unused resources: Binary resource data reduced from 2570KB to 1711KB: Removed 33%</span><br><span class="line">:android:validateDebugSigning</span><br></pre></td></tr></table></figure>

<p>Gradle 还会在 <code>&lt;module-name&gt;/build/outputs/mapping/release/</code>（ProGuard 输出文件所在的文件夹）中创建一个名为 resources.txt 的诊断文件。该文件包括诸如哪些资源引用了其他资源以及使用或移除了哪些资源等详情。</p>
<p>例如，要了解您的 APK 为何仍包含 @drawable/ic_plus_anim_016，请打开 resources.txt 文件并搜索该文件名。您可能会发现，有其他资源引用了它，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">16:25:48.005 [QUIET] [system.out] @drawable&#x2F;add_schedule_fab_icon_anim : reachable&#x3D;true</span><br><span class="line">16:25:48.009 [QUIET] [system.out]     @drawable&#x2F;ic_plus_anim_016</span><br></pre></td></tr></table></figure>

<p>现在您需要了解为何 @drawable/add_schedule_fab_icon_anim 可以访问 - 如果您向上搜索，就会发现“The root reachable resources are:”之下列有该资源。这意味着存在对 add_schedule_fab_icon_anim 的代码引用（即在可访问代码中找到了其 R.drawable ID）。</p>
<p>如果您使用的不是严格检查，则存在看似可用于为动态加载资源构建资源名称的字符串常量时，可将资源 ID 标记为可访问。在这种情况下，如果您在构建输出中搜索资源名称，可能会找到类似下面这样的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:32:50.590 [QUIET] [system.out] Marking drawable:ic_plus_anim_016:2130837506</span><br><span class="line">    used because it format-string matches string pool constant ic_plus_anim_%1$d.</span><br></pre></td></tr></table></figure>

<p>如果您看到一个这样的字符串，并且您能确定该字符串未用于动态加载给定资源，就可以按照有关如何自定义要保留的资源部分中所述利用 tools:discard 属性通知构建系统将它移除。</p>
<h1 id="多DEX文件"><a href="#多DEX文件" class="headerlink" title="多DEX文件"></a>多DEX文件</h1><h2 id="关于“64K-引用限制”"><a href="#关于“64K-引用限制”" class="headerlink" title="关于“64K 引用限制”"></a>关于“64K 引用限制”</h2><p>Android 应用 (APK) 文件包含 Dalvik Executable (DEX) 文件形式的可执行字节码文件，这些文件包含用来运行应用的已编译代码。Dalvik Executable 规范将可在单个 DEX 文件内引用的方法总数限制为 65,536，其中包括 Android 框架方法、库方法以及您自己的代码中的方法。这一限制称为“64K 引用限制”。</p>
<p>Android 5.0（API 级别 21）之前的平台版本使用 Dalvik 运行时来执行应用代码。默认情况下，Dalvik 将应用限制为每个 APK 只能使用一个 classes.dex 字节码文件。要绕过这一限制，您可以在您的项目中添加多 dex 文件支持库：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;androidx.multidex:multidex:2.0.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您不使用 AndroidX，请改为添加以下支持库依赖项：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;com.android.support:multidex:1.0.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此库会成为应用的主要 DEX 文件的一部分，然后管理对其他 DEX 文件及其所包含代码的访问。</p>
<p>Android 5.0（API 级别 21）及更高版本使用名为 ART 的运行时，它本身支持从 APK 文件加载多个 DEX 文件。ART 在应用安装时执行预编译，扫描 classesN.dex 文件，并将它们编译成单个 .oat 文件，以供 Android 设备执行。因此，如果您的 minSdkVersion 为 21 或更高的值，则不需要多 dex 文件支持库。</p>
<h2 id="多DEX配置"><a href="#多DEX配置" class="headerlink" title="多DEX配置"></a>多DEX配置</h2><p>将您的应用项目设为使用多 dex 文件配置要求您对应用项目进行以下修改，具体取决于应用支持的最低 Android 版本。</p>
<p>如果您的 minSdkVersion 设为 21 或更高的值，您只需在模块级 build.gradle 文件中将 multiDexEnabled 设为 true，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，如果您的 minSdkVersion 设为 20 或更低的值，则您必须使用多 dex 文件支持库，具体操作步骤如下：</p>
<ol>
<li><p>修改模块级 build.gradle 文件以启用多 dex 文件，并将多 dex 文件库添加为依赖项，如下所示：</p>
 <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;com.android.support:multidex:1.0.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据是否替换 Application 类，执行以下某项操作：</p>
<ul>
<li><p>如果您不替换 Application 类，请修改清单文件以设置 <code>&lt;application&gt;</code> 标记中的 android:name，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.myapp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;android.support.multidex.MultiDexApplication&quot;</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果您替换 Application 类，请对其进行更改以扩展 MultiDexApplication（如果可能），如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">MultiDexApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者，如果您替换 Application 类，但无法更改基类，则可以改为替换 attachBaseContext() 方法并调用 MultiDex.install(this) 来启用多 dex 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">SomeOtherApplication</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">     MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在 MultiDex.install() 完成之前，不要通过反射或 JNI 执行 MultiDex.install() 或其他任何代码。多 dex 文件跟踪功能不会追踪这些调用，从而导致出现 ClassNotFoundException，或因 DEX 文件之间的类分区错误而导致验证错误。</p>
</li>
</ul>
</li>
</ol>
<p>现在，当您编译应用时，Android 编译工具会根据需要构造主要 DEX 文件 (classes.dex) 和辅助 DEX 文件（classes2.dex 和 classes3.dex 等）。然后，编译系统会将所有 DEX 文件打包到您的 APK 中。</p>
<p>在运行时，多 dex 文件 API 使用特殊的类加载器来搜索适用于您的方法的所有 DEX 文件（而不是只在主 classes.dex 文件中搜索）。</p>
<p>多 dex 文件支持库具有一些已知的局限性，将其纳入您的应用编译配置时，您应注意这些局限性并进行针对性的测试：</p>
<ul>
<li>启动期间在设备的数据分区上安装 DEX 文件的过程相当复杂，如果辅助 DEX 文件较大，可能会导致应用无响应 (ANR) 错误。在这种情况下，您应通过 ProGuard 应用代码压缩，以尽量减小 DEX 文件的大小，并移除未使用的那部分代码。</li>
<li>当运行的版本低于 Android 5.0（API 级别 21）时，使用多 dex 文件不足以避开 linearalloc 限制（<a target="_blank" rel="noopener" href="http://b.android.com/78035">问题 78035</a>）。此上限在 Android 4.0（API 级别 14）中有所提高，但这并未完全解决该问题。在低于 Android 4.0 的版本中，您可能会在达到 DEX 索引限制之前达到 linearalloc 限制。因此，如果您的目标 API 级别低于 14，请在这些版本的平台上进行全面测试，因为您的应用可能会在启动时或加载特定类组时出现问题。</li>
</ul>
<h2 id="声明主要-DEX-文件中必需的类"><a href="#声明主要-DEX-文件中必需的类" class="headerlink" title="声明主要 DEX 文件中必需的类"></a>声明主要 DEX 文件中必需的类</h2><p>为多 dex 文件应用编译每个 DEX 文件时，编译工具会执行复杂的决策制定来确定主要 DEX 文件中需要的类，以便您的应用能够成功启动。如果主要 DEX 文件中未提供启动期间需要的任何类，则您的应用会崩溃并出现 java.lang.NoClassDefFoundError 错误。</p>
<p>对于直接从您的应用代码访问的代码，不应发生这种情况，因为编译工具可以识别这些代码路径。但是，当代码路径的可见性较低时（例如，当您使用的库具有复杂的依赖项时），可能会发生这种情况。例如，如果代码使用自检机制或从原生代码调用 Java 方法，那么可能不会将这些类识别为主要 DEX 文件中的必需类。</p>
<p>因此，如果您收到 java.lang.NoClassDefFoundError，则必须使用版本类型中的 multiDexKeepFile 或 multiDexKeepProguard 属性声明这些其他类，以手动将这些类指定为主要 DEX 文件中的必需类。如果某个类在 multiDexKeepFile 或 multiDexKeepProguard 文件中匹配到，则会将该类添加到主要 DEX 文件。</p>
<h3 id="multiDexKeepFile-属性"><a href="#multiDexKeepFile-属性" class="headerlink" title="multiDexKeepFile 属性"></a>multiDexKeepFile 属性</h3><p>您在 multiDexKeepFile 中指定的文件应该每行包含一个类，并且类采用 com/example/MyClass.class 格式。例如，您可以创建一个名为 multidex-config.txt 的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F;example&#x2F;MyClass.class</span><br><span class="line">com&#x2F;example&#x2F;MyOtherClass.class</span><br></pre></td></tr></table></figure>

<p>然后，您可以针对版本类型声明该文件，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            multiDexKeepFile file(<span class="string">&#x27;multidex-config.txt&#x27;</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，Gradle 会读取相对于 build.gradle 文件的路径，因此如果 multidex-config.txt 与 build.gradle 文件在同一目录中，以上示例将有效。</p>
<h3 id="multiDexKeepProguard-属性"><a href="#multiDexKeepProguard-属性" class="headerlink" title="multiDexKeepProguard 属性"></a>multiDexKeepProguard 属性</h3><p>multiDexKeepProguard 文件使用与 Proguard 相同的格式，并且支持全部 Proguard 语法。如需详细了解 Proguard 格式和语法，请参阅 Proguard 手册中的 <a target="_blank" rel="noopener" href="http://proguard.sourceforge.net/manual/usage.html#keepoptions">Keep 选项</a> 一节。</p>
<p>您在 multiDexKeepProguard 中指定的文件应该在任何有效的 ProGuard 语法中包含 -keep 选项。例如，-keep com.example.MyClass.class。您可以创建一个名为 multidex-config.pro 的文件，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.example.MyClass</span><br><span class="line">-keep class com.example.MyClassToo</span><br></pre></td></tr></table></figure>

<p>如果您要指定软件包中的所有类，文件将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep class com.example.** &#123; *; &#125; &#x2F;&#x2F; All classes in the com.example package</span><br></pre></td></tr></table></figure>

<p>然后，您可以针对版本类型声明该文件，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            multiDexKeepProguard file(<span class="string">&#x27;multidex-config.pro&#x27;</span>)</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在开发编译中优化多-dex-文件"><a href="#在开发编译中优化多-dex-文件" class="headerlink" title="在开发编译中优化多 dex 文件"></a>在开发编译中优化多 dex 文件</h2><p>多 dex 文件配置会大幅增加编译处理时间，因为编译系统必须就哪些类必须包含在主要 DEX 文件中以及哪些类可以包含在辅助 DEX 文件中做出复杂的决策。这意味着，使用多 dex 文件的增量编译通常耗时较长，可能会拖慢您的开发进度。</p>
<p>要缩短较长的增量编译时间，您应使用 dex 预处理在编译之间重用多 dex 文件输出。dex 预处理依赖于一种只在 Android 5.0（API 级别 21）及更高版本中提供的 ART 格式。如果您使用的是 Android Studio 2.3 及更高版本，那么在将您的应用部署到搭载 Android 5.0（API 级别 21）或更高版本的设备上时，IDE 会自动使用此功能。</p>
<p>提示：Android Plugin for Gradle 3.0.0 及更高版本得到了进一步改进来优化编译速度，如每个类的 dex 处理（这样，只有您修改的类会重新进行 dex 处理）。一般来说，为了获得最佳开发体验，您应始终升级到最新版 Android Studio 和 Android 插件。</p>
<p>不过，如果您是从命令行运行 Gradle 编译，则需要将 minSdkVersion 设为 21 或更高的值以启用 dex 预处理。要保留正式版的设置，一种有用的策略是使用产品类型（一个开发类型和一个发布类型，它们具有不同的 minSdkVersion 值）来创建两个应用版本，如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// The default minimum API level you want to support.</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        <span class="comment">// Includes settings you want to keep only while developing your app.</span></span><br><span class="line">        dev &#123;</span><br><span class="line">            <span class="comment">// Enables pre-dexing for command line builds. When using</span></span><br><span class="line">            <span class="comment">// Android Studio 2.3 or higher, the IDE enables pre-dexing</span></span><br><span class="line">            <span class="comment">// when deploying your app to a device running Android 5.0</span></span><br><span class="line">            <span class="comment">// (API level 21) or higher—regardless of what you set for</span></span><br><span class="line">            <span class="comment">// minSdkVersion.</span></span><br><span class="line">            minSdkVersion <span class="number">21</span></span><br><span class="line">        &#125;</span><br><span class="line">        prod &#123;</span><br><span class="line">            <span class="comment">// If you&#x27;ve configured the defaultConfig block for the production version of</span></span><br><span class="line">            <span class="comment">// your app, you can leave this block empty and Gradle uses configurations in</span></span><br><span class="line">            <span class="comment">// the defaultConfig block instead. You still need to include this flavor.</span></span><br><span class="line">            <span class="comment">// Otherwise, all variants use the &quot;dev&quot; flavor configurations.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),</span><br><span class="line">                                                    <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;com.android.support:multidex:1.0.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：由于您有满足不同多 dex 文件需求的不同编译变体，因此也可以为不同的变体提供不同的清单文件（这样，只有适用于 API 级别 20 及更低级别的清单文件会更改 <code>&lt;application&gt;</code> 标记名称），或者为每个变体创建不同的 Application 子类（这样，只有适用于 API 级别 20 及更低级别的子类会扩展 MultiDexApplication 类或调用 MultiDex.install(this)）。</p>
<h2 id="测试多-dex-文件应用"><a href="#测试多-dex-文件应用" class="headerlink" title="测试多 dex 文件应用"></a>测试多 dex 文件应用</h2><p>编写多 dex 文件应用的插桩测试时，如果使用 MonitoringInstrumentation（或 AndroidJUnitRunner）插桩测试，则不需要额外的配置。如果使用其他 Instrumentation，则必须将其 onCreate() 方法替换为以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arguments)</span> </span>&#123;</span><br><span class="line">    MultiDex.install(getTargetContext());</span><br><span class="line">    <span class="keyword">super</span>.onCreate(arguments);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>请勿使用已弃用的 MultiDexTestRunner，请改用 AndroidJUnitRunner。</li>
<li>目前不支持使用多 dex 文件创建测试 APK。</li>
</ul>
<h1 id="aapt"><a href="#aapt" class="headerlink" title="aapt"></a>aapt</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>Android 天生为兼容各种各样不同的设备做了相当多的工作，比如屏幕大小、国际化、键盘、像素密度等等，我们能为各种各样特定的场景下使用特定的资源做兼容而不用改动一行代码，假设我们为各种各样不同的场景适配了不同的资源，如何能快速的应用上这些资源呢？Android 为我们提供了 R 这个类，指定了一个资源的索引（id），然后我们只需要告诉系统在不同的业务场景下，使用对应的资源就好了，至于具体是指定资源里面的哪一个具体文件，由系统根据开发者的配置决定。</p>
<p>在这种场景下，假设我们给定的 id 是 x 值，那么当下业务需要使用这个资源的时候，手机的状态就是 y 值，有了(x,y)，在一个表里面就能迅速的定位到资源文件的具体路径了。这个表就是 resources.arsc，它是从 aapt 编译出来的。</p>
<p>其实二进制的资源（比如图片）是不需要编译的，只不过这个“编译”的行为，是为了生成 resources.arsc 以及对 xml 文件进行二进制化等操作，resources.arsc 是上面说的表，xml 的二进制化是为了系统读取上性能更好。AssetManager 在我们调用 R 相关的 id 的时候，就会在这个表里面找到对应的文件，读取出来。</p>
<p>Gradle 在编译资源的过程中，就是调用的这些<a target="_blank" rel="noopener" href="https://developer.android.com/studio/command-line/aapt2">aapt2命令</a>，传的参数也在这个文档里都介绍了，只不过对开发者隐藏起了调用细节。</p>
<p>aapt2 主要分两步，一步叫 compile，一步叫 link。创建一个空工程：只写了两个 xml，分别是 AndroidManifest.xml 和 activity_main.xml。</p>
<h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir compiled</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> aapt2 compile src/main/res/layout/activity_main.xml -o compiled/</span></span><br></pre></td></tr></table></figure>

<p>在 compiled 文件夹中，生成了 layout_activity_main.xml.flat 这个文件，它是 aapt2 特有的，aapt 没有，aapt2 用它能进行增量编译。如果我们有很多的文件的话，需要依次调用 compile 才行，其实这里也可以使用 –dir 参数，只不过这个参数就没有增量编译的效果了。也就是说，当传递整个目录时，即使只有一个资源发生了变化，AAPT2也会重新编译目录中的所有文件。</p>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><p>link 的工作量比 compile 要多一点，此处的输入是多个 flat 的文件 和 AndroidManifest.xml，外部资源，输出是只包含资源的 apk 和 R.java。命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aapt2 link -o out.apk \</span><br><span class="line">-I $ANDROID_HOME/platforms/android-28/android.jar \</span><br><span class="line">compiled/layout_activity_main.xml.flat \</span><br><span class="line">--java src/main/java \</span><br><span class="line">--manifest src/main/AndroidManifest.xml</span><br></pre></td></tr></table></figure>

<ul>
<li>第二行 <code>-I</code> 是 import 外部资源，此处主要是 android 命名空间下定义的一些属性，我们平常使用的@android:xxx都是放在这个 jar 里面，其实我们也可以提供自己的资源供别人链接</li>
<li>第三行是输入的 flat 文件，如果有多个，直接在后面拼接即可</li>
<li>第四行是 R.java 生成的目录</li>
<li>第五行是指定 AndroidManifest.xml</li>
</ul>
<p>Link完成后会生成out.apk和R.java，out.apk中包含了一个resources.arsc文件。只带资源文件的可以用后缀名<code>.ap_</code>。</p>
<h2 id="查看编译后的资源"><a href="#查看编译后的资源" class="headerlink" title="查看编译后的资源"></a>查看编译后的资源</h2><p>除了是用 Android Studio 去查看 resources.arsc，还可以直接使用 <code>aapt2 dump apk</code> 信息的方式来查看资源相关的 ID 和状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt2 dump out.apk</span><br></pre></td></tr></table></figure>

<p>输出的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Binary APK</span><br><span class="line">Package name=com.geminiwen.hello id=7f</span><br><span class="line">  type layout id=01 entryCount=1</span><br><span class="line">    resource 0x7f010000 layout/activity_main</span><br><span class="line">      () (file) res/layout/activity_main.xml type=XML</span><br></pre></td></tr></table></figure>

<p>可以看到 layout/activity_main 对应的 ID 是 0x7f010000。顺便看下一个用 Android Studio 新建出来的 apk（为了简单，暂时去除了 support library）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Binary APK</span><br><span class="line">Package name=com.gemini.app.properties id=7f</span><br><span class="line">  type color id=01 entryCount=3</span><br><span class="line">    resource 0x7f010000 color/colorAccent</span><br><span class="line">      () #ffd81b60</span><br><span class="line">    resource 0x7f010001 color/colorPrimary</span><br><span class="line">      () #ff008577</span><br><span class="line">    resource 0x7f010002 color/colorPrimaryDark</span><br><span class="line">      () #ff00574b</span><br><span class="line">  type drawable id=02 entryCount=3</span><br><span class="line">    resource 0x7f020000 drawable/$ic_launcher_foreground__0</span><br><span class="line">      (v24) (file) res/drawable-v24/$ic_launcher_foreground__0.xml type=XML</span><br><span class="line">    resource 0x7f020001 drawable/ic_launcher_background</span><br><span class="line">      () (file) res/drawable/ic_launcher_background.xml type=XML</span><br><span class="line">    resource 0x7f020002 drawable/ic_launcher_foreground</span><br><span class="line">      (v24) (file) res/drawable-v24/ic_launcher_foreground.xml type=XML</span><br><span class="line">  type layout id=03 entryCount=1</span><br><span class="line">    resource 0x7f030000 layout/activity_main</span><br><span class="line">      () (file) res/layout/activity_main.xml type=XML</span><br><span class="line">  type mipmap id=04 entryCount=2</span><br><span class="line">    resource 0x7f040000 mipmap/ic_launcher</span><br><span class="line">      (mdpi) (file) res/mipmap-mdpi-v4/ic_launcher.png type=PNG</span><br><span class="line">      (hdpi) (file) res/mipmap-hdpi-v4/ic_launcher.png type=PNG</span><br><span class="line">      (xhdpi) (file) res/mipmap-xhdpi-v4/ic_launcher.png type=PNG</span><br><span class="line">      (xxhdpi) (file) res/mipmap-xxhdpi-v4/ic_launcher.png type=PNG</span><br><span class="line">      (xxxhdpi) (file) res/mipmap-xxxhdpi-v4/ic_launcher.png type=PNG</span><br><span class="line">      (anydpi-v26) (file) res/mipmap-anydpi-v26/ic_launcher.xml type=XML</span><br><span class="line">    resource 0x7f040001 mipmap/ic_launcher_round</span><br><span class="line">      (mdpi) (file) res/mipmap-mdpi-v4/ic_launcher_round.png type=PNG</span><br><span class="line">      (hdpi) (file) res/mipmap-hdpi-v4/ic_launcher_round.png type=PNG</span><br><span class="line">      (xhdpi) (file) res/mipmap-xhdpi-v4/ic_launcher_round.png type=PNG</span><br><span class="line">      (xxhdpi) (file) res/mipmap-xxhdpi-v4/ic_launcher_round.png type=PNG</span><br><span class="line">      (xxxhdpi) (file) res/mipmap-xxxhdpi-v4/ic_launcher_round.png type=PNG</span><br><span class="line">      (anydpi-v26) (file) res/mipmap-anydpi-v26/ic_launcher_round.xml type=XML</span><br><span class="line">  type string id=05 entryCount=1</span><br><span class="line">    resource 0x7f050000 string/app_name</span><br><span class="line">      () &quot;Gemini&quot;</span><br></pre></td></tr></table></figure>

<h2 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h2><p>android.jar 只是一个编译用的桩，真正执行的时候，Android OS 提供了一个运行时的库(framework.jar)。android.jar很像一个 apk，只不过它存在的是 class 文件，然后存在一个 AndroidManifest.xml 和 resources.arsc。这就意味着我们也可以对它用aapt2 dump，执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt2 dump $ANDROID_HOME/platforms/android-28/android.jar &gt; test.out</span><br></pre></td></tr></table></figure>

<p>得到很多类似如下的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resource 0x010a0000 anim/fade_in PUBLIC</span><br><span class="line">      () (file) res/anim/fade_in.xml type=XML</span><br><span class="line">    resource 0x010a0001 anim/fade_out PUBLIC</span><br><span class="line">      () (file) res/anim/fade_out.xml type=XML</span><br><span class="line">    resource 0x010a0002 anim/slide_in_left PUBLIC</span><br><span class="line">      () (file) res/anim/slide_in_left.xml type=XML</span><br><span class="line">    resource 0x010a0003 anim/slide_out_right PUBLIC</span><br><span class="line">      () (file) res/anim/slide_out_right.xml type=XML</span><br></pre></td></tr></table></figure>

<p>它多了一些PUBLIC的字段，一个 apk 文件里面的资源，如果被加上这个标记的话，就能被其他 apk 所引用，引用方式是<code>@包名:类型/名字</code>，例如：<code>@android:color/red</code>。</p>
<p>如果我们想要提供我们的资源，那么首先为我们的资源打上 PUBLIC 的标记，然后在 xml 中引用你的包名，比如：<code>@com.gemini.app:color/red</code> 就能引用到你定义的 color/red 了，如果你不指定包名，默认是自己。</p>
<p>至于 AAPT2 如何生成 PUBLIC，感兴趣的可以接着研究。</p>
<h1 id="Apk相关"><a href="#Apk相关" class="headerlink" title="Apk相关"></a>Apk相关</h1><h2 id="直接运行-Dex"><a href="#直接运行-Dex" class="headerlink" title="直接运行 Dex"></a>直接运行 Dex</h2><p>在 Android OS 上跑的虚拟机曾经叫 dalvik，现在叫 ART （Android Runtime）。</p>
<h3 id="编译-java文件"><a href="#编译-java文件" class="headerlink" title="编译.java文件"></a>编译.java文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javac -cp . Main.java</code>可得到.class文件。</p>
<h3 id="编译-class文件"><a href="#编译-class文件" class="headerlink" title="编译.class文件"></a>编译.class文件</h3><p>使用dx工具编译，在build-tools下不同的版本中都有dx工具。命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/Software/android_sdk/build-tools/29.0.1/dx --dex --output=classes.dex Main.class</span></span><br></pre></td></tr></table></figure>

<h3 id="运行-dex文件"><a href="#运行-dex文件" class="headerlink" title="运行.dex文件"></a>运行.dex文件</h3><p>将生成的classes.dex文件push进手机，运行命令即可得到输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dalvikvm -cp classes.dex Main                                                                       </span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>如果输错类名，得到输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unable to locate class &#x27;Mai&#x27;</span><br><span class="line">java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;Mai&quot; on path: DexPathList[[dex file &quot;classes.dex&quot;],nativeLibraryDirectories=[/system/lib64, /vendor/lib64, /system/lib64, /vendor/lib64]]</span><br><span class="line">	at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:134)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:379)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:312)</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassNotFoundException: Didn&#x27;t find class &quot;Mai&quot; on path: DexPathList[[dex file &quot;classes.dex&quot;],nativeLibraryDirectories=[/system/lib64, /vendor/lib64, /system/lib64, /vendor/lib64]]</span><br><span class="line">	at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:134)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:379)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:312)</span><br></pre></td></tr></table></figure>

<p>可以看到，此处的类加载器是 DexClassLoader，里面存在一个 DexPathList。</p>
<p>dalvikvm 除了能接受一个裸露的 dex 文件以外，还能接受一个 zip 格式的文件，只要求里面的 dex 文件名必须是 classes.dex 就行。比如我们传一个 zip/apk/jar 都能接受，毕竟他们的本质都是 zip。</p>
<h2 id="Dex-热修复与-Classpath"><a href="#Dex-热修复与-Classpath" class="headerlink" title="Dex 热修复与 Classpath"></a>Dex 热修复与 Classpath</h2><h3 id="热修复与-Classloader"><a href="#热修复与-Classloader" class="headerlink" title="热修复与 Classloader"></a>热修复与 Classloader</h3><p>参照腾讯开源的 Tinker 和阿里的 DexPatch 的原理，我们知道对于现在对于 java 代码的热修复主要从 DexClassLoader 里面的 dexPathList 入手，这里应用的原理就是 classloader 双亲委派里对于加载后的类的缓存机制。</p>
<ul>
<li>如果一个类在一个类加载器中加载过，就不会从其他类加载器中装载了。</li>
</ul>
<p>Android 提供的 DexClassloader 是按提供的 dex 顺序找的，因此对于 java 代码的热修复变得很简单：只要把想要被修复的 Dex 放到最前面，加载相关的类就好了，Tinker 和 DexPatch 当然还做了更多的事情，比如对 dex 进行 merge 之类的工作。</p>
<h3 id="构造有问题的-Dex"><a href="#构造有问题的-Dex" class="headerlink" title="构造有问题的 Dex"></a>构造有问题的 Dex</h3><p>首先要构造有问题的 Dex，写两个类，分别为Test.java，和HelloWorld.java，这里的HelloWorld类作为主入口，Test 类内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bug!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac Test.java HelloWorld.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dx --dex -output=classes.dex Test.class HelloWorld.class</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb push classes.dex /sdcard/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> adb shell</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /sdcard/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dalvikvm -cp classes.dex HelloWorld</span></span><br><span class="line">Bug!</span><br></pre></td></tr></table></figure>

<h3 id="构造修复后的-Dex"><a href="#构造修复后的-Dex" class="headerlink" title="构造修复后的 Dex"></a>构造修复后的 Dex</h3><p>在 Test.java 中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fixed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个新的new.dex：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/javac Test.java HelloWorld.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ~/dx --dex --output=new.dex Test.class</span></span><br></pre></td></tr></table></figure>

<h3 id="应用热修复"><a href="#应用热修复" class="headerlink" title="应用热修复"></a>应用热修复</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dalvikvm -cp new.dex:classes.dex HelloWorld</span></span><br><span class="line">Fixed!</span><br><span class="line"><span class="meta">$</span><span class="bash"> dalvikvm -cp classes.dex HelloWorld</span></span><br><span class="line">Bug!</span><br></pre></td></tr></table></figure>

<h2 id="手动创建可安装Apk"><a href="#手动创建可安装Apk" class="headerlink" title="手动创建可安装Apk"></a>手动创建可安装Apk</h2><p>可以在脱离Gradle的情况下使用sdk工具手工创建Android项目，然后生成Apk并打包。</p>
<h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">├── build</span><br><span class="line">├── compiled</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── AndroidManifest.xml</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── test</span><br><span class="line">        │           ├── MainActivity.java</span><br><span class="line">        └── res</span><br><span class="line">            ├── drawable</span><br><span class="line">            │   └── ic_launcher.png</span><br><span class="line">            └── layout</span><br><span class="line">                └── activity_main.xml</span><br></pre></td></tr></table></figure>

<p>AndroidManifest.xml内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.test&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;21&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;29&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;坤坤&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;com.test.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LEANBACK_LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MainActivity.java内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>activity_main.xml内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Test&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="编译资源"><a href="#编译资源" class="headerlink" title="编译资源"></a>编译资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aapt2 compile src/main/res/layout/activity_main.xml -o compiled/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> aapt2 compile src/main/res/drawable/ic_launcher.png -o compiled/</span></span><br></pre></td></tr></table></figure>

<h3 id="链接资源"><a href="#链接资源" class="headerlink" title="链接资源"></a>链接资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> aapt2 link -o resources.ap_ -I <span class="variable">$ANDROID_HOME</span>/platforms/android-29/android.jar compiled/drawable_ic_launcher.png.flat compiled/layout_activity_main.xml.flat --java src/main/java --manifest src/main/AndroidManifest.xml</span></span><br></pre></td></tr></table></figure>

<h3 id="编译class"><a href="#编译class" class="headerlink" title="编译class"></a>编译class</h3><p>java工具链中是没有android sdk的，所以需要在编译的时候导入classpath。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -d build -cp <span class="variable">$ANDROID_HOME</span>/platforms/android-29/android.jar src/main/java/**/*.java</span></span><br></pre></td></tr></table></figure>

<p>其中-d表示输出目录，-cp表示 classpath，后面跟着输入文件，src/main/java 目录下面所有的 java 文件。</p>
<h3 id="生成dex"><a href="#生成dex" class="headerlink" title="生成dex"></a>生成dex</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dx --dex --output=classes.dex build</span></span><br></pre></td></tr></table></figure>

<p>把前面的编译结果合起来，首先将ap_文件，复制一份，重命名成 apk 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp resources.ap_ app-debug.apk</span><br></pre></td></tr></table></figure>

<p>拿到了一个 apk（其实是zip文件），然后把 classes.dex 加进去。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -ur app-debug.apk classes.dex</span><br></pre></td></tr></table></figure>

<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 密码为android</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> apksigner sign -ks ~/.android/debug.keystore app-debug.apk</span></span><br></pre></td></tr></table></figure>

<h3 id="生成结果"><a href="#生成结果" class="headerlink" title="生成结果"></a>生成结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">├── app-debug.apk</span><br><span class="line">├── build</span><br><span class="line">│   └── com</span><br><span class="line">│       └── test</span><br><span class="line">│           ├── MainActivity.class</span><br><span class="line">│           ├── R.class</span><br><span class="line">│           ├── R$drawable.class</span><br><span class="line">│           └── R$layout.class</span><br><span class="line">├── classes.dex</span><br><span class="line">├── compiled</span><br><span class="line">│   ├── drawable_ic_launcher.png.flat</span><br><span class="line">│   └── layout_activity_main.xml.flat</span><br><span class="line">├── resources.ap_</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── AndroidManifest.xml</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── test</span><br><span class="line">        │           ├── MainActivity.java</span><br><span class="line">        │           └── R.java</span><br><span class="line">        └── res</span><br><span class="line">            ├── drawable</span><br><span class="line">            │   └── ic_launcher.png</span><br><span class="line">            └── layout</span><br><span class="line">                └── activity_main.xml</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="配置调试的Debug包apk可安装"><a href="#配置调试的Debug包apk可安装" class="headerlink" title="配置调试的Debug包apk可安装"></a>配置调试的Debug包apk可安装</h2><p>Android Studio 3.0会在debug apk的配置文件application标签里自动添加 android:testOnly=”true”属性，导致IDE中run跑出的apk无法安装，只能用于as测试安装。</p>
<p>解决办法：在gradle.properties(项目根目录或者gradle全局配置目录 ~/.gradle/)文件中添加<code>android.injected.testOnly=false</code> 之后就可以安装了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/Gradle/" rel="tag"># Gradle</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/19/Android-OpenGL-ES%E7%AC%94%E8%AE%B0/" rel="prev" title="Android-OpenGL-ES笔记">
      <i class="fa fa-chevron-left"></i> Android-OpenGL-ES笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/26/Android%E7%AD%BE%E5%90%8D%E7%AC%94%E8%AE%B0/" rel="next" title="Android签名笔记">
      Android签名笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">构建流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.</span> <span class="nav-text">构建配置文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SDK-Version"><span class="nav-number">2.</span> <span class="nav-text">SDK Version</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#compileSdkVersion"><span class="nav-number">2.1.</span> <span class="nav-text">compileSdkVersion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#minSdkVersion"><span class="nav-number">2.2.</span> <span class="nav-text">minSdkVersion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#targetSdkVersion"><span class="nav-number">2.3.</span> <span class="nav-text">targetSdkVersion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Set-the-Application-ID"><span class="nav-number">3.</span> <span class="nav-text">Set the Application ID</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEApplication-ID"><span class="nav-number">3.1.</span> <span class="nav-text">设置Application ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E7%94%A8%E4%BA%8E%E7%BC%96%E8%AF%91%E5%8F%98%E4%BD%93%E7%9A%84Application-ID"><span class="nav-number">3.2.</span> <span class="nav-text">更改用于编译变体的Application ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%9A%84%E5%BA%94%E7%94%A8-ID"><span class="nav-number">3.3.</span> <span class="nav-text">更改用于测试的应用 ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%90%8D%E7%A7%B0"><span class="nav-number">3.4.</span> <span class="nav-text">更改软件包名称</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Add-the-dependencies"><span class="nav-number">4.</span> <span class="nav-text">Add the dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%A1%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">依赖项类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">4.1.1.</span> <span class="nav-text">本地库模块依赖项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">4.1.2.</span> <span class="nav-text">本地二进制文件依赖项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">4.1.3.</span> <span class="nav-text">远程二进制文件依赖项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%A1%B9%E9%85%8D%E7%BD%AE"><span class="nav-number">4.2.</span> <span class="nav-text">依赖项配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">4.2.1.</span> <span class="nav-text">添加注解处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E9%99%A4%E4%BC%A0%E9%80%92%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">4.2.2.</span> <span class="nav-text">排除传递依赖项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-variant-aware-%E4%BE%9D%E8%B5%96%E9%A1%B9%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">使用 variant-aware 依赖项管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%BA%93"><span class="nav-number">4.4.</span> <span class="nav-text">远程代码库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E9%A1%B9%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.5.</span> <span class="nav-text">依赖项顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%A0%91"><span class="nav-number">4.6.</span> <span class="nav-text">查看依赖项树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E4%BE%9D%E8%B5%96%E9%A1%B9%E8%A7%A3%E6%9E%90%E9%94%99%E8%AF%AF"><span class="nav-number">4.7.</span> <span class="nav-text">修复依赖项解析错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E9%87%8D%E5%A4%8D%E7%B1%BB%E9%94%99%E8%AF%AF"><span class="nav-number">4.7.1.</span> <span class="nav-text">修复重复类错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%B1%BB%E8%B7%AF%E5%BE%84%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.7.2.</span> <span class="nav-text">解决类路径之间的冲突问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%E9%80%BB%E8%BE%91"><span class="nav-number">4.8.</span> <span class="nav-text">应用自定义构建逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%BB%E8%BE%91%E5%8F%91%E5%B8%83%E5%8F%98%E4%BD%93%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">4.8.1.</span> <span class="nav-text">为自定义逻辑发布变体依赖项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BE%9D%E8%B5%96%E9%A1%B9%E8%A7%A3%E6%9E%90%E7%AD%96%E7%95%A5"><span class="nav-number">4.8.2.</span> <span class="nav-text">自定义依赖项解析策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E5%8F%98%E4%BD%93"><span class="nav-number">5.</span> <span class="nav-text">配置编译变体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%89%88%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">配置版本类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%BA%A7%E5%93%81%E7%89%B9%E6%80%A7"><span class="nav-number">5.2.</span> <span class="nav-text">配置产品特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%BA%A7%E5%93%81%E7%89%B9%E6%80%A7-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">配置产品特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%A4%9A%E4%B8%AA%E4%BA%A7%E5%93%81%E7%89%B9%E6%80%A7%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%BB%B4%E5%BA%A6%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">将多个产品特性与类型维度结合使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%8F%98%E4%BD%93"><span class="nav-number">5.2.3.</span> <span class="nav-text">过滤变体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%B4%E5%BA%A6%E5%9B%9E%E9%80%80"><span class="nav-number">5.2.4.</span> <span class="nav-text">维度回退</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%BA%90%E9%9B%86"><span class="nav-number">5.3.</span> <span class="nav-text">创建源集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%BA%90%E9%9B%86-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">创建源集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E6%BA%90%E9%9B%86%E9%85%8D%E7%BD%AE"><span class="nav-number">5.3.2.</span> <span class="nav-text">更改默认源集配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%BA%90%E9%9B%86%E7%BC%96%E8%AF%91"><span class="nav-number">5.3.3.</span> <span class="nav-text">使用源集编译</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">5.4.</span> <span class="nav-text">声明依赖项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%AD%BE%E5%90%8D%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.5.</span> <span class="nav-text">配置签名设置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%BA%94%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">构建多应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E5%BA%94%E7%94%A8-1"><span class="nav-number">6.1.</span> <span class="nav-text">构建多应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6"><span class="nav-number">6.1.1.</span> <span class="nav-text">屏幕密度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ABI"><span class="nav-number">6.1.2.</span> <span class="nav-text">ABI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%89%88%E6%9C%AC"><span class="nav-number">6.2.</span> <span class="nav-text">配置版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96apk%E5%90%8D"><span class="nav-number">6.3.</span> <span class="nav-text">格式化apk名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Manifest%E5%90%88%E5%B9%B6"><span class="nav-number">7.</span> <span class="nav-text">Manifest合并</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">7.1.</span> <span class="nav-text">合并优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">合并冲突启发式算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99%E6%A0%87%E8%AE%B0"><span class="nav-number">7.3.</span> <span class="nav-text">合并规则标记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E6%A0%87%E8%AE%B0"><span class="nav-number">7.3.1.</span> <span class="nav-text">节点标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%A0%87%E8%AE%B0"><span class="nav-number">7.3.2.</span> <span class="nav-text">属性标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">7.3.3.</span> <span class="nav-text">标记选择器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E5%AF%BC%E5%85%A5%E7%9A%84%E5%BA%93%E7%9A%84-lt-uses-sdk-gt"><span class="nav-number">7.3.4.</span> <span class="nav-text">替换导入的库的 &lt;uses-sdk&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90"><span class="nav-number">7.3.5.</span> <span class="nav-text">隐式系统权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%90%88%E5%B9%B6%E5%90%8E%E7%9A%84%E6%B8%85%E5%8D%95%E5%B9%B6%E6%9F%A5%E6%89%BE%E5%86%B2%E7%AA%81"><span class="nav-number">7.4.</span> <span class="nav-text">检查合并后的清单并查找冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5"><span class="nav-number">7.5.</span> <span class="nav-text">合并策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%86%E6%9E%84%E5%BB%BA%E5%8F%98%E9%87%8F%E6%B3%A8%E5%85%A5Manifest"><span class="nav-number">8.</span> <span class="nav-text">将构建变量注入Manifest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89BuildConfig"><span class="nav-number">9.</span> <span class="nav-text">自定义BuildConfig</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%E5%92%8C%E8%B5%84%E6%BA%90"><span class="nav-number">10.</span> <span class="nav-text">压缩代码和资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81"><span class="nav-number">10.1.</span> <span class="nav-text">压缩代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81-1"><span class="nav-number">10.1.1.</span> <span class="nav-text">压缩代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A6%81%E4%BF%9D%E7%95%99%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">10.1.2.</span> <span class="nav-text">自定义要保留的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">10.1.3.</span> <span class="nav-text">解码混淆后的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Instant-Run-%E5%90%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9"><span class="nav-number">10.1.4.</span> <span class="nav-text">通过 Instant Run 启用代码压缩</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E8%B5%84%E6%BA%90"><span class="nav-number">10.2.</span> <span class="nav-text">压缩资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E8%B5%84%E6%BA%90-1"><span class="nav-number">10.2.1.</span> <span class="nav-text">压缩资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A6%81%E4%BF%9D%E7%95%99%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">10.2.2.</span> <span class="nav-text">自定义要保留的资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E4%B8%A5%E6%A0%BC%E5%BC%95%E7%94%A8%E6%A3%80%E6%9F%A5"><span class="nav-number">10.2.3.</span> <span class="nav-text">启用严格引用检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%A4%87%E7%94%A8%E8%B5%84%E6%BA%90"><span class="nav-number">10.2.4.</span> <span class="nav-text">移除未使用的备用资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E9%87%8D%E5%A4%8D%E8%B5%84%E6%BA%90"><span class="nav-number">10.2.5.</span> <span class="nav-text">合并重复资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E6%9F%A5%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E9%97%AE%E9%A2%98"><span class="nav-number">10.2.6.</span> <span class="nav-text">排查资源压缩问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9ADEX%E6%96%87%E4%BB%B6"><span class="nav-number">11.</span> <span class="nav-text">多DEX文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E2%80%9C64K-%E5%BC%95%E7%94%A8%E9%99%90%E5%88%B6%E2%80%9D"><span class="nav-number">11.1.</span> <span class="nav-text">关于“64K 引用限制”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9ADEX%E9%85%8D%E7%BD%AE"><span class="nav-number">11.2.</span> <span class="nav-text">多DEX配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%BB%E8%A6%81-DEX-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BF%85%E9%9C%80%E7%9A%84%E7%B1%BB"><span class="nav-number">11.3.</span> <span class="nav-text">声明主要 DEX 文件中必需的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#multiDexKeepFile-%E5%B1%9E%E6%80%A7"><span class="nav-number">11.3.1.</span> <span class="nav-text">multiDexKeepFile 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#multiDexKeepProguard-%E5%B1%9E%E6%80%A7"><span class="nav-number">11.3.2.</span> <span class="nav-text">multiDexKeepProguard 属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%BC%80%E5%8F%91%E7%BC%96%E8%AF%91%E4%B8%AD%E4%BC%98%E5%8C%96%E5%A4%9A-dex-%E6%96%87%E4%BB%B6"><span class="nav-number">11.4.</span> <span class="nav-text">在开发编译中优化多 dex 文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%A4%9A-dex-%E6%96%87%E4%BB%B6%E5%BA%94%E7%94%A8"><span class="nav-number">11.5.</span> <span class="nav-text">测试多 dex 文件应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#aapt"><span class="nav-number">12.</span> <span class="nav-text">aapt</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90"><span class="nav-number">12.1.</span> <span class="nav-text">资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compile"><span class="nav-number">12.2.</span> <span class="nav-text">Compile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Link"><span class="nav-number">12.3.</span> <span class="nav-text">Link</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">12.4.</span> <span class="nav-text">查看编译后的资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB"><span class="nav-number">12.5.</span> <span class="nav-text">资源共享</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Apk%E7%9B%B8%E5%85%B3"><span class="nav-number">13.</span> <span class="nav-text">Apk相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C-Dex"><span class="nav-number">13.1.</span> <span class="nav-text">直接运行 Dex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-java%E6%96%87%E4%BB%B6"><span class="nav-number">13.1.1.</span> <span class="nav-text">编译.java文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91-class%E6%96%87%E4%BB%B6"><span class="nav-number">13.1.2.</span> <span class="nav-text">编译.class文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-dex%E6%96%87%E4%BB%B6"><span class="nav-number">13.1.3.</span> <span class="nav-text">运行.dex文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dex-%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B8%8E-Classpath"><span class="nav-number">13.2.</span> <span class="nav-text">Dex 热修复与 Classpath</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E4%B8%8E-Classloader"><span class="nav-number">13.2.1.</span> <span class="nav-text">热修复与 Classloader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84-Dex"><span class="nav-number">13.2.2.</span> <span class="nav-text">构造有问题的 Dex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%BF%AE%E5%A4%8D%E5%90%8E%E7%9A%84-Dex"><span class="nav-number">13.2.3.</span> <span class="nav-text">构造修复后的 Dex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%83%AD%E4%BF%AE%E5%A4%8D"><span class="nav-number">13.2.4.</span> <span class="nav-text">应用热修复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%AE%89%E8%A3%85Apk"><span class="nav-number">13.3.</span> <span class="nav-text">手动创建可安装Apk</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="nav-number">13.3.1.</span> <span class="nav-text">新建工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%B5%84%E6%BA%90"><span class="nav-number">13.3.2.</span> <span class="nav-text">编译资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E8%B5%84%E6%BA%90"><span class="nav-number">13.3.3.</span> <span class="nav-text">链接资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91class"><span class="nav-number">13.3.4.</span> <span class="nav-text">编译class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90dex"><span class="nav-number">13.3.5.</span> <span class="nav-text">生成dex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D"><span class="nav-number">13.3.6.</span> <span class="nav-text">签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E7%BB%93%E6%9E%9C"><span class="nav-number">13.3.7.</span> <span class="nav-text">生成结果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">14.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E8%B0%83%E8%AF%95%E7%9A%84Debug%E5%8C%85apk%E5%8F%AF%E5%AE%89%E8%A3%85"><span class="nav-number">14.1.</span> <span class="nav-text">配置调试的Debug包apk可安装</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">166</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
