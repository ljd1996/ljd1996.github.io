<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。 在解析了 Android-SurfaceFlinger启动与工作流程 和 Android-Choreographer工作原理 后，明白了 Vsync 信号是怎么控制 SurfaceFlinger 进行合成 Layer 数据以及 Choreographer 是怎么控制开始绘制流程的，另外 Android-Vie">
<meta property="og:type" content="article">
<meta property="og:title" content="Android-Surface原理解析">
<meta property="og:url" content="http://yoursite.com/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="概述注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。 在解析了 Android-SurfaceFlinger启动与工作流程 和 Android-Choreographer工作原理 后，明白了 Vsync 信号是怎么控制 SurfaceFlinger 进行合成 Layer 数据以及 Choreographer 是怎么控制开始绘制流程的，另外 Android-Vie">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E5%8F%8C%E7%BC%93%E5%86%B2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/Android-%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.jpg">
<meta property="article:published_time" content="2020-11-09T13:43:58.000Z">
<meta property="article:modified_time" content="2021-05-14T06:14:57.775Z">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="图形系统">
<meta property="article:tag" content="Surface">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E5%8F%8C%E7%BC%93%E5%86%B2.jpg">

<link rel="canonical" href="http://yoursite.com/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android-Surface原理解析 | 苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android-Surface原理解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 21:43:58" itemprop="dateCreated datePublished" datetime="2020-11-09T21:43:58+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">图形系统</span></a>
                </span>
            </span>

          
            <span id="/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="Android-Surface原理解析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>注：本文基于Android 10源码，为了文章的简洁性，引用源码的地方可能有所删减。</p>
<p>在解析了 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/11/02/Android-SurfaceFlinger%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%98%E5%9B%BE%E5%8E%9F%E7%90%86/">Android-SurfaceFlinger启动与工作流程</a> 和 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/07/Android-Choreographer%E5%8E%9F%E7%90%86/">Android-Choreographer工作原理</a> 后，明白了 Vsync 信号是怎么控制 SurfaceFlinger 进行合成 Layer 数据以及 Choreographer 是怎么控制开始绘制流程的，另外 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/09/Android-View%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/">Android-View绘制流程</a> 中贴出了从 Choreographer.postCallback 接收到 Vsync 信号后调用 ViewRootImpl.performTraversals 开始 View 的 measure, layout, draw 流程的代码。接下来还有一个问题就是在 View 开始绘制后，即 View.draw 方法中绘制的数据是怎么流入 SurfaceFlinger 进程进行合成的。这里涉及到 Surface 的工作流程以及 BufferQueue 处理图形缓存区的逻辑，关于 BufferQueue 在后面会分析到与它相关的几个重要方法，不影响 Surface 的流程解析。</p>
<span id="more"></span>

<h1 id="Surface创建"><a href="#Surface创建" class="headerlink" title="Surface创建"></a>Surface创建</h1><h2 id="WMS-addWindow"><a href="#WMS-addWindow" class="headerlink" title="WMS.addWindow"></a>WMS.addWindow</h2><p>从 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/08/27/Android-Window%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/">Android-Window机制原理</a> 知道当调用 WM.addView 方法时会调用到 ViewRootImpl.setView 方法，然后通过 Binder 跨进程调用到 WMS.addWindow 方法，在该方法里创建了一个 WindowState 对象，进而调用其 attach 方法，最终调用到 Session.windowAddedLocked 方法，Surface 的创建就是从这里开始的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceSession</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mNativeClient; <span class="comment">// SurfaceComposerClient*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Create a new connection with the surface flinger. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceSession.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">    client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 SurfaceSession 构造方法中通过 nativeCreate 方法返回了一个 SurfaceComposerClient 指针，它表示一个跟 SurfaceFlinger 的连接。</p>
<p>当其第一次被使用时会调用如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceComposerClient::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = (rootProducer != <span class="literal">nullptr</span>) ? sf-&gt;<span class="built_in">createScopedConnection</span>(rootProducer) : sf-&gt;<span class="built_in">createConnection</span>();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposerClient&gt; <span class="title">SurfaceFlinger::createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">initClient</span>(<span class="keyword">new</span> <span class="built_in">Client</span>(<span class="keyword">this</span>)); <span class="comment">// initClient方法只是调用initCheck检查了一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即创建了一个实现 ISurfaceComposerClient 接口的 Client 对象。</p>
<p>总结一下上面 WMS 中的相关操作：WMS 创建了一个 WindowState 对象表示客户端的一个 Window, 接着调用 WindowState.attach 方法创建了一个 SurfaceSession 对象，SurfaceSession 表示一个跟 SurfaceFlinger 的连接，它创建了一个 SurfaceComposerClient 对象，然后 SurfaceComposerClient 又创建了一个 Client 对象。</p>
<h2 id="创建Surface"><a href="#创建Surface" class="headerlink" title="创建Surface"></a>创建Surface</h2><p>一个 ViewRootImpl 对象对应了一个 Surface 对象，在其源码中有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure>

<p>但此时这个 Surface 对象啥东西都没有，构造方法也是空的。根据 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/07/Android-Choreographer%E5%8E%9F%E7%90%86/">Android-Choreographer工作流程</a> 中的分析，ViewRootImpl.setView 方法会调用到 Choreographer 的逻辑，进而在 Vsync 信号到来后执行 ViewRootImpl.performTraversals 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending)</span><br><span class="line">    <span class="comment">// measure, layout, draw</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(...)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// 注意最后一个参数 mSurface 便是之前创建的 Surface 对象</span></span><br><span class="line">    <span class="comment">// 会调用 WMS.relayoutWindow 方法</span></span><br><span class="line">    mWindowSession.relayout(mWindow, ..., mSurface);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WMS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, ..., Surface outSurface)</span> </span>&#123;</span><br><span class="line">    result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win, WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面调用 createSurfaceLocked 方法创建了一个 WindowSurfaceController 对象，然后在 WindowSurfaceController 的构造方法中会创建一个 SurfaceControl 对象(mSurfaceControl, 通过构造方法实例化，代码不贴了)，顾名思义这个对象是用来维护 Surface 的，我们看一下这个类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SurfaceControl</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回 native SurfaceControl 指针</span></span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags, parent != <span class="keyword">null</span> ? parent.mNativeObject : <span class="number">0</span>, windowType, ownerUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// client 即上面创建的 SurfaceComposerClient 对象</span></span><br><span class="line">    <span class="function">sp&lt;SurfaceComposerClient&gt; <span class="title">client</span><span class="params">(android_view_SurfaceSession_getClient(env, sessionObj)</span>)</span>;</span><br><span class="line">    sp&lt;SurfaceControl&gt; surface;</span><br><span class="line">    client-&gt;createSurfaceChecked(String8(name.c_str()), w, h, format, &amp;surface, flags, parent, windowType, ownerUid);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t SurfaceComposerClient::createSurfaceChecked(..., sp&lt;SurfaceControl&gt;* outSurface, ...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, windowType, ownerUid, &amp;handle, &amp;gbp);</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="keyword">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t Client::createSurface(...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    flinger-&gt;createLayer(name, client, w, h, format, flags, windowType, ownerUid, handle, gbp, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Surface 在 SurfaceFlinger 中对应的实体是 Layer 对象，在 createLayer 方法中会创建好几种 Layer。因此可以知道在创建 SurfaceControl 对象时通过 SurfaceFlinger 创建了一个对应 Surface 的 Layer 对象。</p>
<p>接下来就到了 WindowSurfaceController.getSurface 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Surface.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 即上面返回的 native SurfaceControl 指针</span></span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeGetFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNativeObjectLocked</span><span class="params">(<span class="keyword">long</span> ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeObject != ptr) &#123;</span><br><span class="line">        mNativeObject = ptr;</span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHwuiContext.updateSurface();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ctrl 是前面创建的 SurfaceControl 对象</span></span><br><span class="line">    <span class="function">sp&lt;SurfaceControl&gt; <span class="title">ctrl</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>)</span>;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(ctrl-&gt;getSurface()</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (surface != NULL) &#123;</span><br><span class="line">        surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">_l</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateSurfaceLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// mGraphicBufferProducer 是上面创建的 gbp 对象</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面通过 nativeGetFromSurfaceControl 方法返回了一个 native 层创建的 Surface 指针，并赋值给了 Java 层 Surface 对象的 mNativeObject 属性。</p>
<h2 id="IGraphicBufferProducer"><a href="#IGraphicBufferProducer" class="headerlink" title="IGraphicBufferProducer"></a>IGraphicBufferProducer</h2><p>上面看到了一个 <code>IGraphicBufferProducer gbp</code> 对象，这是一个很重要的对象，我们看一下它是怎么被创建的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client, ..., sp&lt;IGraphicBufferProducer&gt;* gbp, ...)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            <span class="comment">// 只看这一种 Layer</span></span><br><span class="line">            result = <span class="built_in">createBufferLayer</span>(client, uniqueName, w, h, flags, format, handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createBufferLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span></span></span><br><span class="line"><span class="params"><span class="function">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;BufferLayer&gt; layer = <span class="keyword">new</span> <span class="built_in">BufferLayer</span>(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line">    <span class="keyword">status_t</span> err = layer-&gt;<span class="built_in">setBuffers</span>(w, h, format, flags);</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = layer-&gt;<span class="built_in">getHandle</span>();</span><br><span class="line">        *gbp = layer-&gt;<span class="built_in">getProducer</span>(); <span class="comment">// 获取 gbp</span></span><br><span class="line">        *outLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">BufferLayer::getProducer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mProducer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">    BufferQueue::<span class="built_in">createBufferQueue</span>(&amp;producer, &amp;consumer, <span class="literal">true</span>);</span><br><span class="line">    mProducer = <span class="keyword">new</span> <span class="built_in">MonitoredProducer</span>(producer, mFlinger, <span class="keyword">this</span>);</span><br><span class="line">    mConsumer = <span class="keyword">new</span> <span class="built_in">BufferLayerConsumer</span>(consumer, mFlinger-&gt;<span class="built_in">getRenderEngine</span>(), mTextureName, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mProducer 是 MonitoredProducer 实例，它是一个装饰类，实际功能都委托给了其 producer 属性:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueue::createBufferQueue</span><span class="params">(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span></span></span><br><span class="line"><span class="params"><span class="function">        sp&lt;IGraphicBufferConsumer&gt;* outConsumer, <span class="keyword">bool</span> consumerIsSurfaceFlinger)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;BufferQueueCore&gt; <span class="title">core</span><span class="params">(<span class="keyword">new</span> BufferQueueCore())</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferProducer&gt; <span class="title">producer</span><span class="params">(<span class="keyword">new</span> BufferQueueProducer(core, consumerIsSurfaceFlinger))</span></span>;</span><br><span class="line">    <span class="function">sp&lt;IGraphicBufferConsumer&gt; <span class="title">consumer</span><span class="params">(<span class="keyword">new</span> BufferQueueConsumer(core))</span></span>;</span><br><span class="line">    *outProducer = producer;</span><br><span class="line">    *outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 producer 是 BufferQueueProducer 对象, consumer 是 BufferQueueConsumer 对象。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Java 层中 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示，这点在后面会讲到。</p>
<h1 id="硬件加速-amp-软件绘制"><a href="#硬件加速-amp-软件绘制" class="headerlink" title="硬件加速&amp;软件绘制"></a>硬件加速&amp;软件绘制</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Resterization: 栅格化(光栅化)。栅格化把 Button, TextView 等组件拆分到不同的像素上进行显示，这是一个很费时的操作，GPU可以加快栅格化的操作。</p>
<p>Android 系统的 UI 从绘制到显示在屏幕上可分为两个步骤：</p>
<ol>
<li>Android APP 进程: 将 UI 绘制到一个图形缓冲区 GraphicBuffer 中，然后通知 SurfaceFlinger 进行合成。</li>
<li>SurfaceFlinger 进程: 将 GraphicBuffer 数据合成并交给屏幕缓存区去显示，这一步本身就是通过硬件(OpenGL 和 HardWare Composer)去完成的。</li>
</ol>
<p>因此我们说的硬件加速一般是指在 APP 进程将图形通过 GPU 加速渲染到 GraphicBuffer 的过程。GPU 作为一个硬件，用户空间不能直接使用，GPU 厂商会按照 OpenGL 的规范实现一套 API 驱动来调用它的相关功能。</p>
<p><strong>软件渲染</strong></p>
<ul>
<li>当 App 更新部分 UI 时，CPU 会遍历 View Tree 计算出需要重绘的脏区，接着在 View 层次结构中绘制所有跟脏区相交的区域，因此软件绘制会绘制到不需要重绘的视图。</li>
<li>软件绘制的绘制过程是在主线程进行的，可能会造成卡顿等情况。</li>
<li>软件绘制把要绘制的内容写进一个 Bitmap 位图，在之后的渲染过程中，这个 Bitmap 的像素内容会填充到 Surface 的缓存区里。</li>
<li>软件绘制使用 Skia 库。</li>
</ul>
<p><strong>硬件渲染</strong></p>
<ul>
<li>当 App 更新部分 UI 时，CPU 会计算出脏区，但是不会立即执行绘制命令，而是将 drawXXX 函数作为绘制指令(DrawOp)记录在一个列表(DisplayList)中，然后交给单独的 Render 线程使用 GPU 进行硬件加速渲染。</li>
<li>只需要针对需要更新的 View 对象的脏区进行记录或更新，无需更新的 View 对象则能重用先前 DisplayList 中记录的指令。</li>
<li>硬件加速是在单独的 Render 线程中完成绘制的，分担了主线程的压力，提高了响应速度。</li>
<li>硬件绘制使用 OpenGL 在 GPU 上完成，OpenGL 是跨平台的图形 API，为 2D/3D 图形处理硬件制定了标准的软件接口。听说在 Android 新版本中，Google 开始逐渐让 Skia 接手 OpenGL，实现间接统一调用。</li>
<li>硬件加速有几个缺陷：兼容性（部分绘制函数不支持速），内存消耗，电量消耗（GPU耗电）等。</li>
<li>从 Android 3.0(API 11)开始支持硬件加速，Android 4.0(API 14)默认开启硬件加速。</li>
</ul>
<p>关于 OpenGl ES 的简单使用可以参考：<a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/08/19/Android-OpenGL-ES%E7%AC%94%E8%AE%B0/">Android-OpenGL-ES笔记</a>和<a target="_blank" rel="noopener" href="https://developer.android.com/training/graphics/opengl">官方文档</a>。</p>
<h2 id="配置硬件加速"><a href="#配置硬件加速" class="headerlink" title="配置硬件加速"></a>配置硬件加速</h2><ul>
<li>Application: 在 Manifest 文件的 application 标签添加 <code>android:hardwareAccelerated=&quot;boolean&quot;</code></li>
<li>Activity: 在 Manifest 文件的 activity 标签添加 <code>android:hardwareAccelerated=&quot;boolean&quot;</code></li>
<li>Window: <code>getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)</code></li>
<li>View: <code>setLayerType(View.LAYER_TYPE_HARDWARE/*View.LAYER_TYPE_SOFTWARE*/, mPaint)</code></li>
</ul>
<p>判断是否支持硬件加速：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果Application、Activity配置了不开启硬件加速，则返回false</span></span><br><span class="line">view.isHardwareAccelerated()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如没有设置setLayerType，则受到Application、Activity的影响</span></span><br><span class="line"><span class="comment">// 假如设置了setLayerType，其返回值则受到setLayerType参数的影响</span></span><br><span class="line">canvas.isHardwareAccelerated()</span><br></pre></td></tr></table></figure>

<p>在绘制过程中会通过 VRImpl.enableHardwareAcceleration 方法去判断是否需要开启硬件加速：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">    mAttachInfo.mHardwareAccelerated = <span class="keyword">false</span>;</span><br><span class="line">    mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t enable hardware acceleration when the application is in compatibility mode</span></span><br><span class="line">    <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to enable hardware acceleration if requested</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hardwareAccelerated = (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hardwareAccelerated) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ThreadedRenderer.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Persistent processes (including the system) should not do accelerated rendering on low-end devices.</span></span><br><span class="line">        <span class="comment">// In that case, sRendererDisabled will be set. In addition, the system process itself should never do accelerated rendering. </span></span><br><span class="line">        <span class="comment">// In that case, both sRendererDisabled and sSystemRendererDisabled are set. When sSystemRendererDisabled is set,</span></span><br><span class="line">        <span class="comment">// PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED can be used by code on the system process to escape that and enable</span></span><br><span class="line">        <span class="comment">// HW accelerated drawing.  (This is basically for the lock screen.)</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> fakeHwAccelerated = (attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> forceHwAccelerated = (attrs.privateFlags &amp; WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fakeHwAccelerated) &#123;</span><br><span class="line">            <span class="comment">// This is exclusively for the preview windows the window manager shows for launching applications, </span></span><br><span class="line">            <span class="comment">// so they will look more like the app being launched.</span></span><br><span class="line">            mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled || (ThreadedRenderer.sSystemRendererDisabled &amp;&amp; forceHwAccelerated)) &#123;</span><br><span class="line">            <span class="comment">// 创建硬件加速的渲染器</span></span><br><span class="line">            mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent, attrs.getTitle().toString());</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setWideGamut(wideGamut);</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mHardwareAccelerated = mAttachInfo.mHardwareAccelerationRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sSupportsOpenGL != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sSupportsOpenGL.booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SystemProperties.getInt(<span class="string">&quot;ro.kernel.qemu&quot;</span>, <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Device is not an emulator.</span></span><br><span class="line">        sSupportsOpenGL = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> qemu_gles = SystemProperties.getInt(<span class="string">&quot;qemu.gles&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_gles == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// In this case, the value of the qemu.gles property is not ready</span></span><br><span class="line">        <span class="comment">// because the SurfaceFlinger service may not start at this point.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// In the emulator this property will be set &gt; 0 when OpenGL ES 2.0 is</span></span><br><span class="line">    <span class="comment">// enabled, 0 otherwise. On old emulator versions it will be undefined.</span></span><br><span class="line">    sSupportsOpenGL = qemu_gles &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sSupportsOpenGL.booleanValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h1><p>从 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/09/Android-View%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/">Android-View绘制流程</a> 知道软件绘制从 VRImpl.drawSoftware 方法开始。</p>
<h2 id="VRImpl-drawSoftware"><a href="#VRImpl-drawSoftware" class="headerlink" title="VRImpl.drawSoftware"></a>VRImpl.drawSoftware</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    canvas.setDensity(mDensity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        surface.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的软件绘制可以分成三个步骤：</p>
<ol>
<li>通过 Surface.lockCanvas 方法向 SurfaceFlinger Layer 申请一段共享内存</li>
<li>调用 View.draw 方法将绘制数据写入缓存区</li>
<li>通过 Surface.unlockCanvasAndPost 方法将图形缓存区数据入 Layer 的缓存队列并通知 SurfaceFlinger 进行合成</li>
</ol>
<h2 id="Surface-lockCanvas"><a href="#Surface-lockCanvas" class="headerlink" title="Surface.lockCanvas"></a>Surface.lockCanvas</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span> <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLockedObject != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// refuse to re-lock the Surface.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Surface was already locked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">        <span class="keyword">return</span> mCanvas;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用 native 方法 nativeLockCanvas 来获取 mLockedObject 指针，上面说过 mNativeObject 指向 native 层创建的 Surface 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 Dirty 区域创建 native Rect 对象</span></span><br><span class="line">    <span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">    Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">        <span class="comment">// 根据 Java 层 dirtyRectObj 初始化 dirtyRect 和 dirtyRectPtr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    <span class="comment">// 调用 lock 方法</span></span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;<span class="built_in">lock</span>(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">    <span class="comment">// 根据 outBuffer 创建 SkImageInfo</span></span><br><span class="line">    SkImageInfo info = SkImageInfo::<span class="built_in">Make</span>(outBuffer.width, outBuffer.height, <span class="built_in">convertPixelFormat</span>(outBuffer.format),</span><br><span class="line">                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888 ? kOpaque_SkAlphaType : kPremul_SkAlphaType,</span><br><span class="line">                                         GraphicsJNI::<span class="built_in">defaultColorSpace</span>());</span><br><span class="line">    <span class="comment">// 设置 bitmap</span></span><br><span class="line">    SkBitmap bitmap;</span><br><span class="line">    <span class="keyword">ssize_t</span> bpr = outBuffer.stride * <span class="built_in">bytesPerPixel</span>(outBuffer.format);</span><br><span class="line">    bitmap.<span class="built_in">setInfo</span>(info, bpr);</span><br><span class="line">    <span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        bitmap.<span class="built_in">setPixels</span>(outBuffer.bits);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">        bitmap.<span class="built_in">setPixels</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 native bitmap 设置给 native Canvas</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::<span class="built_in">getNativeCanvas</span>(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">setBitmap</span>(bitmap);</span><br><span class="line">    <span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">        nativeCanvas-&gt;<span class="built_in">clipRect</span>(dirtyRect.left, dirtyRect.top, dirtyRect.right, dirtyRect.bottom, SkClipOp::kIntersect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">lockedSurface</span><span class="params">(surface)</span></span>;</span><br><span class="line">    lockedSurface-&gt;<span class="built_in">incStrong</span>(&amp;sRefBaseOwner);</span><br><span class="line">    <span class="keyword">return</span> (jlong) lockedSurface.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 nativeLockCanvas 方法根据脏区创建了一个 Rect 对象，然后调用 surface-&gt;lock:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span> </span>&#123;</span><br><span class="line">    ANativeWindowBuffer* out;</span><br><span class="line">    <span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd); <span class="comment">// 取出一个图形缓存区 GraphicBuffer</span></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">    <span class="comment">// 锁定 GraphicBuffer</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;<span class="built_in">lockAsync</span>(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, newDirtyRegion.<span class="built_in">bounds</span>(), &amp;vaddr, fenceFd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLockedBuffer = backBuffer;</span><br><span class="line">        outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">        outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">        outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">        outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">        outBuffer-&gt;bits   = vaddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::dequeueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;<span class="built_in">dequeueBuffer</span>(&amp;buf, &amp;fence, reqWidth, reqHeight,</span><br><span class="line">        reqFormat, reqUsage, &amp;mBufferAge, enableFrameTimestamps ? &amp;frameTimestamps : <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    *buffer = gbuf.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mGraphicBufferProducer 是 Layer 中的 BufferQueueProducer – graph buffer 的生产者，在绘制时通过 BufferQueueProducer 生产者从 BufferQueue 中取出一个 GraphicBuffer 缓存区用来绘制。</p>
<p><strong>小结: Surface.lockCanvas 方法的作用是通过 BufferQueueProducer 生产者从 BufferQueue 队列中取出一个图形缓存区 GraphicBuffer(用来创建 Canvas 中的 Bitmap 对象) 并锁定该 Surface，然后将 Surface 的地址返回给 Java 层 Surface 中的 mLockedObject 属性</strong>。</p>
<h2 id="View-draw"><a href="#View-draw" class="headerlink" title="View.draw"></a>View.draw</h2><p>见 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/09/Android-View%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/#VRImpl-performDraw">Android-View绘制原理</a>, 以 drawLines 为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BaseCanvas</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawLines</span><span class="params">(@Size(multiple = <span class="number">4</span>) @NonNull <span class="keyword">float</span>[] pts, <span class="keyword">int</span> offset, <span class="keyword">int</span> count, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">nDrawLines</span>(mNativeCanvasWrapper, pts, offset, count, paint.<span class="built_in">getNativeInstance</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&quot;nDrawLines&quot;, &quot;(J[FIIJ)V&quot;, (void*) CanvasJNI::drawLines&#125;</span></span><br><span class="line"><span class="comment">// nDrawLines 方法对应 SkiaCanvas::drawLines</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawLines</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* points, <span class="keyword">int</span> count, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">drawPoints</span>(points, count, paint, SkCanvas::kLines_PointMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawPoints</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span>* points, <span class="keyword">int</span> count, <span class="keyword">const</span> SkPaint&amp; paint, SkCanvas::PointMode mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mCanvas 是 SkCanvas 类型指针</span></span><br><span class="line">    mCanvas-&gt;<span class="built_in">drawPoints</span>(mode, count, pts.<span class="built_in">get</span>(), paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawPoints</span><span class="params">(PointMode mode, <span class="keyword">size_t</span> count, <span class="keyword">const</span> SkPoint pts[], <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">onDrawPoints</span>(mode, count, pts, paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::onDrawPoints</span><span class="params">(PointMode mode, <span class="keyword">size_t</span> count, <span class="keyword">const</span> SkPoint pts[],</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">while</span> (iter.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        iter.fDevice-&gt;<span class="built_in">drawPoints</span>(mode, count, pts, looper.<span class="built_in">paint</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Android 新版本中，Google 开始逐渐让 Skia 接手 OpenGL，实现间接统一调用，因此无论是软件绘制还是硬件加速采用的都是 native 层 SkiaCanvas 对象，然后通过 fDevice-&gt;drawPoints 来真正实现绘制(构建)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里应该是软件绘制的 Device 类...吧，大概就是这么个意思</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkBitmapDevice::drawPoints</span><span class="params">(SkCanvas::PointMode mode, <span class="keyword">size_t</span> count, <span class="keyword">const</span> SkPoint pts[], <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绘制在 Bitmap 中</span></span><br><span class="line">    <span class="built_in">BDDraw</span>(<span class="keyword">this</span>).<span class="built_in">drawPoints</span>(mode, count, pts, paint, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Surface-unlockCanvasAndPost"><a href="#Surface-unlockCanvasAndPost" class="headerlink" title="Surface.unlockCanvasAndPost"></a>Surface.unlockCanvasAndPost</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123; <span class="comment">// 硬件绘制走这里</span></span><br><span class="line">            mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unlockSwCanvasAndPost(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        nativeRelease(mLockedObject);</span><br><span class="line">        mLockedObject = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过之前锁定的 Surface 的地址调用了 native 层的 nativeUnlockCanvasAndPost 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// detach the canvas from the surface</span></span><br><span class="line">    Canvas* nativeCanvas = GraphicsJNI::<span class="built_in">getNativeCanvas</span>(env, canvasObj);</span><br><span class="line">    nativeCanvas-&gt;<span class="built_in">setBitmap</span>(<span class="built_in">SkBitmap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlock surface</span></span><br><span class="line">    <span class="keyword">status_t</span> err = surface-&gt;<span class="built_in">unlockAndPost</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err = mLockedBuffer-&gt;<span class="built_in">unlockAsync</span>(&amp;fd);</span><br><span class="line">    err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);</span><br><span class="line">    mPostedBuffer = mLockedBuffer;</span><br><span class="line">    mLockedBuffer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mLockedBuffer 就是前面的 backBuffer, mLockedBuffer-&gt;unlockAsync 方法用来解除 GraphicBuffer 的锁定状态，然后看一下 queueBuffer 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Surface::queueBuffer</span><span class="params">(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">getSlotFromBufferLocked</span>(buffer);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    IGraphicBufferProducer::QueueBufferOutput output;</span><br><span class="line">    <span class="function">IGraphicBufferProducer::QueueBufferInput <span class="title">input</span><span class="params">(timestamp, isAutoTimestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">static_cast</span>&lt;android_dataspace&gt;(mDataSpace), crop, mScalingMode,</span></span></span><br><span class="line"><span class="params"><span class="function">            mTransform ^ mStickyTransform, fence, mStickyTransform, mEnableFrameTimestamps)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;<span class="built_in">queueBuffer</span>(i, input, &amp;output);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 mGraphicBufferProducer-&gt;queueBuffer 的具体代码就不看了，其逻辑是通过 mGraphicBufferProducer 生产者将填充了绘制数据的图形缓存区入 BufferQueue 队列，在 queueBuffer 调用后，会调用到 SF.signalLayerUpdate 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mEvents-&gt;<span class="built_in">requestNextVsync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就回到了 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/11/02/Android-SurfaceFlinger%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%98%E5%9B%BE%E5%8E%9F%E7%90%86/">Android-SurfaceFlinger启动与绘图原理</a> 的流程，它用来请求下一次 Vsync 信号。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>软件绘制可以简单分成以下三个步骤：</p>
<ol>
<li>Surface.lockCanvas 方法通过 BufferQueueProducer.dequeueBuffer 函数从 BufferQueue 中取出一个图形缓存区 GraphicBuffer(用来创建 Canvas 中的 Bitmap 对象) 并锁定该 Surface，然后将 Surface 的地址返回给 Java 层 Surface 中的 mLockedObject 属性。在这个方法中还会涉及到 Surface 的双缓冲逻辑，后面会具体讲解。</li>
<li>调用 View.draw 方法将内容绘制到 Canvas 对应的 Bitmap 中，其实就是往上面的图形缓存区 GraphicBuffer 填充绘制数据。</li>
<li>Surface.unlockCanvasAndPost 方法通过调用被锁定的 surface-&gt;unlockAndPost 方法解锁 Surface 且通过 queueBuffer 函数将填充了数据的图形缓存区 GraphicBuffer 存入 BufferQueue 队列中，然后通知给 SurfaceFlinger 进行合成(请求 Vsync 信号)。</li>
</ol>
<p>BufferQueueProducer 中的两个重要函数：</p>
<ul>
<li>dequeueBuffer: BufferQueueProducer 生产者通过 BufferQueue 请求一块空闲的缓存区(GraphicBuffer)</li>
<li>queueBuffer: BufferQueueProducer 生产者将填充了数据的缓存区(GraphicBuffer)入 BufferQueue 队列</li>
</ul>
<p>与 BufferQueue 以及生产者/消费者相关的几个重要方法在后续文章里会讲到，有上面的生产者就肯定有消费者的工作，大概猜一下可以知道消费者应该就是在 SurfaceFlinger 进程中通过 BufferQueueConsumer 去从 BufferQueue 中取出 GraphicBuffer 中的数据进行合成的，具体逻辑有兴趣的话在参考了 <a target="_blank" rel="noopener" href="https://juejin.im/post/6891980868798939150">Android-SurfaceFlinger启动与工作流程</a> 后可以自行阅读源码。</p>
<p>对于软件绘制中的 Canvas 而言其绘制目标是一个 Bitmap 对象，绘制的内容会填充到 Surface 持有的缓存区(GraphicBuffer)里。</p>
<h1 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h1><p>参考: <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/40f660e17a73">https://www.jianshu.com/p/40f660e17a73</a></p>
<p>从 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/09/09/Android-View%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/">Android-View绘制流程</a> 知道硬件绘制从 ThreadedRenderer.draw 方法开始。</p>
<h2 id="ThreadedRenderer-draw"><a href="#ThreadedRenderer-draw" class="headerlink" title="ThreadedRenderer.draw"></a>ThreadedRenderer.draw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks, FrameDrawingCallback frameDrawingCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">    choreographer.mFrameInfo.markDrawStart();</span><br><span class="line">    <span class="comment">// 构建 View 的 DrawOp 树</span></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line">    <span class="comment">// 通知 RenderThread 线程进行绘制</span></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将硬件绘制分为两个阶段：构建阶段 和 渲染阶段。</p>
<h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RenderNode mRootNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如有必要则更新 View 的 DisplayList</span></span><br><span class="line">    updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 通过 RenderNode 获取 DisplayListCanvas</span></span><br><span class="line">        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">            canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">            callbacks.onPreDraw(canvas);</span><br><span class="line"></span><br><span class="line">            canvas.insertReorderBarrier();</span><br><span class="line">            <span class="comment">// 利用 DisplayListCanvas 构建并缓存所有的 DrawOp</span></span><br><span class="line">            canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">            canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">            callbacks.onPostDraw(canvas);</span><br><span class="line">            canvas.restoreToCount(saveCount);</span><br><span class="line">            mRootNodeNeedsUpdate = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 将 View 构建的 DrawOp 存入 RenderNode 中，完成构建</span></span><br><span class="line">            mRootNode.end(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RenderNode renderNode = mRenderNode;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span> || !renderNode.isValid() || (mRecreateDisplayList)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">final</span> DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;<span class="comment">// 强制使用软件绘制</span></span><br><span class="line">                buildDrawingCache(<span class="keyword">true</span>);</span><br><span class="line">                Bitmap cache = getDrawingCache(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    canvas.drawBitmap(cache, <span class="number">0</span>, <span class="number">0</span>, mLayerPaint);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果自身不用绘制则直接递归子View</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                    dispatchDraw(canvas);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 调用 draw 方法，如果是 ViewGroup 会递归子View</span></span><br><span class="line">                    draw(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存构建Op</span></span><br><span class="line">            renderNode.end(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> renderNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们创建的 Canvas 是 DisplayListCanvas 类型实例，在调用 View.draw 方法后，使用 DisplayListCanvas 来绘图，以 drawLines 为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayListCanvas</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">drawLines</span><span class="params">(@Size(multiple = <span class="number">4</span>) @NonNull <span class="keyword">float</span>[] pts, <span class="keyword">int</span> offset, <span class="keyword">int</span> count, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">nDrawLines</span>(mNativeCanvasWrapper, pts, offset, count, paint.<span class="built_in">getNativeInstance</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由上面软件绘制 Canvas.draw 可知实现可能是在这里...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkGpuDevice::drawPoints</span><span class="params">(SkCanvas::PointMode mode, <span class="keyword">size_t</span> count, <span class="keyword">const</span> SkPoint pts[], <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 从 fRenderTargetContext 中的源码可以看出来这里面会构建 DrawOp</span></span><br><span class="line">    fRenderTargetContext-&gt;<span class="built_in">drawPath</span>(<span class="keyword">this</span>-&gt;<span class="built_in">clip</span>(), std::<span class="built_in">move</span>(grPaint), <span class="built_in">GrAA</span>(paint.<span class="built_in">isAntiAlias</span>()), <span class="keyword">this</span>-&gt;<span class="built_in">ctm</span>(), path, style);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面在 View.updateDisplayListIfDirty 方法中会遍历所有子 View 并通过 DisplayListCanvas 构建出一个 DrawOp 树，在递归完成 DrawOp 的构建后，会调用 RenderNode.end 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(DisplayListCanvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">    <span class="comment">// 将 displayList 缓存到 native 层的 RenderNode 中</span></span><br><span class="line">    nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">    canvas.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RenderNode.end 方法用来将 displayList 缓存到 native 层的 RenderNode 中。在 updateDisplayListIfDirty 方法遍历了子 View 并将缓存了 displayList 的 RenderNode 返回后，ThreadedRenderer 通过 DisplayListCanvas.drawRenderNode 方法将之前返回的 RenderNode 合入 ThreadedRenderer 内部的 RenderNode 中，然后也通过 RenderNode.end 方法将 displayList 缓存到 native 层的 RenderNode 里。</p>
<h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><p><strong>申请内存</strong></p>
<p>软件绘制申请内存是通过 Surface.lockCanvas 方法借由 BufferQueueProducer 取出一个图形缓存区 GraphicBuffer。至于硬件加速的内存是怎么申请的可以看看这部分代码(performTraversals 方法应该很熟悉了)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hwInitialized = mAttachInfo.mThreadedRenderer.initialize(mSurface);</span><br><span class="line">            <span class="keyword">if</span> (hwInitialized &amp;&amp; (host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == <span class="number">0</span>) &#123;</span><br><span class="line">                mSurface.allocateBuffers();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</span><br><span class="line">            handleOutOfResourcesException(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Surface.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allocateBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line">        nativeAllocateBuffers(mNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeAllocateBuffers</span><span class="params">(JNIEnv* <span class="comment">/* env */</span> , jclass <span class="comment">/* clazz */</span>, jlong nativeObject)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(reinterpret_cast&lt;Surface *&gt;(nativeObject)</span>)</span>;</span><br><span class="line">    surface-&gt;allocateBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Surface::allocateBuffers() &#123;</span><br><span class="line">    <span class="comment">// 依旧是调用 BufferQueueProducer 生产者分配 buffer</span></span><br><span class="line">    mGraphicBufferProducer-&gt;allocateBuffers(reqWidth, reqHeight, mReqFormat, mReqUsage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然硬件加速申请内存调用的方法不一样，但看上去也是借助 Layer 中的 BufferQueueProducer 生产者从 BufferQueue 中出队列了一块空闲缓存区。</p>
<p>可以看到硬件加速请求 SurfaceFlinger 内存分配的时机会比软件绘制更前，硬件加速这么设计可以预先分配内存，避免在渲染的时候再申请，防止分配内存失败时浪费了 CPU 之前的构建等工作，另外也可以将渲染线程的工作简化。</p>
<p><strong>渲染线程绑定Surface</strong></p>
<p>接着看一下 Render 线程是怎么跟目标 Surface 绘图界面绑定的(因为同一时刻可能有多个 Surface 绘图界面，它需要绑定一个渲染的上下文)，从上面看到申请内存前调用了 ThreadedRenderer.initialize 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadedRenderer</span></span><br><span class="line"><span class="function">boolean <span class="title">initialize</span><span class="params">(Surface surface)</span> throws OutOfResourcesException </span>&#123;</span><br><span class="line">    boolean status = !mInitialized;</span><br><span class="line">    mInitialized = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">updateEnabledState</span>(surface);</span><br><span class="line">    <span class="built_in">nInitialize</span>(mNativeProxy, surface);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_ThreadedRenderer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_ThreadedRenderer_initialize</span><span class="params">(JNIEnv* env, jobject clazz, jlong proxyPtr, jobject jsurface)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    sp&lt;Surface&gt; surface = <span class="built_in">android_view_Surface_getSurface</span>(env, jsurface);</span><br><span class="line">    proxy-&gt;<span class="built_in">initialize</span>(surface);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderProxy::initialize</span><span class="params">(<span class="keyword">const</span> sp&lt;Surface&gt;&amp; surface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向 Render 线程发送消息，执行 CanvasContext-&gt;setSurface 方法</span></span><br><span class="line">    mRenderThread.<span class="built_in">queue</span>().<span class="built_in">post</span>([ <span class="keyword">this</span>, surf = surface ]() <span class="keyword">mutable</span> &#123; mContext-&gt;<span class="built_in">setSurface</span>(std::<span class="built_in">move</span>(surf)); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面初始化时 CanvasContext 上下文通过 setSurface 方法将当前要渲染的 Surface 绑定到了 Render 线程中。</p>
<p><strong>渲染</strong></p>
<p>当渲染线程绑定了 Surface，且 Surface 内存分配以及 DrawOp 树构建完成后，便可以看一下渲染流程，从上面的 nSyncAndDrawFrame 方法开始，其实现在 Native 层：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_ThreadedRenderer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong proxyPtr, jlongArray frameInfo, jint frameInfoSize)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    env-&gt;<span class="built_in">GetLongArrayRegion</span>(frameInfo, <span class="number">0</span>, frameInfoSize, proxy-&gt;<span class="built_in">frameInfo</span>());</span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;<span class="built_in">syncAndDrawFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.<span class="built_in">drawFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawFrameTask::drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">postAndWait</span>();</span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">run</span>(); &#125;);</span><br><span class="line">    mSignal.<span class="built_in">wait</span>(mLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_LIKELY</span>(canDrawThisFrame)) &#123; <span class="comment">// CanvasContext</span></span><br><span class="line">        context-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don&#x27;t overlap next frame</span></span><br><span class="line">        context-&gt;<span class="built_in">waitOnFences</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来所有的 DrawOp 都会通过 OpenGL 被绘制到 GraphicBuffer 中，然后通知 SurfaceFlinger 进行合成，具体源码不贴了，因为看不大懂。</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>硬件加速可以从两个阶段来看：</p>
<ol>
<li>构建阶段：将 View 抽象成 RenderNode 节点，其每个绘制操作(drawLine…)都会抽象成 DrawOp 操作，它存在对应的 OpenGL 绘制命令并保存了绘图需要的数据。这个阶段会递归遍历所有 View 并通过 Canvas.drawXXX 将绘制操作转化成 DrawOp 存入 DisplayList 中，根据 ViewTree 模型，这个 DisplayList 虽然命名为 List，但其实更像一棵树。</li>
<li>绘制阶段：通过单独的 Render 线程，依赖 GPU 绘制上面的 DrawOp 数据。</li>
</ol>
<p>其中硬件加速的内存申请跟软件绘制一样都是借助 Layer 中的 BufferQueueProducer 生产者从 BufferQueue 中出队列一块空闲缓存区 GraphicBuffer 用来渲染数据的，之后也都会通知 SurfaceFlinger 进行合成。不一样的地方在于硬件加速相比软件绘制而言算法可能更加合理，同时采用了一个单独的 Render 线程，减轻了主线程的负担。</p>
<h1 id="双缓冲-View绘制过程"><a href="#双缓冲-View绘制过程" class="headerlink" title="双缓冲(View绘制过程)"></a>双缓冲(View绘制过程)</h1><p>一般来说将双缓冲用到的两块缓冲区称为 – 前缓冲区(front buffer) 和 后缓冲区(back buffer)。显示器显示的数据来源于 front buffer 前缓存区，而每一帧的数据都绘制到 back buffer 后缓存区，在 Vsync 信号到来后会交互缓存区的数据(指针指向)，这时 front buffer 和 back buffer 的称呼及功能倒转。</p>
<p>双缓冲的使用范围非常广泛，比如说在屏幕图像显示的时候就应用到了双缓冲 – 分为屏幕前缓冲区和屏幕后缓冲区，此外还有三缓冲…这里主要看看 View 在绘制的过程中是怎么使用双缓冲的。</p>
<h2 id="软件绘制中的双缓冲"><a href="#软件绘制中的双缓冲" class="headerlink" title="软件绘制中的双缓冲"></a>软件绘制中的双缓冲</h2><p>通过之前的解析可以知道软件绘制可分为三个步骤：</p>
<ol>
<li>Surface.lockCanvas: 会调用到 Native 层的 Surface.lock 方法</li>
<li>View.draw: 将绘制数据写入缓存区</li>
<li>Surface.unlockCanvasAndPost: 会调用到 Surface.unlockAndPost 方法</li>
</ol>
<p>双缓冲的解析可以从 Native 层的 Surface.lock 方法开始看起：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::lock</span><span class="params">(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span> </span>&#123;</span><br><span class="line">    ANativeWindowBuffer* out;</span><br><span class="line">    <span class="comment">// 通过生产者从 QueueBuffer 队列中取出一块空闲的图形缓存区--GraphicBuffer</span></span><br><span class="line">    <span class="keyword">status_t</span> err = <span class="built_in">dequeueBuffer</span>(&amp;out, &amp;fenceFd);</span><br><span class="line">    <span class="comment">// 将 GraphicBuffer 赋值给后缓存区 backBuffer</span></span><br><span class="line">    <span class="function">sp&lt;GraphicBuffer&gt; <span class="title">backBuffer</span><span class="params">(GraphicBuffer::getSelf(out))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    <span class="comment">// 计算新的脏区--1处图</span></span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">// App 通过调用 lockCanvas(Rect inOutDirty) 传递了一个脏区</span></span><br><span class="line">        <span class="comment">// 则将传入的 inOutDirty 作为新的脏区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则将后缓存区大小作为脏区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将正在显示的 mPostedBuffer 缓存区赋值给 frontBuffer 前缓存区</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; <span class="title">frontBuffer</span><span class="params">(mPostedBuffer)</span></span>;</span><br><span class="line">    <span class="comment">// 是否需要将前缓存区拷贝到后缓存区</span></span><br><span class="line">    <span class="comment">// 前缓存区有内容 &amp;&amp; 前后缓存区的长宽及格式一样</span></span><br><span class="line">    <span class="comment">// 第一次绘制时 frontBuffer 是没内容的</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        <span class="comment">// 可以拷贝时--2处图</span></span><br><span class="line">        <span class="comment">// copy the area that is invalid and not repainted this round</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">copyback</span><span class="params">(mDirtyRegion.subtract(newDirtyRegion))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!copyback.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="built_in">copyBlt</span>(backBuffer, frontBuffer, copyback, &amp;fenceFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不能拷贝时，后缓存区直接取新脏区的区域，确保重绘整个区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        mDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁定 backBuffer</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;<span class="built_in">lockAsync</span>(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">                newDirtyRegion.<span class="built_in">bounds</span>(), &amp;vaddr, fenceFd);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将后缓存区赋值给 mLockedBuffer</span></span><br><span class="line">        mLockedBuffer = backBuffer;</span><br><span class="line">        outBuffer-&gt;width  = backBuffer-&gt;width;</span><br><span class="line">        outBuffer-&gt;height = backBuffer-&gt;height;</span><br><span class="line">        outBuffer-&gt;stride = backBuffer-&gt;stride;</span><br><span class="line">        outBuffer-&gt;format = backBuffer-&gt;format;</span><br><span class="line">        outBuffer-&gt;bits   = vaddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上图的注释都比较清晰了，看一下上面标数字的 1 和 2 处逻辑：</p>
<p><img src="%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E5%8F%8C%E7%BC%93%E5%86%B2.jpg" alt="软件绘制双缓冲"></p>
<p>在拷贝后，后缓存区浅绿色的部分就是要重绘的区域，而绿色区域是之前前缓存区显示的内容，与脏区相交的部分要重绘，未相交的区域则不需要重绘，下次显示时接着使用该区域即可。</p>
<p>接下来看看 Surface.unlockAndPost 方法，其中 mLockedBuffer 在 lock 方法中被赋值为 backBuffer：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Surface::unlockAndPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 解锁 mLockedBuffer</span></span><br><span class="line">    <span class="keyword">status_t</span> err = mLockedBuffer-&gt;<span class="built_in">unlockAsync</span>(&amp;fd);</span><br><span class="line">    <span class="comment">// 将绘制后的缓存区入队列，等待被合成显示</span></span><br><span class="line">    err = <span class="built_in">queueBuffer</span>(mLockedBuffer.<span class="built_in">get</span>(), fd);</span><br><span class="line">    <span class="comment">// 赋值给 mPostedBuffer，代表要被显示的数据</span></span><br><span class="line">    mPostedBuffer = mLockedBuffer;</span><br><span class="line">    mLockedBuffer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<p>Surface.lock:</p>
<ol>
<li>将出队列的空闲缓存区 GraphicBuffer 赋给后缓存区 backBuffer，将正在显示的 mPostedBuffer 赋给前缓存区。</li>
<li>计算新的脏区，并确定是否需要将前缓存区拷贝到后缓存区，依此计算出后缓存区 backBuffer 的最终数据。然后将 backBuffer 与应用层的 Canvas 关联，当操作 Canvas 绘图时会将数据绘制到 backBuffer 上。</li>
<li>锁定 backBuffer 且将 backBuffer 指针赋值给 mLockedBuffer。</li>
</ol>
<p>Surface.unlockAndPost:</p>
<ol>
<li>将存有绘制数据的 mLockedBuffer 解锁并将其赋值给 mPostedBuffer。</li>
<li>将 mLockedBuffer 入 BufferQueue 队列，等待被合成显示，在这里便相当于交换了前后缓冲区的指针，等到下次绘制时，接着重复上面的步骤。</li>
</ol>
<h2 id="硬件绘制中的双缓冲"><a href="#硬件绘制中的双缓冲" class="headerlink" title="硬件绘制中的双缓冲"></a>硬件绘制中的双缓冲</h2><p>由之前的解析可以知道硬件绘制最终会调用 CanvasContext.draw 方法来绘制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.<span class="built_in">finish</span>(&amp;dirty);</span><br><span class="line">    Frame frame = mRenderPipeline-&gt;<span class="built_in">getFrame</span>();</span><br><span class="line">    <span class="comment">// 计算脏区</span></span><br><span class="line">    SkRect windowDirty = <span class="built_in">computeDirtyRect</span>(frame, &amp;dirty);</span><br><span class="line">    <span class="comment">// 渲染</span></span><br><span class="line">    <span class="keyword">bool</span> drew = mRenderPipeline-&gt;<span class="built_in">draw</span>(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mWideColorGamut, mLightInfo,</span><br><span class="line">                                      mRenderNodes, &amp;(<span class="built_in">profiler</span>()));</span><br><span class="line">    <span class="comment">// 交换缓存区</span></span><br><span class="line">    <span class="keyword">bool</span> didSwap = mRenderPipeline-&gt;<span class="built_in">swapBuffers</span>(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的代码比较复杂(看不太懂了)，大概可以看出硬件绘制时也是存在双缓冲的。</p>
<h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>SurfaceView 是一种较之 TextView, Button 等更为特殊的 View, 它不与其宿主的 Window 共享一个 Surface, 而是有自己的独立 Surface。并且它可以在一个独立的线程中绘制 UI。因此 SurfaceView 一般用来实现比较复杂的图像或动画/视频的显示。</p>
<p>这里插入一个内容，关于 View 为啥不能在子线程中操作 UI 的话可以看看 ViewRootImpl.checkThread 这个方法，参考 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/08/27/Android-Window%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/#ViewRootImpl-checkThread">ViewRootImpl.checkThread 方法</a> 其实就是因为每次操作 UI 都会去 check 线程，当然前提是 ViewRootImpl 已经被实例化了~</p>
<ul>
<li>SurfaceView 在绘图时实现了双缓冲机制(独立的 Surface)</li>
<li>普通 View 在绘图时会绘制到 Bitmap 中，然后通过其所在 Window 的 Surface 对象实现双缓冲。 </li>
</ul>
<p>一般来说，每个 Window 都有对应的 Surface 绘制表面，它在 SurfaceFlinger 服务中对应一个 Layer。而对于存在 SurfaceView 的 Window 来说，它除了自己的 Surface 以外还会有另一个 SurfaceView 独有的 Surface 绘制表面，在 SurfaceFlinger 服务中也会存在着两个 Layer 分别对应它们。查看 SurfaceView 的源码可以看到类似于 ViewRootImpl 一样其内部都有一个单独的 Surface 实例，于是结合之前的解析，就能理解刚才对 SurfaceView 的描述了。</p>
<p>SurfaceView 官方注释有一段: <code>The surface is Z ordered so that it is behind the window holding its SurfaceView; the SurfaceView punches a hole in its window to allow its surface to be displayed.</code></p>
<p>翻译一下大体意思是：Surface 是按照 Z 轴顺序排列的，SurfaceView 的 Surface 位于其宿主窗口的 Surface 后面；SurfaceView 在其窗口上打一个孔，以显示其 Surface。这个孔实际上是 SurfaceView 在其宿主窗口上设置了一块透明区域。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>接下来看一个使用 SurfaceView 的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySurfaceView</span></span>(context: Context?, attrs: AttributeSet?, defStyleAttr: <span class="built_in">Int</span>) :</span><br><span class="line">    SurfaceView(context, attrs, defStyleAttr), SurfaceHolder.Callback, Runnable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MySurfaceView&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> surfaceHolder: SurfaceHolder = holder</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> canvas: Canvas? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> canDoDraw = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> drawThread = Thread(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lock = Object()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> xx = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> yy = <span class="number">400f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> path = Path()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?) : <span class="keyword">this</span>(context, <span class="literal">null</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context?, attrs: AttributeSet?) : <span class="keyword">this</span>(context, attrs, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        surfaceHolder.addCallback(<span class="keyword">this</span>)</span><br><span class="line">        isFocusable = <span class="literal">true</span></span><br><span class="line">        isFocusableInTouchMode = <span class="literal">true</span></span><br><span class="line">        keepScreenOn = <span class="literal">true</span></span><br><span class="line">        path.moveTo(xx, yy)</span><br><span class="line">        paint.style = Paint.Style.STROKE</span><br><span class="line">        paint.strokeWidth = <span class="number">10f</span></span><br><span class="line">        paint.color = Color.RED</span><br><span class="line">        drawThread.start()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceCreated</span><span class="params">(holder: <span class="type">SurfaceHolder</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;surfaceCreated&quot;</span>)</span><br><span class="line">        setCanDraw(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceChanged</span><span class="params">(holder: <span class="type">SurfaceHolder</span>?, format: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;surfaceChanged&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">surfaceDestroyed</span><span class="params">(holder: <span class="type">SurfaceHolder</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;surfaceDestroyed&quot;</span>)</span><br><span class="line">        canDoDraw = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 注意当APP到后台时会 destroy Surface, 回到前台会重新调用 surfaceCreated</span></span><br><span class="line">        <span class="comment">// 因此这里不能移除回调，否则会黑屏</span></span><br><span class="line">        <span class="comment">// surfaceHolder.removeCallback(this)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onTouchEvent&quot;</span>)</span><br><span class="line">        setCanDraw(!canDoDraw)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setCanDraw</span><span class="params">(canDraw: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canDraw) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.notifyAll()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        canDoDraw = canDraw</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!canDoDraw) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait()</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                        e.printStackTrace()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            draw()</span><br><span class="line">            xx += <span class="number">1</span></span><br><span class="line">            yy = (<span class="number">100</span> * sin(xx * <span class="number">2</span> * Math.PI / <span class="number">180</span>) + <span class="number">400</span>).toFloat()</span><br><span class="line">            path.lineTo(xx, yy)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas = surfaceHolder.lockCanvas()</span><br><span class="line">            canvas?.drawColor(Color.WHITE)</span><br><span class="line">            canvas?.drawPath(path, paint)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            surfaceHolder.unlockCanvasAndPost(canvas ?: <span class="keyword">return</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先看一下 SurfaceHolder 这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SurfaceHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首次创建 Surface 后会调用此方法，在这个回调里应该开始绘制任务</span></span><br><span class="line">        <span class="comment">// 只有一个线程可以绘制到 Surface 中，如果渲染任务将在另一个线程中进行则不能在此处绘制 Surface</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 Surface 结构更改(format or size)后会调用此方法，在这个回调里应该更新 Surface 的图像</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 Surface destroy 之前会调用此方法，在这个回调以后不应该尝试访问此 Surface</span></span><br><span class="line">        <span class="comment">// 如果具有直接访问*曲面的渲染线程，则必须确保该线程不再接触*曲面，然后才能从此函数返回。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(Callback callback)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCallback</span><span class="params">(Callback callback)</span></span>;</span><br><span class="line">    <span class="comment">// 是否正在通过 Callback 方法创建 Surface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCreating</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span></span>; <span class="comment">// Sets the surface&#x27;s type.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFixedSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSizeFromLayout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFormat</span><span class="params">(<span class="keyword">int</span> format)</span></span>;</span><br><span class="line">    <span class="comment">// Enable or disable option to keep the screen turned on while this surface is displayed.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepScreenOn</span><span class="params">(<span class="keyword">boolean</span> screenOn)</span></span>; <span class="comment">// 默认 false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect dirty)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;This SurfaceHolder doesn&#x27;t support lockHardwareCanvas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Rect <span class="title">getSurfaceFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Surface <span class="title">getSurface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 SurfaceHolder 是用来管理 Surface 的类。接下来看下 SurfaceView 的 draw 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawFinished &amp;&amp; !isAboveParent()) &#123;</span><br><span class="line">        <span class="comment">// draw() is not called when SKIP_DRAW is set</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// punch a whole in the view-hierarchy below us</span></span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDrawFinished &amp;&amp; !isAboveParent()) &#123;</span><br><span class="line">        <span class="comment">// draw() is not called when SKIP_DRAW is set</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">            <span class="comment">// punch a whole in the view-hierarchy below us</span></span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceView 方法中 draw 和 dispatchDraw 的参数 canvas 是从宿主的 Surface 中获取的，因此在该 canvas 上绘制的内容都会出现在宿主的 Surface 上。</p>
<p>所以可以看到 SurfaceView.draw 和 SurfaceView.dispatchDraw 方法的逻辑是：如果当前 SurfaceView 不是用作宿主窗口面板，则 SurfaceView 在其宿主窗口 Surface 上的操作只是清空 Canvas 区域，因为 SurfaceView 的内容是需要展现在自己单独的 Surface 上的(像上面的示例一样，通过其 Surface 拿到一个 Canvas 并在一个独立线程在其上进行绘制)。</p>
<p>接着看一下 SurfaceView 中 SurfaceHolder 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SurfaceView</span> <span class="keyword">extends</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">ViewRootImpl</span>.<span class="title">WindowStoppedCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;SurfaceHolder.Callback&gt; mCallbacks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mSurfaceLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SurfaceHolder <span class="title">getHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSurfaceHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SurfaceHolder mSurfaceHolder = <span class="keyword">new</span> SurfaceHolder() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mCallbacks) &#123; <span class="comment">// 添加回调</span></span><br><span class="line">                <span class="keyword">if</span> (mCallbacks.contains(callback) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    mCallbacks.add(callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFixedSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mRequestedWidth != width || mRequestedHeight != height) &#123;</span><br><span class="line">                mRequestedWidth = width;</span><br><span class="line">                mRequestedHeight = height;</span><br><span class="line">                requestLayout(); <span class="comment">// 重新 layout</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepScreenOn</span><span class="params">(<span class="keyword">boolean</span> screenOn)</span> </span>&#123;</span><br><span class="line">            runOnUiThread(() -&gt; SurfaceView.<span class="keyword">this</span>.setKeepScreenOn(screenOn));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> internalLockCanvas(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> internalLockCanvas(inOutDirty, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> internalLockCanvas(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁定 Surface</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Canvas <span class="title">internalLockCanvas</span><span class="params">(Rect dirty, <span class="keyword">boolean</span> hardware)</span> </span>&#123;</span><br><span class="line">            mSurfaceLock.lock();</span><br><span class="line"></span><br><span class="line">            Canvas c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!mDrawingStopped &amp;&amp; mSurfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hardware) &#123; <span class="comment">// 硬件渲染</span></span><br><span class="line">                        c = mSurface.lockHardwareCanvas();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 软件渲染</span></span><br><span class="line">                        c = mSurface.lockCanvas(dirty);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(LOG_TAG, <span class="string">&quot;Exception locking surface&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mLastLockTime = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当返回 null 时使 internalLockCanvas 被调用的间隔超过100ms</span></span><br><span class="line">            <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> nextTime = mLastLockTime + <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span> (nextTime &gt; now) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(nextTime-now);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                now = SystemClock.uptimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">            mLastLockTime = now;</span><br><span class="line">            mSurfaceLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">            mSurface.unlockCanvasAndPost(canvas);</span><br><span class="line">            mSurfaceLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Surface <span class="title">getSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mSurface;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出调用 SurfaceHolder 的 lock 和 unlock 系列方法都是调用到了 Surface 中的方法。除了 lockHardwareCanvas 方法，其他的都已经看过了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHwuiContext = <span class="keyword">new</span> HwuiContext(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mHwuiContext.lockCanvas(nativeGetWidth(mNativeObject), nativeGetHeight(mNativeObject));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HwuiContext</span></span><br><span class="line"><span class="function">Canvas <span class="title">lockCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Surface was already locked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mCanvas = mRenderNode.start(width, height);</span><br><span class="line">    <span class="keyword">return</span> mCanvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 HwuiContext.lockCanvas 是使用硬件加速的方式，其调用的 RenderNode.start 之前已经看过了，与之对应的 RenderNode.end 方法是在这里调用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mHwuiContext != <span class="keyword">null</span>) &#123; <span class="comment">// 不为空时</span></span><br><span class="line">            mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unlockSwCanvasAndPost(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HwuiContext</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlockAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canvas != mCanvas) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;canvas object must be the same instance that &quot;</span></span><br><span class="line">                + <span class="string">&quot;was previously returned by lockCanvas&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mRenderNode.end(mCanvas);</span><br><span class="line">    mCanvas = <span class="keyword">null</span>;</span><br><span class="line">    nHwuiDraw(mHwuiRenderer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即 SurfaceView 的绘制兼顾了软件绘制和硬件加速绘制。另外在 SurfaceView.updateSurface 方法中会更新 Surface 的状态并将其回调给 SurfaceHolder.Callback 相关方法，具体逻辑便不给出了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Java 层的 Surface 对象中 mNativeObject 属性指向 native 层中创建的 Surface 对象。</li>
<li>Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中的 BufferQueueProducer 指针(生产者)，通过这个生产者对象可以在绘制时向 BufferQueue 申请一块空闲的图形缓存区 GraphicBuffer，在 Surface 上绘制的内容会存入该缓存区内。</li>
<li>SurfaceFlinger 通过 BufferQueueConsumer 消费者从 BufferQueue 中取出 GraphicBuffer 中的数据进行合成渲染并送到显示器显示。</li>
</ul>
<p><strong>软件绘制</strong></p>
<p>软件绘制可能会绘制到不需要重绘的视图，且其绘制过程在主线程进行的，可能会造成卡顿等情况。它把要绘制的内容写进一个 Bitmap 位图，其实就是填充到了 Surface 申请的图形缓存区里。</p>
<p>软件绘制可分为三个步骤：</p>
<ol>
<li>Surface.lockCanvas – dequeueBuffer 从 BufferQueue 中出队列一块缓存区。</li>
<li>View.draw – 绘制内容。</li>
<li>Surface.unlockCanvasAndPost – queueBuffer 将填充了数据的缓存区存入 BufferQueue 队列中，然后通知给 SurfaceFlinger 进行合成(请求 Vsync 信号)。</li>
</ol>
<p><strong>硬件绘制</strong></p>
<p>硬件绘制会将绘制函数作为绘制指令(DrawOp)记录在一个列表(DisplayList)中，然后交给单独的 Render 线程使用 GPU 进行硬件加速渲染。它只需要针对需要更新的 View 对象的脏区进行记录或更新，无需更新的 View 对象则能重用先前 DisplayList 中记录的指令。</p>
<p>硬件绘制可分为两个阶段：</p>
<ol>
<li>构建阶段：将 View 的绘制操作(drawLine…)抽象成 DrawOp 操作并存入 DisplayList 中。</li>
<li>绘制阶段：首先分配缓存区(同软件绘制)，然后将 Surface 绑定到 Render 线程，最后通过 GPU 渲染 DrawOp 数据。</li>
</ol>
<p>硬件加速的内存申请跟软件绘制一样都是借助 Layer 中的 BufferQueueProducer 生产者从 BufferQueue 中出队列一块空闲缓存区 GraphicBuffer 用来渲染数据的，之后也都会通知 SurfaceFlinger 进行合成。不一样的地方在于硬件加速相比软件绘制而言算法可能更加合理，同时采用了一个单独的 Render 线程，减轻了主线程的负担。</p>
<p><strong>双缓冲</strong></p>
<p>一般来说将双缓冲用到的两块缓冲区称为 – 前缓冲区(front buffer) 和 后缓冲区(back buffer)。显示器显示的数据来源于 front buffer 前缓存区，而每一帧的数据都绘制到 back buffer 后缓存区，在 Vsync 信号到来后会交互缓存区的数据(指针指向)，这时 front buffer 和 back buffer 的称呼及功能倒转。</p>
<p>在 View 的绘制过程中 Surface 使用了双缓冲技术。</p>
<p><strong>SurfaceView</strong></p>
<p>SurfaceView 就是一块拥有自己独立 Surface 的特殊 View 视图，由于这个特性，它一般用来实现比较复杂的图像或动画/视频的显示。</p>
<p>用一张图总结一下 Android 软硬件绘制的流程：</p>
<p><img src="Android-%E8%BD%AF%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.jpg" alt="Android-软硬件绘制流程"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/" rel="tag"># 图形系统</a>
              <a href="/tags/Surface/" rel="tag"># Surface</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/02/Android-SurfaceFlinger%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%BB%98%E5%9B%BE%E5%8E%9F%E7%90%86/" rel="prev" title="Android-SurfaceFlinger启动与绘图原理">
      <i class="fa fa-chevron-left"></i> Android-SurfaceFlinger启动与绘图原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/23/Android-requestLayout%E4%B8%8Einvalidate%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/" rel="next" title="Android-requestLayout与invalidate方法解析">
      Android-requestLayout与invalidate方法解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Surface%E5%88%9B%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">Surface创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WMS-addWindow"><span class="nav-number">2.1.</span> <span class="nav-text">WMS.addWindow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BASurface"><span class="nav-number">2.2.</span> <span class="nav-text">创建Surface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IGraphicBufferProducer"><span class="nav-number">2.3.</span> <span class="nav-text">IGraphicBufferProducer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F-amp-%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">硬件加速&amp;软件绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="nav-number">3.2.</span> <span class="nav-text">配置硬件加速</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">软件绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#VRImpl-drawSoftware"><span class="nav-number">4.1.</span> <span class="nav-text">VRImpl.drawSoftware</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface-lockCanvas"><span class="nav-number">4.2.</span> <span class="nav-text">Surface.lockCanvas</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View-draw"><span class="nav-number">4.3.</span> <span class="nav-text">View.draw</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface-unlockCanvasAndPost"><span class="nav-number">4.4.</span> <span class="nav-text">Surface.unlockCanvasAndPost</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">4.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">硬件绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadedRenderer-draw"><span class="nav-number">5.1.</span> <span class="nav-text">ThreadedRenderer.draw</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="nav-number">5.2.</span> <span class="nav-text">构建阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5"><span class="nav-number">5.3.</span> <span class="nav-text">渲染阶段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="nav-number">5.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2-View%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">双缓冲(View绘制过程)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6%E4%B8%AD%E7%9A%84%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="nav-number">6.1.</span> <span class="nav-text">软件绘制中的双缓冲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%98%E5%88%B6%E4%B8%AD%E7%9A%84%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="nav-number">6.2.</span> <span class="nav-text">硬件绘制中的双缓冲</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SurfaceView"><span class="nav-number">7.</span> <span class="nav-text">SurfaceView</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">7.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">7.3.</span> <span class="nav-text">源码解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
