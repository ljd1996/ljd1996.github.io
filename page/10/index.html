<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:type" content="website">
<meta property="og:title" content="苍耳的博客">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="诗歌，宋词，后台，Android，Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Java%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Java%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Java反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 15:42:50" itemprop="dateCreated datePublished" datetime="2019-10-21T15:42:50+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2019/10/21/Java%E5%8F%8D%E5%B0%84/" class="post-meta-item leancloud_visitors" data-flag-title="Java反射" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/21/Java%E5%8F%8D%E5%B0%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/Java%E5%8F%8D%E5%B0%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>反射机制就是允许编程人员在程序运行时来改变程序的结构或者变量的类型。通过这个特性，我们可以在运行时得知某个类的所有成员，包括其属性和方法，同时也能够调用这些方法。请注意反射机制的特殊之处就在于可以使用编译期间完全未知的类,也就是通过反射机制可以加载一个在运行时才得知名字的类，从而取得其内部的成员函数并调用。</p>
<ol>
<li><p>动态语言：</p>
<p> 一般认为在程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。尽管这样，JAVA有着一个非常突出的动态相关机制：反射（Reflection）。运用反射我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载在运行时才得知名称的class，获悉其完整构造方法，并生成其对象实体、或对其属性设值、或唤起其成员方法。</p>
</li>
<li><p>反射：</p>
<p> 要让Java程序能够运行，就得让Java类被Java虚拟机加载。Java类如果不被Java虚拟机加载就不能正常运行。正常情况下，我们运行的所有的程序在编译期时候就已经把那个类被加载了。Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载。使用的是在编译期并不知道的类。这样的编译特点就是java反射。</p>
</li>
<li><p>反射的作用:</p>
<p> 如果有AB两个程序员合作，A在写程序的时需要使用B所写的类，但B并没完成他所写的类。那么A的代码是不能通过编译的。此时，利用Java反射的机制，就可以让A在没有得到B所写的类的时候，来使自身的代码通过编译。</p>
</li>
<li><p>反射的实质:</p>
<p> 反射就是把Java类中的各种存在给解析成相应的Java类。要正确使用Java反射机制就得使用Class（C大写） 这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个Class对象对应的方法、成员以及构造方法的声明和定义等信息。</p>
</li>
<li><p>反射机制的优点与缺点:</p>
<ul>
<li>静态编译：在编译时确定类型，绑定对象,即通过。</li>
<li>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，降低类之间的藕合性。</li>
</ul>
<p> 一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用安装，只需要在运行时才动态的创建和编译，就可以实现该功能。它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p>
</li>
</ol>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>在面向对象的世界里，万事万物皆对象。在java语言中，静态的成员，普通数据类型不是对象。</p>
<p>类是对象，类是java.lang.Class类的实例对象。这个对象的表示方式有三种：</p>
<ul>
<li><p>第一种表示方式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Foo.class;<span class="comment">//任何一个类都有一个隐含的静态成员变量class</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二种表示方式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = foo1.getClass();<span class="comment">//已知该类的对象，通过getClass方法得到这个实例类的class(类类型)</span></span><br></pre></td></tr></table></figure></li>
<li><p>第三种表达方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">&quot;imooc.reflect.Foo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  可以通过类类型创建该类的类对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Foo.class;<span class="comment">//c1就是类类型</span></span><br><span class="line">Foo foo=(Foo)c1.newInstance();<span class="comment">//需要有无参数的构造方法。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="静态动态加载类"><a href="#静态动态加载类" class="headerlink" title="静态动态加载类"></a>静态动态加载类</h1><p>编译时刻加载类是静态加载类，运行时刻是动态加载类。</p>
<p>new创建对象是静态加载类，在编译时刻就需要加载所有可能用到的类。如果创建了一个可以使用的C1对象和不可使用的C2对象，即使C1可用，由于C2不可以而编译不过使得C1不可用。用动态加载类可以解决该问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Word...start...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//动态加载类，在运行时加载</span></span><br><span class="line">        Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//通过类类型，创建该对象</span></span><br><span class="line">        OfficeAble oa = (OfficeAble) c.newInstance();</span><br><span class="line">        oa.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先获取类的类类型</span></span><br><span class="line">Class cl = object.getClass();</span><br><span class="line"><span class="comment">//获取类的名称/简称</span></span><br><span class="line">System.out.println(<span class="string">&quot;名称:&quot;</span> + cl.getName() + <span class="string">&quot; 简称:&quot;</span> + cl.getSimpleName());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method类，方法对象，一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">* getMethods获取的是所有public方法，包括从父类继承而来的</span></span><br><span class="line"><span class="comment">* getDeclaredMethods获取的是所有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Method[] methods = cl.getMethods();<span class="comment">//cl.getDeclaredMethods()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++)&#123;</span><br><span class="line">    <span class="comment">//得到方法的返回值类型的类类型</span></span><br><span class="line">    Class returnType = methods[i].getReturnType();</span><br><span class="line">    System.out.print(returnType.getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">//得到方法的名称</span></span><br><span class="line">    System.out.print(methods[i].getName() + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="comment">//获取参数列表的类型的类类型</span></span><br><span class="line">    Class[] params = methods[i].getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class c: params)&#123;</span><br><span class="line">        System.out.print(c.getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h1><p>在使用反射获取或者修改一个变量的值时，编译器不会进行自动装/拆箱。因此我们无法给一个 Integer 类型的变量赋整型值，必须给它赋一个 Integer 对象才可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getFields获取的是所有public属性，包括从父类继承而来的</span></span><br><span class="line"><span class="comment">* getDeclaredFields获取的是所有该类自己定义的属性，不问访问权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Field[] fields = cl.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++)&#123;</span><br><span class="line">    <span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">    Class fieldType = fields[i].getType();</span><br><span class="line">    System.out.println(fieldType.getName());</span><br><span class="line">    System.out.println(fields[i].getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 final 修饰的字段：</p>
<p><strong>构造方法赋值：</strong></p>
<ul>
<li>构造方法赋值在JVM编译期不会优化，运行时决定字段的值，修改后通过反射和其他方式访问到的都是新值。</li>
</ul>
<p><strong>直接赋值：</strong></p>
<ul>
<li>基本类型、String类型：JVM编译期会优化成常量，导致修改后的值通过反射可以访问到新值，其他方式访问到的仍是旧值。</li>
<li>对象类型：JVM编译期不会优化，运行时决定字段的值，修改后通过反射和其他方式访问到的都是新值。</li>
</ul>
<p><strong>间接赋值：</strong></p>
<ul>
<li>间接赋值在JVM编译期不会优化，运行时决定字段的值，修改后通过反射和其他方式访问到的都是新值。</li>
</ul>
<p><strong>小结</strong></p>
<p>如果final字段值是运行时赋值的，则修改后无论通过何种方式访问获得的都是新值；基本类型、String类型直接赋值时由于JVM编译优化，编译时期用到字段的地方会直接被字段值替换，导致通过反射修改字段值后用到字段的地方仍是原值，但通过反射访问获取到的是新值（给人的错觉是没修改成功）。</p>
<h1 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a>获取类的构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getConstructors获取的是所有public的构造函数，包括从父类继承而来的</span></span><br><span class="line"><span class="comment">* getDeclaredConstructors获取的是所有该类自己定义的构造函数，不问访问权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Constructor[] constructor = cl.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>

<h1 id="方法反射"><a href="#方法反射" class="headerlink" title="方法反射"></a>方法反射</h1><p>使用method.invok();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">Class c = a.getClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = c.getMethod(<span class="string">&quot;print&quot;</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//方法的反射操作是指用method对象进行操作</span></span><br><span class="line">    <span class="comment">//方法如果没有返回值则返回null， 有返回值则返回返回值</span></span><br><span class="line">    method.invoke(a, <span class="keyword">new</span> Object[]&#123;<span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"><span class="comment">//method.invoke(a, 20, 30);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="属性反射"><a href="#属性反射" class="headerlink" title="属性反射"></a>属性反射</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">    f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.set(object, args...);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h1><p>编译之后集合的泛型是去泛型化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">Class c1 = list.getClass();</span><br><span class="line">Class c2 = list1.getClass();</span><br><span class="line">System.out.println(c1 == c2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**反射都是编译之后的操作（字节码）</span></span><br><span class="line"><span class="comment">* 返回true说明编译之后集合的泛型是去泛型化的</span></span><br><span class="line"><span class="comment">* Java中集合的泛型，是防止错误输入的，只在编译阶段有效</span></span><br><span class="line"><span class="comment">* 验证：通过方法的反射来给list1加入int类型的数据，绕过编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = c2.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">    method.invoke(list1, <span class="number">20</span>);</span><br><span class="line">    method.invoke(list1, <span class="string">&quot;string&quot;</span>);</span><br><span class="line">    System.out.println(list1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>java7增加了对动态类型语言的支持，使java也可以像C语言那样将方法作为参数传递，其实现在lava.lang.invoke包中。MethodHandle作用类似于反射中的Method类，但它比Method类要更加灵活和轻量级。通过MethodHandle进行方法调用一般需要以下几步：</p>
<ol>
<li>创建MethodType对象，指定方法的签名；</li>
<li>在MethodHandles.Lookup中查找类型为MethodType的MethodHandle；</li>
<li>传入方法参数并调用MethodHandle.invoke或者MethodHandle.invokeExact方法。</li>
</ol>
<h2 id="MethodType"><a href="#MethodType" class="headerlink" title="MethodType"></a>MethodType</h2><p>创建方法：</p>
<p>1.通过MethodType.methodType及其重载方法，需要指定返回值类型以及0到多个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">methodType</span><span class="params">(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">methodType</span><span class="params">(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.MethodType.genericMethodType，需要指定参数的个数，类型都为Object：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">genericMethodType</span><span class="params">(<span class="keyword">int</span> objectArgCount, <span class="keyword">boolean</span> finalArray)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">genericMethodType</span><span class="params">(<span class="keyword">int</span> objectArgCount)</span></span></span><br></pre></td></tr></table></figure>

<p>3.fromMethodDescriptorString，通过方法描述来创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">fromMethodDescriptorString</span><span class="params">(String descriptor, ClassLoader loader)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="MethodHandles-Lookup"><a href="#MethodHandles-Lookup" class="headerlink" title="MethodHandles.Lookup"></a>MethodHandles.Lookup</h2><p>MethodHandles.Lookup相当于MethodHandle工厂类，通过findxxx方法可以得到相应的MethodHandle，还可以配合反射API创建MethodHandle，对应的方法有unreflect、unreflectSpecial等。</p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p>在得到MethodHandle后就可以进行方法调用了，有三种调用形式：</p>
<ol>
<li>invokeExact: 调用此方法与直接调用底层方法一样，需要做到参数类型精确匹配；</li>
<li>invoke: 参数类型松散匹配，通过asType自动适配；</li>
<li>invokeWithArguments: 直接通过方法参数来调用。其实现是先通过genericMethodType方法得到MethodType，再通过MethodHandle的asType转换后得到一个新的MethodHandle，最后通过新MethodHandle的invokeExact方法来完成调用。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;s = &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodHandle methodHandle = getMethodType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = (String) methodHandle.invokeExact(<span class="string">&quot;hearing&quot;</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// String s = (String) methodHandle.bindTo(...).invokeWithArguments(&quot;hearing-2&quot;);</span></span><br><span class="line">            String s = (String) methodHandle.invokeWithArguments(<span class="string">&quot;hearing-2&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getMethodType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodType methodType = MethodType.methodType(String.class, String.class);</span><br><span class="line">        MethodHandle methodHandle = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodHandle = MethodHandles.lookup().findStatic(Main.class, <span class="string">&quot;hello&quot;</span>, methodType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methodHandle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Java%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Java%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">Java并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 15:33:29" itemprop="dateCreated datePublished" datetime="2019-10-21T15:33:29+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2019/10/21/Java%E5%B9%B6%E5%8F%91/" class="post-meta-item leancloud_visitors" data-flag-title="Java并发" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/21/Java%E5%B9%B6%E5%8F%91/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/Java%E5%B9%B6%E5%8F%91/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ul>
<li>thread.join: 让调用线程等待自己结束后在执行。</li>
<li>Thread.yield: 礼让，自己先暂停，然后与其他线程共同竞争资源，静态方法(Thread.yield)。</li>
</ul>
<p><strong>线程中断机制</strong></p>
<p>线程中断是给目标线程发送一个中断信号，开发者可以监听线程的中断状态选择是否停止执行线程逻辑。对于阻塞线程的方法如 sleep, wait 等会在中断状态后抛出 InterruptedException 异常。</p>
<ul>
<li>thread.interrupt: 中断目标线程，给目标线程发一个中断信号，线程被打上中断标记。</li>
<li>Thread.interrupted: 判断目标线程是否被中断，会清除中断标记。</li>
<li>thread.isInterrupted: 判断目标线程是否被中断，不会清除中断标记。</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。CAS 即<code>我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可</code>。</p>
<p><strong>ABA问题</strong></p>
<p>出现原因：</p>
<ol>
<li>线程1读取出指定内存地址的数据A，加载到寄存器，此时读取出来的原值不仅将作为要被计算的值A，还会作为比较值A。</li>
<li>此时线程1的cpu被线程2抢占了，线程2也从同样的内存地址中读取了同样的数据A，线程2还比线程1先执行完，线程2产生了新数据B，并且遵守了CAS原理把新数据B存入该内存地址（这个时候内存的值由A被该为B）。</li>
<li>线程2执行完之后，线程1又没抢过其它线程，此时cpu被线程3抢占，之后步骤和第2步一样，线程3从同样的内存地址中读取了数据B，线程3比线程1先执行完，线程3产生了新数据A（不意味着此A就是彼A，已经被替换了），并且遵守了CAS原理把新数据A存入该内存地址（这个时候内存的值由B又变为A）。</li>
<li>此时线程1执行完了，要遵守CAS原理存入数据，然后比较值A是原来的A，而执行内存地址中的A是被替换过的了，但原A的值与内存中的A值是相等的，根据CAS，线程1会把新的执行结果存入该内存地址。</li>
</ol>
<p>解决办法：加版本号，多一步比较版本号。</p>
<h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>锁从宏观上分类，分为悲观锁与乐观锁，这是一种思想。Java中重量级锁是悲观锁的一种，自旋锁、轻量级锁与偏向锁属于乐观锁。</p>
<p><strong>乐观锁</strong></p>
<p>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。乐观锁直到修改完成准备提交所做的的修改时才会将数据锁住。完成更改后释放。</p>
<p>java中的乐观锁基本都是通过CAS操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p>
<p><strong>悲观锁</strong></p>
<p>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。Synchronized 是悲观锁，无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量，独占锁是一种悲观锁。</p>
<p><strong>可重入锁</strong></p>
<p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，当一个线程执行到某个synchronized方法时，在其内调用了另一个synchronized方法，此时线程不必重新去申请锁，而是可以直接执行方法该方法。</p>
<p><strong>可中断锁</strong></p>
<p>可以响应中断的锁。在Java中，synchronized不是可中断锁，而Lock是可中断锁。</p>
<p><strong>(非)公平锁</strong></p>
<p>公平锁即尽量以请求锁的顺序来获取锁。同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程会获得该锁，这种就是公平锁。</p>
<p>在Java中，synchronized是非公平锁，而 ReentrantLock 和 ReentrantReadWriteLock 默认情况下是非公平锁，但是可以设置为公平锁。</p>
<p><strong>共享锁和独占(排他)锁</strong></p>
<ul>
<li>共享锁：允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock的读锁。</li>
<li>独占锁：每次只能有一个线程能持有锁，它是悲观的加锁策略。ReentrantLock就是以独占方式实现的互斥锁。</li>
</ul>
<p><strong>读写锁</strong></p>
<p>读写锁将对一个资源的访问分成了一个读锁和一个写锁。它允许一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。如ReadWriteLock就是读写锁。</p>
<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><p>在 Java 对象的数据结构中有一部分称为 MarkWord, 在其内有锁状态相关的标志位。Java 锁的状态总共有四种，级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁，锁状态只能升级，不能降级。</p>
<p><strong>自旋</strong></p>
<p>自旋就是线程在不满足某种条件的情况下，一直循环做某个动作(空代码)。线程一旦进入阻塞(Block)，再被唤醒的代价比较高。所以常见的做法是先自旋一段时间，还没拿到锁就进入阻塞。</p>
<p>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p><strong>偏向锁</strong></p>
<p>初次执行到同步代码块的时候，锁对象变成偏向锁(通过CAS修改对象头里的锁标志位)，字面意思是 <code>偏向于第一个获得它的线程</code> 的锁。执行完同步代码块后，线程并不会主动释放偏向锁，当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己(持有锁的线程ID也在对象头里)，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p>
<p>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。偏向锁的撤销需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到无锁或轻量级锁的状态。</p>
<p>如果线程竞争激烈，那么应该禁用偏向锁。</p>
<p><strong>轻量级锁(自旋锁)</strong></p>
<p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程访问偏向锁的时候，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p>
<p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他等待的线程就只能在空耗CPU，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么就会一直用轻量级锁，允许短时间的忙等现象。这是一种折中的方法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。</p>
<p>轻量级锁的获取主要有两种情况：</p>
<ul>
<li>当关闭偏向锁功能时；</li>
<li>由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。</li>
</ul>
<p><strong>重量级锁</strong></p>
<p>轻量级锁的忙等是有限度的，如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p>
<p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。</p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p><strong>减小锁持有时间</strong></p>
<p>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p>
<p><strong>减小锁粒度</strong></p>
<p>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。</p>
<p>比如说 ConcurrentHashMap 的实现，它把整个 HashMap 拆成了若干个小的 segment, 当有线程操作里面的数据时实际上操作的是被拆分后的某个小的 segment, 从而使 ConcurrentHashMap 允许多个线程同时进入，因此增加了并行度，达到了锁优化的目的。</p>
<p><strong>增大锁粒度(锁粗化)</strong></p>
<p>通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽可能短，但在某些情况下需要增大锁粒度。比如说某个循环内的操作需要加锁，此时应该把锁放到循环外面，否则每次进出循环都需要获取与释放锁。</p>
<p><strong>使用CAS</strong></p>
<p>如果需要同步的操作执行速度非常快，并且线程竞争不激烈，这时候使用 CAS 效率会更高，因为线程阻塞唤醒会有比较大的性能消耗，此时使用 CAS 操作(原子类)会是非常高效的选择。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>参考 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2018/06/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">Java内存模型与线程</a>。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ul>
<li>可见性：线程可见性。</li>
<li>有序性：Java遵循as-if-serial语义，即单线程执行程序时，即使发生重排序，程序的执行结果不能被改变。而 volatile 会禁止指令重排序，因此可以避免其他线程访问到一个未初始化的对象(分配内存，初始化对象，引用赋值给变量)。</li>
<li>不能保证原子性。</li>
</ul>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>原子类的原理是 CAS 操作，在 Java 中有许多原子类: AtomicBoolean, AtomicInteger, AtomicIntegerArray, AtomicIntegerFieldUpdater, AtomicLong, AtomicLongArray, AtomicLongFieldUpdater, AtomicMarkableReference, AtomicReference, AtomicReferenceArray, AtomicReferenceFieldUpdater, AtomicStampedReference。</p>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>在 JDK 1.6 之前 synchronized 是一个重量级锁，效率比较低下，在JDK 1.6 后 Jvm 为了提高锁的获取与释放效率对 synchronized 进行了优化，引入了偏向锁和轻量级锁。synchronized 是可重入锁，这样可以避免死锁。</p>
<p>在 HotSpot JVM 实现中，锁有个专门的名字：对象监视器(Object Monitor)。synchronized 的同步在软件层面依赖于JVM，看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后，其字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Test</span></span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: monitorexit</span><br><span class="line">      <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_2</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      <span class="number">19</span>: monitorexit</span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br></pre></td></tr></table></figure>

<p>monitorenter: 每个对象都是一个监视器锁(monitor)，当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权：</p>
<ul>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li>
</ul>
<p>monitorexit: 执行monitorexit的线程必须是锁对象所对应的monitor对象的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p>
<p>可以看出synchronized的实现原理：synchronized的语义底层是通过一个monitor的对象来完成，其实 wait/notify 等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p>
<p>两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，这会导致在用户态和内核态之间来回切换，对性能有较大影响。</p>
<p>而对于 synchronized 方法，编译后会在方法上增加一个标识，当调用该方法时，如果检测到该标识的存在，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象，本质上与上面 synchronized 代码块是一样的。</p>
<h2 id="原子性，可见性，有序性"><a href="#原子性，可见性，有序性" class="headerlink" title="原子性，可见性，有序性"></a>原子性，可见性，有序性</h2><ul>
<li>原子性: synchronized 通过 monitorenter 和 monitorexit 指令来保证原子性。</li>
<li>可见性: synchronized 规定线程在加锁时清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。</li>
<li>有序性: synchronized 无法禁止指令重排序，所以不能保证有序性。不过还有一种说法是由于 synchronized 修饰的代码，同一时间只能被同一线程访问，那么也就是单线程执行的，从as-if-serial语义而言，即单线程执行程序时，即使发生重排序，程序的执行结果不能被改变，所以可以保证其有序性。</li>
</ul>
<h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h2><p>wait 和 notify 不在同一个线程中进行，且必须在 synchronized 语句中，JAVA 的 Object 类型都带有一个内存锁，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现 JAVA 中的同步、互斥操作。notify 调用后并不会马上释放对象锁，而是在相应的 synchronized 语句块执行结束，自动释放锁后，JVM会在 wait 的线程中选取一个线程，赋予其对象锁，唤醒线程，继续执行。</p>
<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><h2 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h2><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。</p>
<p><img src="AQS%E6%A1%86%E6%9E%B6.png" alt="AQS框架"></p>
<p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p>
<p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是虚拟双向队列(FIFO)实现的，将暂时获取不到锁的线程加入到队列中，队列头节点不与任何线程关联，它是一个虚节点。</p>
<p>线程两种锁的模式：</p>
<ul>
<li>SHARED: 表示线程以共享的模式等待锁</li>
<li>EXCLUSIVE: 表示线程正在以独占的方式等待锁</li>
</ul>
<p>节点中waitStatus参数有下面几个枚举值：</p>
<ul>
<li>0: 当一个Node被初始化的时候的默认值</li>
<li>CANCELLED =1: 表示线程获取锁的请求已经取消了</li>
<li>SIGNAL    =-1: 表示线程已经处于唤醒状态</li>
<li>CONDITION =-2: 表示节点在等待队列中，节点线程等待唤醒</li>
<li>PROPAGATE =-3: 当前线程处在SHARED情况下，该字段才会使用</li>
</ul>
<p>AQS使用一个Volatile的int类型的成员变量state来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）：</p>
<p><img src="AQS%E5%8A%A0%E9%94%81%E8%BF%87%E7%A8%8B.png" alt="AQS加锁过程"></p>
<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。接下来看看 AQS 中的重要方法。</p>
<h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 tryAcquire 方法尝试去获取锁，如果获取锁成功则直接返回，该方法需要在子类中实现。如果 tryAcquire 方法获取锁失败返回 false 后则会调用 addWaiter 方法通过当前线程和锁模式新建一个节点 newNode，并将其加入等待队列尾部。然后调用 acquireQueued 方法将 newNode 之前的处于 CANCELLED 状态的节点出队列。</p>
<h2 id="addWaiter：线程入队列"><a href="#addWaiter：线程入队列" class="headerlink" title="addWaiter：线程入队列"></a>addWaiter：线程入队列</h2><p>addWaiter 方法会通过当前线程和锁模式新建一个节点，并将其加入等待队列尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置关联模式为 独占 或 共享</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node oldTail = tail;</span><br><span class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 尾节点不为 null 说明已经初始化过了</span></span><br><span class="line">            U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">            <span class="comment">// 设置新节点为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                oldTail.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 初始化</span></span><br><span class="line">            initializeSyncQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 head and tail 节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h;</span><br><span class="line">    <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, HEAD, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">        tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意头节点是通过空构造函数初始化的，其 waitStatus 默认为 0, 不关联线程，是一个虚节点。</p>
<h2 id="acquireQueued：线程出队列"><a href="#acquireQueued：线程出队列" class="headerlink" title="acquireQueued：线程出队列"></a>acquireQueued：线程出队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记线程是否被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="comment">// 如果前驱节点是head节点，则其可以尝试获取锁，因为头节点是虚节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 获取成功，将当前节点设置为head节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否可以阻塞，若可以则阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 线程被中断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个原因可能导致走到第二个 if 语句：</p>
<ul>
<li>前驱节点为头节点且当前没有获取到锁（可能是锁被抢占了）</li>
<li>前驱节点不为头结点</li>
</ul>
<p>此时要判断当前线程是否要被阻塞，如需要则阻塞线程，防止无限循环（自旋）浪费资源。流程如下：</p>
<p><img src="acquireQueued%E6%B5%81%E7%A8%8B1.png" alt="acquireQueued流程1"></p>
<p>看一下 shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt 方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 获取前驱节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 说明前驱结点处于唤醒状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// waitStatus&gt;0是取消状态</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 将前驱节点的状态设置为SIGNAL</span></span><br><span class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起当前线程，返回线程中断状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程入队后能够挂起的前提是：其前驱节点的状态为SIGNAL，SIGNAL的含义是 <code>前驱节点获取锁并且出队后要将自己唤醒</code>，如果前驱结点的状态不是SIGNAL，那么自己就不能安心挂起，需要去找个安心的挂起点，下次被唤醒后再通过死循环重新尝试获取锁。流程如下：</p>
<p><img src="acquireQueued%E6%B5%81%E7%A8%8B2.png" alt="acquireQueued流程2"></p>
<h2 id="cancelAcquire：CANCELLED节点生成"><a href="#cancelAcquire：CANCELLED节点生成" class="headerlink" title="cancelAcquire：CANCELLED节点生成"></a>cancelAcquire：CANCELLED节点生成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 设置该节点不关联任何线程，即虚节点</span></span><br><span class="line">    <span class="comment">// 通过前驱节点，跳过取消状态的node</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    Node predNext = pred.next; <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED; <span class="comment">// 把当前node的状态设置为CANCELLED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，则将从后往前的第一个非取消状态的节点设置为尾节点，即移除自身</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 更新成功则将tail的后继节点设置为null</span></span><br><span class="line">        pred.compareAndSetNext(predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 如果当前节点不是head的后继节点</span></span><br><span class="line">        <span class="comment">// &amp;&amp; 1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">        <span class="comment">// &amp;&amp; 前节点的线程不为null</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head </span><br><span class="line">            &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp; pred.compareAndSetWaitStatus(ws, Node.SIGNAL)))</span><br><span class="line">            &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="comment">// 将当前node从链表中移除</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>) pred.compareAndSetNext(predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的流程如下：获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个不为CANCELLED的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。根据当前节点的位置，考虑以下三种情况：</p>
<ul>
<li>当前节点是尾节点：</li>
</ul>
<p><img src="cancelAcquire1.png" alt="cancelAcquire1"></p>
<ul>
<li>当前节点是Head的后继节点：</li>
</ul>
<p><img src="cancelAcquire2.png" alt="cancelAcquire2"></p>
<ul>
<li>当前节点不是Head的后继节点，也不是尾节点：</li>
</ul>
<p><img src="cancelAcquire3.png" alt="cancelAcquire3"></p>
<h2 id="release：释放锁"><a href="#release：释放锁" class="headerlink" title="release：释放锁"></a>release：释放锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 自定义tryRelease如果返回true，说明该锁没有被任何线程持有</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 头结点不为空并且头结点的waitStatus不是初始化节点情况，则唤醒其后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryRelease 需要在子类中重写，看一下 unparkSuccessor 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下个节点是null或者下个节点被cancelled则从后往前找第一个非Cancelled的节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</span><br><span class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以要从后往前找，是因为在 addWaiter 方法中节点入队并不是原子操作，如果在 <code>oldTail.next = node;</code> 执行前就调用 unparkSuccessor 方法，则无法从前往后找了。另外在产生 CANCELLED 状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p>
<h2 id="acquireInterruptibly"><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly"></a>acquireInterruptibly</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg)) doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 增加节点</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 类似 acquireQueued 方法处理流程</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程调用 parkAndCheckInterrupt 方法挂起后，下次被唤醒时，会返回是否中断的 bool 值，如果外部调用了 interrupt 方法，则返回 true，于是走抛出异常的逻辑，外部捕获后可以退出阻塞状态(如Lock.lockInterruptibly方法的使用)。</p>
<h2 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h2><p>hasQueuedPredecessors 是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双向链表中，第一个节点为虚节点，并不存储任何信息。真正第一个有数据的节点，是从第二个节点开始的。当<code>h != t</code>时：如果<code>(s = h.next) == null</code>，则表示等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail(参考新增节点的 addWaiter 方法流程，因为节点入队列并不是原子操作)，此时队列中有元素，需要返回True。如果<code>(s = h.next) != null</code>，说明此时队列中至少有一个有效节点。如果此时<code>s.thread == Thread.currentThread()</code>则说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><p>Lock 是一个接口，其实现有 ReentrantLock, ReadLock 和 WriteLock 等，看一下相关方法：</p>
<p><strong>lock()</strong></p>
<p>获取锁，如果锁已被其他线程获取，则进行等待。</p>
<p><strong>tryLock()</strong></p>
<p>尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p>
<p>它有一个重载方法可以指定等待时长，当拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p>
<p><strong>lockInterruptibly()</strong></p>
<p>当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就是说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
<p><strong>unlock()</strong></p>
<p>释放锁。</p>
<h2 id="AQS-1"><a href="#AQS-1" class="headerlink" title="AQS"></a>AQS</h2><p>Lock 是通过 AQS 实现锁功能的，其实现的方法如下：</p>
<ul>
<li><code>isHeldExclusively()</code>: 该线程是否正在独占资源，只有用到Condition才需要去实现它。</li>
<li><code>tryAcquire(int arg)</code>: 独占方式。arg为获取锁的次数，尝试获取资源。</li>
<li><code>tryRelease(int arg)</code>: 独占方式。arg为释放锁的次数，尝试释放资源。</li>
<li><code>tryAcquireShared(int arg)</code>: 共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><code>tryReleaseShared(int arg)</code>: 共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</li>
</ul>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，只需实现<code>tryAcquire-tryRelease</code>, <code>tryAcquireShared-tryReleaseShared</code>中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了<code>tryAcquire-tryRelease</code>。</p>
<p>以非公平锁为例看一下非公平锁与AQS之间方法的关联之处：</p>
<p><img src="AQS%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png" alt="AQS与非公平锁"></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性，但相较于 synchronized 提供了更高的处理锁的灵活性。看一下其 lock 和 unlock 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认是非公平锁</span></span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lock</strong></p>
<p>NonfairSync 和 FairSync 都继承自 Sync, 而 Sync 继承自 AbstractQueuedSynchronizer(AQS)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FairSync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 NonfairSync 来说首先通过 CAS 操作，判断 state 是否是 0(当前锁未被占用)，如果是 0 则把它置为 1，并且设置当前线程为该锁的独占线程，表示获取锁成功。当多个线程同时尝试占用同一个锁时，CAS操作只能保证一个线程操作成功，剩下的只能排队。</p>
<p><code>非公平</code>即体现在这里，如果占用锁的线程刚释放锁，state 置为 0，而排队等待锁的线程还未唤醒时，新来的线程就直接抢占了该锁，那么就“插队”了。</p>
<p><strong>非公平锁</strong></p>
<p>acquire 方法的实现在 AQS 中，在上面已经看过了，它会调用重写的 tryAcquire 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NonfairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// 没有线程占用锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 占用锁成功，设置独占线程为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 当前线程已经占用该锁，则将 state 更新为新的重入次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁会通过 CAS 操作判断当前有没有线程占用锁，没有则直接占用成功，并修改 state。否则判断当前占用锁的线程是不是本线程，若是则叠加 state 表示重入锁的次数并返回 true。否则返回 false 标识占用锁失败，进行 AQS 的下一步操作。</p>
<p><strong>公平锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FairSync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于非公平锁，它多调用了 hasQueuedPredecessors 方法来判断等待队列中是否存在有效节点，存在则说明已经有线程在等待获取锁了，公平起见，此时不能把锁给调用者。</p>
<p><strong>unlock</strong></p>
<p>unlock 调用的是 AQS.release 方法。若释放锁成功，则唤醒头结点的下个节点关联的线程。子类需实现 tryRelease 方法进行真正的释放工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="comment">// 当前线程不是独占线程则抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// state 为 0 则表示释放成功</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>State 字段在 ReentrantLock 中的变化过程：</p>
<ul>
<li>State 初始化的时候为 0，表示没有任何线程持有锁；</li>
<li>当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁则会多次+1，这里就是可重入的概念；</li>
<li>解锁时对这个字段-1，一直到 0 则锁释放成功。</li>
</ul>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock 是一个接口，有一个实现类是 ReentrantReadWriteLock:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 返回锁的可重入剩余次数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="comment">// 锁可重入剩余次数为0或不是同一个线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="comment">// 请求的重入次数超出剩余数</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 writerShouldBlock 方法是一个抽象方法，在公平锁中返回 hasQueuedPredecessors() 方法的返回值；在非公平锁中返回 false。</p>
<p>再看读锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 共享锁数量</span></span><br><span class="line">    <span class="comment">// readerShouldBlock 根据是否公平返回不一样</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="await-amp-signal"><a href="#await-amp-signal" class="headerlink" title="await&amp;signal"></a>await&amp;signal</h2><p>单个 Lock 可能与多个 Condition 对象关联。在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。<br>Condition 实例实质上被绑定到一个锁上，要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。</p>
<p>调用signal()方法后一定要释放当前占用的锁，这样被唤醒的线程才能有获得锁的机会，才能继续执行。</p>
<h2 id="与synchronized比较"><a href="#与synchronized比较" class="headerlink" title="与synchronized比较"></a>与synchronized比较</h2><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">synchronized</th>
<th align="center">Lock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存在层次</td>
<td align="center">Java的关键字，在jvm层面上实现</td>
<td align="center">一个接口</td>
</tr>
<tr>
<td align="center">锁的获取</td>
<td align="center">阻塞等待</td>
<td align="center">分情况而定，Lock有多个锁获取的方式，可以尝试获得锁，线程可以不用一直等待</td>
</tr>
<tr>
<td align="center">锁的释放</td>
<td align="center">1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁</td>
<td align="center">在finally中必须释放锁，不然容易造成线程死锁</td>
</tr>
<tr>
<td align="center">中断响应</td>
<td align="center">只能等待锁的释放，不能响应中断</td>
<td align="center">可以用interrupt来中断等待</td>
</tr>
<tr>
<td align="center">公平性</td>
<td align="center">非公平锁</td>
<td align="center">公平和非公平都可</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">竞争资源不激烈，两者的性能差不多</td>
<td align="center">竞争资源非常激烈时Lock的性能要远远优于synchronized</td>
</tr>
</tbody></table>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch的计数器只能使用一次，它一般用于某个线程等待若干个其他线程执行完任务之后，它才执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 start...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1 end...&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 start...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2 end...&quot;</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;Wait for...&quot;</span>);</span><br><span class="line">    latch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;Finish...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier 的字面意思是回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以使用reset方法重置。当调用await()方法之后，线程就处于barrier了。</p>
<p>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(count, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;All thread is finished...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; end...&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore翻译成字面意思为信号量，Semaphore可以控制同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; begin to acquire...&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">2000</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; begin to release...&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread &quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h1><h2 id="接口与参数"><a href="#接口与参数" class="headerlink" title="接口与参数"></a>接口与参数</h2><p>ThreadPoolExecutor-&gt;AbstractExecutorService-&gt;ExecutorService-&gt;Executor.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure>

<p>相关重要参数：</p>
<ul>
<li>corePoolSize：核心池的大小，在创建了线程池后默认情况下线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法；</li>
<li>maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程；</li>
<li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止；默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，除非设置了allowCoreThreadTimeOut(boolean)方法。</li>
<li>unit：参数keepAliveTime的时间单位；</li>
<li>workQueue：一个阻塞队列，用来存储等待执行的任务，如果队列满了则新建非核心线程执行任务；</li>
<li>RejectedExecutionHandler: 拒绝策略，是指将任务添加到线程池中时，线程池拒绝该任务所采取的相应策略。抛异常或丢弃任务等。</li>
</ul>
<p>阻塞队列可选值：</p>
<ul>
<li>ArrayBlockingQueue: 可以限定队列的长度；如果总线程数到了maximumPoolSize且队列满了则发生错误；</li>
<li>LinkedBlockingQueue: 队列长度没有限制，即所有超过核心线程数的任务都将被添加到队列中；</li>
<li>SynchronousQueue: SynchronousQueue是一个没有数据缓冲的BlockingQueue(队列只能存储一个元素)，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样，消费者移除数据操作必须等待生产者的插入。</li>
</ul>
<p>线程池工作流程如下：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="线程池工作流程"></p>
<p><strong>实现优先级</strong></p>
<p>可比较的 Runnable 加上优先级阻塞队列 PriorityBlockingQueue.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrioritizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Comparable</span>&lt;<span class="title">PrioritizedRunnable</span>&gt; </span>&#123;&#125;</span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(..., <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;(), ...);</span><br></pre></td></tr></table></figure>

<p><strong>submit&amp;execute</strong></p>
<ul>
<li>execute() 参数 Runnable ；submit() 参数 (Runnable) 或 (Runnable 和 结果 T) 或 (Callable)</li>
<li>execute() 没有返回值；而 submit() 有返回值</li>
<li>submit() 的返回值 Future 调用 get 方法时，可以捕获处理异常；execute()只有通过ThreadFactory主动设置线程的异常处理类才能感知到提交的线程中的异常信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 execute 方法可以给 newThread 中创建的 Thread 对象设置UncaughtExceptionHandler。而 submit 不能这样，因为它没有抛出异常而是把保存起来在 get 时候才处理。</p>
<h2 id="内置线程池"><a href="#内置线程池" class="headerlink" title="内置线程池"></a>内置线程池</h2><p><strong>SingleThreadExecutor</strong></p>
<p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FixedThreadPool</strong></p>
<p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CachedThreadPool</strong></p>
<p>SynchronousQueue是一个只有1个元素的队列，入队的任务需要一直等待直到队列中的元素被移出。核心线程数是0，意味着所有任务会先入队列；最大线程数是Integer.MAX_VALUE，可以认为线程数量是没有限制的。KeepAlive时间被设置成60秒，意味着在没有任务的时候线程等待60秒以后退出。CachedThreadPool适用于执行很多的短期异步任务的小程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ScheduledThreadPool</strong></p>
<p>创建一个定长线程池，支持定时及周期性任务执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">        DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">scheduledThreadPool.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<p>状态转换如下图：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png"></p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>首先看看 execute 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 创建并添加Worker，内部有Thread参数</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心线程满了则尝试往阻塞队列添加任务</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command); <span class="comment">// 线程池不在RUNNING状态则拒绝</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 当一个worker都没有则创建一个非核心线程</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则创建一个非核心线程，失败则走拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看看 Worker 的执行逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当存在firstTask或队列中有task则执行</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (XX x) &#123;</span><br><span class="line">                    <span class="comment">// rethrow</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程执行时，调用 runWorker 方法，这里面会调用 getTask 获取任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从任务队列里取任务, timeout 为 keepAliveTime。</span></span><br><span class="line">            <span class="comment">// 即线程空闲时间达到keepAliveTime则返回空任务，线程没任务执行就退出了</span></span><br><span class="line">            <span class="comment">// 而核心线程默认则不受该参数影响，没任务时会一直阻塞</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><ul>
<li><code>void shutdown()</code>: 线程池队列中的任务会执行，无法提交新的任务，该方法不会等待执行的任务执行完成，可以使用 awaitTermination 实现这个目的。</li>
<li><code>List&lt;Runnable&gt; shutdownNow()</code>: 试图关闭正在执行的任务(任务需要处理中断)，不会执行已经提交到队列但还没执行的任务，返回等待执行的任务列表，同时此方法不会等待那些正在执行的任务执行完，等待执行的任务会从线程池队列移除。</li>
</ul>
<p>关闭线程池主要利用的是线程的中断机制，看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">// 置为SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        advanceRunState(STOP);  <span class="comment">// 置为STOP</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下 interruptIdleWorkers 和 interruptWorkers 的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 尝试获取Worker中的锁，线程池的线程在执行task时也会获取这把锁</span></span><br><span class="line">            <span class="comment">// 因此如果任务正在执行，则会拿锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted(); <span class="comment">// 直接置为中断状态</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看 getTask 中对中断的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// SHUTDOWN后状态且(队列为空或处于STOP状态)则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Executors各个方法的弊端，因此可以直接使用 ThreadPoolExecutor 构造方法创建线程池：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>newCachedThreadPool 和 newScheduledThreadPool: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Java-Android-Collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Java-Android-Collection/" class="post-title-link" itemprop="url">Java-Android-Collection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 15:25:48" itemprop="dateCreated datePublished" datetime="2019-10-21T15:25:48+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2019/10/21/Java-Android-Collection/" class="post-meta-item leancloud_visitors" data-flag-title="Java-Android-Collection" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/21/Java-Android-Collection/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/Java-Android-Collection/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="继承图"><a href="#继承图" class="headerlink" title="继承图"></a>继承图</h1><p><img src="Collections.png" alt="Collections"></p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><table>
<thead>
<tr>
<th align="center">Map类型</th>
<th align="center">插入是否有序</th>
<th align="center">顺序特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HashMap</td>
<td align="center">无序</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">LinkedHashMap</td>
<td align="center">有序</td>
<td align="center">记录插入顺序</td>
</tr>
<tr>
<td align="center">TreeMap</td>
<td align="center">有序</td>
<td align="center">默认升序</td>
</tr>
</tbody></table>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><img src="Map%E7%BB%93%E6%9E%84.png" alt="Map结构"></p>
<ul>
<li>HashMap 是一个最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null。在JDK1.8中，链表⻓度⼤于8的时候，链表会转成红⿊树。</li>
<li>DEFAULT_INITIAL_CAPACITY: Table数组的初始化长度 = 16。</li>
<li>DEFAULT_LOAD_FACTOR: 负载因子默认值为 0.75。当 <code>元素的总个数&gt;当前数组的长度 * 负载因子</code> 时数组会扩容为原来的两倍。</li>
<li>TREEIFY_THRESHOLD: 链表树化阙值默认值为 8 。表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</li>
<li>UNTREEIFY_THRESHOLD: 红黑树链化阙值：默认值为 6 。表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</li>
<li>MIN_TREEIFY_CAPACITY: 64 最小树化阈值，当Table所有元素超过该值时才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</li>
<li>HashMap中存储的是泛型，因此不能是基础类型，可能会产生自动装箱的消耗，创建新的装箱对象。</li>
</ul>
<p><strong>为什么是2次幂的初始容量，为什么扩容也是2倍？</strong></p>
<p>因为计算下标时采用的是 (n - 1) &amp; hash 方式，位运算特别高效，按位与 <code>&amp;</code> 的计算方法是，只有当对应位置的数据都为1时，运算结果也为1，当 HashMap 的容量是 2 的 n 次幂时，(n-1) 的 2 进制也就是 <code>1111111***111</code> 这样形式的，这样与添加元素的 hash 值进行位运算时，能够充分的散列，使得添加的元素均匀分布在 HashMap 的每个位置上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！</p>
<p><strong>为什么使用链表+数组？⽤ LinkedList/ArrayList 代替数组结构可以吗？</strong></p>
<p>在对key值进行散列取到下标以后，放入到数组中时，难免出现两个key值不同，但是却放入到下标相同的格子中，此时我们就可以使用链表来对其进行链式的存放。数组的查找效率比 LinkedList 大，所以使用数组。另外 ArrayList 底层虽然也是数组，但它是 1.5 倍扩容机制。</p>
<p><strong>put方法</strong></p>
<ol>
<li>对 key 做 hash 运算，计算 index；</li>
<li>如果没碰撞直接放到数组⾥；如果碰撞了则以链表的形式存在数组后；</li>
<li>如果碰撞导致链表过⻓(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)；</li>
<li>如果节点已经存在就替换 old value(保证key的唯⼀性)；</li>
<li>如果达到了扩容条件则扩容。</li>
</ol>
<p><strong>resise方法</strong></p>
<p>HashMap 的扩容实现机制是将原 table 数组中所有的 Entry 取出来，重新对其 Hashcode 做 Hash 散列到扩容后新的 Table 中。</p>
<p><strong>get方法</strong></p>
<ol>
<li>对 key 做 hash 运算，计算 index；</li>
<li>如果与数组⾥的第⼀个节点直接命中，则直接返回；</li>
<li>如果有冲突，则去查找对应的 Entry；若为树则为 O(logn)；若为链表则为 O(n)。</li>
</ol>
<h2 id="ArrayMap"><a href="#ArrayMap" class="headerlink" title="ArrayMap"></a>ArrayMap</h2><p>ArrayMap是一个通用的key-value映射数据结构，它相比HashMap会占用更少的内存空间。</p>
<p><strong>数据结构</strong></p>
<p>在ArrayMap内部有两个比较重要的数组，一个是mHashes,另一个是mArray。</p>
<ul>
<li>mHashes用来存放key的hashcode值</li>
<li>mArray用来存储key与value的值，它是一个Object数组。依旧存在自动装箱的消耗。</li>
</ul>
<p>其中这两个数组的索引对应关系是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] mHashes;</span><br><span class="line">Object[] mArray;</span><br><span class="line"></span><br><span class="line">mHashes[index] = hash;</span><br><span class="line">mArray[index&lt;&lt;<span class="number">1</span>] = key;  <span class="comment">//等同于 mArray[index * 2] = key;</span></span><br><span class="line">mArray[(index&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>] = value; <span class="comment">//等同于 mArray[index * 2 + 1] = value;</span></span><br></pre></td></tr></table></figure>

<p>注：向左移一位的效率要比 乘以2倍 高一些。</p>
<p><strong>查找数据</strong></p>
<p>查找数据分成两步：</p>
<ul>
<li>根据key的hashcode找到在mHashes数组中的索引值</li>
<li>根据上一步的索引值去查找key所对应的value值</li>
</ul>
<p>mHashes是一个有序数组，查找元素的时候使用的是二分查找。</p>
<p><strong>插入数据</strong></p>
<ol>
<li>新数据位置确定<ul>
<li>根据key的hashcode在mHashes表中二分查找确定合适的位置。</li>
<li>如果新添加的数据的索引不是最后位置，在需要对这个索引之后的全部数据向后移动</li>
</ul>
</li>
<li>当key为null时，其实和其他正常的key差不多，只是对应的hashcode会默认成0来处理。</li>
<li>数组扩容问题<ul>
<li>首先数组的容量会扩充到BASE_SIZE</li>
<li>如果BASE_SIZE无法容纳，则扩大到2 * BASE_SIZE</li>
<li>如果2 * BASE_SIZE仍然无法容纳，则每次扩容为当前容量的1.5倍。</li>
</ul>
</li>
</ol>
<p><strong>删除数据</strong></p>
<ul>
<li>如果当前ArrayMap只有一项数据，则删除操作将mHashes，mArray置为空数组，mSize置为0.</li>
<li>如果当前ArrayMap容量过大（大于BASE_SIZE*2）并且持有的数据量过小（不足1/3）则降低ArrayMap容量，减少内存占用</li>
<li>如果不符合上面的情况，则从mHashes删除对应的值，将mArray中对应的索引置为null</li>
</ul>
<p><strong>ArrayMap的缓存优化</strong></p>
<p>在元素的新增和删除过程中，会频繁出现多个容量为BASE_SIZE和2 * BASE_SIZE的int数组和Object数组(put方法增加数据，扩大容量；remove方法删除数据，减小容量)。ArrayMap设计者为了避免创建不必要的对象，减少GC的压力，采用了类似对象池的优化设计。</p>
<h2 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mKeys;</span><br><span class="line"><span class="keyword">private</span> Object[] mValues;</span><br></pre></td></tr></table></figure>

<p>SparseArray 比 HashMap 更省内存，某些条件下性能更好，因为它避免了对key的自动装箱。ArrayMap 与 SparseArray 最大的一点不同就是 ArrayMap 的 key 可以为任意的类型，而 SparseAraay 的 key 只能是整型。它也对 key 使用二分法进行排序。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><ul>
<li>通过把整个Map分为N个Segment,可以提供相同的线程安全,但是效率提升N倍,默认提升16倍。(读操作不加锁,由于HashEntry的value变量是 volatile的,也能保证读取到最新的值。)</li>
<li>有些方法需要跨段,比如size()和containsValue(),它们可能需要锁定整个表而而不仅仅是某个段,这需要按顺序锁定所有段,操作完毕后,又按顺序释放所有段的锁</li>
<li>扩容:段内扩容(段内元素超过该段对应Entry数组长度的75%触发扩容,不会对整个Map进行扩容),插入前检测需不需要扩容,有效避免无效扩容</li>
</ul>
<h2 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h2><ul>
<li>它是一个有序的Map，相当于TreeMap。</li>
<li>TreeMap采用红黑树实现排序，而ConcurrentHashMap采用跳表实现有序。</li>
</ul>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>HashTable与 HashMap类似，它继承自Dictionary类，不同的是：</p>
<ul>
<li>它不允许记录的键或者值为空。</li>
<li>它支持线程的同步，实现线程安全的方式是在修改数据时锁住整个HashTable，因此也导致了 HashTable在写入时会比较慢。</li>
<li>初始size为11,扩容:newsize = olesize*2+1</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap 直接继承自 HashMap, 内部维护了一个 LinkedList 双向链表。LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录是先插入的，它还可以在此基础上再根据访问顺序(get,put)来排序，可以用来实现 Lru 算法。</p>
<p>在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和容量有关。</p>
<p><strong>初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder; <span class="comment">// 是否按照访问顺序排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LinkedHashMapEntry</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line">    LinkedHashMapEntry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 的 Entry 新增了 before 和 after 两个指针，before 在每次添加元素的时候将会指向上一次添加的元素，而上一次添加的元素的 after 指针将指向本次添加的元素，来形成双向链表。</p>
<p><strong>put元素</strong></p>
<p>LinkedHashMap 没有重写 put 方法，只是重写了 newNode 方法生成新的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMapEntry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMapEntry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 p 放到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMapEntry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>remove元素</strong></p>
<p>LinkedHashMap 没有重写 remove 方法，只是重写了 afterNodeRemoval 方法处理删除的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从双向链表中删除节点 e</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; p = (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) head = a; <span class="keyword">else</span> b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>) tail = b; <span class="keyword">else</span> a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>维护节点访问顺序</strong></p>
<p>accessOrder 参数默认为 false, 当设置为 true 时, LinkedHashMap 会维护节点访问顺序。在 putVal/get/repalce 方法最后都调用了 afterNodeAccess 方法，LinkedHashMap 重写了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将被访问节点移动到链表最后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代器</strong></p>
<p>LinkedHashMap 实现了自己的迭代器，其迭代是通过双向链表实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> LinkedHashMapEntry&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount) <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        current = e;</span><br><span class="line">        next = e.after;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其 containsValue 方法也是通过遍历双向链表实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (LinkedHashMapEntry&lt;K,V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</span><br><span class="line">        V v = e.value;</span><br><span class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul>
<li>TreeMap实现SortMap接口，内部是红黑树，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历TreeMap时，得到的记录是排过序的。</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul>
<li>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map中插入、删除和定位元素，HashMap 是最好的选择。 </li>
<li>TreeMap取出来的是排序后的键值对。但如果要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 </li>
<li>LinkedHashMap是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。</li>
<li>HashMap : 内存占用较大，增、删的效率较高，改、查的效率一般</li>
<li>ThreadLocal.Values :  内存占用一般，当数据量比较小时，增删改查的效率高；数据量大时，增删改查效率一般</li>
<li>ArrayMap: 内存占用较小，改、查的效率高，增、删的效率较低</li>
<li>SparseArray : 内存占用较小，改、查的效率高，增、删的效率低，且主键是数字</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul>
<li>有序，可重复。</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li>底层维护一个Object数组。</li>
<li>查询速度快，增删慢。</li>
<li>线程安全，操作效率低。</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>底层维护一个Object数组。</li>
<li>查询速度快，增删慢。</li>
<li>1.5 倍扩容。</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList是List接口的实现类，因此它可以是一个集合，可以根据索引来随机访问集合中的元素。此外，它还是Duque接口的实现类，因此也可以作为一个双端队列，或者栈来使用。</p>
<ul>
<li>LinkedList是一个双向链表.</li>
<li>查询速度慢，增删快</li>
</ul>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</p>
<p>CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、先加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//2、拷贝数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//3、将元素加入到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//4、将array引用指向到新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//5、解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于所有的写操作都是在新数组进行的，这个时候如果有线程并发的写，则通过锁来控制，如果有线程并发的读，则分几种情况：</p>
<ol>
<li>如果写操作未完成，那么直接读取原数组的数据； </li>
<li>如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；</li>
<li>如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据。</li>
</ol>
<p>可见，CopyOnWriteArrayList的读操作是可以不用加锁的。</p>
<p>CopyOnWriteArrayList表达的一些思想：</p>
<ol>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ol>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>继承自Vector.</p>
<ul>
<li>boolean empty():测试堆栈是否为空。</li>
<li>Object peek():查看堆栈顶部的对象，但不从堆栈中移除它。</li>
<li>Object pop():移除堆栈顶部的对象，并作为此函数的值返回该对象。</li>
<li>Object push(Object element):把项压入堆栈顶部。</li>
<li>int search(Object element):返回对象在堆栈中的位置,从栈顶往下，以1为基数。</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul>
<li>无序，不可重复。</li>
</ul>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet 底层用的是 HashMap:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet导致的内存泄漏：把一个对象存储进hashSet集合后，修改这个对象中参与计算hash的变量的值，这时这个对象的hash值也会随之改变，那么这么对象不可以正常地被删除。</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>TreeSet采用的数据结构是红黑树，我们可以让它按指定规则对其中的元素进行排序。它又是如何判断两个元素是否相同呢？除了用equals方法检查两个元素是否相同外，还要检查compareTo方法是否返回为0。所以如果对象要存放到Tree集合里，需要在重写compareTo时，把相同的对象的比较值定为0，防止相同的元素被重复添加进集合中。</p>
<h2 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h2><ul>
<li>它是一个有序的、线程安全的Set，相当于线程安全的TreeSet。</li>
<li>它内部拥有ConcurrentSkipListMap实例，本质上就是一个ConcurrentSkipListMap，只不过仅使用了Map中的key。</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ul>
<li><p>void add(Object e):将指定元素插入到队列的尾部。</p>
</li>
<li><p>Object remove():获取队列头部的元素，并删除该元素。</p>
</li>
<li><p>object element():获取队列头部的元素，但是不删除该元素。</p>
</li>
<li><p>boolean offer(Object e):将指定的元素插入此队列的尾部。当使用容量有限的队列时，此方法通常比add(Object e)有效。　</p>
</li>
<li><p>Object poll():返回队列头部的元素，并删除该元素。如果队列为空，则返回null。</p>
</li>
<li><p>Object peek():返回队列头部的元素，但是不删除该元素。如果队列为空，则返回null。</p>
</li>
</ul>
<h2 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;T&gt; queue = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>PriorityQueue 默认是小根堆，容量没有界限，会在指定的初始容量基础上扩容，默认排序是自然排序，队头元素是最小元素。可以这样实现大根堆：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> queue = PriorityQueue&lt;<span class="built_in">Int</span>&gt;(<span class="number">10</span>) &#123; o1, o2 -&gt; o2.compareTo(o1) &#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.9</span>) &#123;</span><br><span class="line">    queue.add(Random.nextInt(<span class="number">50</span>))</span><br><span class="line">&#125;</span><br><span class="line">println(queue)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.9</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;queue.remove()&#125;</span> - <span class="variable">$queue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">47</span>, <span class="number">41</span>, <span class="number">28</span>, <span class="number">38</span>, <span class="number">25</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">21</span>]</span><br><span class="line"><span class="number">47</span> - [<span class="number">41</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">21</span>]</span><br><span class="line"><span class="number">41</span> - [<span class="number">38</span>, <span class="number">25</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">38</span> - [<span class="number">28</span>, <span class="number">25</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">28</span> - [<span class="number">25</span>, <span class="number">23</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">25</span> - [<span class="number">23</span>, <span class="number">21</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">23</span> - [<span class="number">21</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">21</span> - [<span class="number">19</span>, <span class="number">11</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">19</span> - [<span class="number">11</span>, <span class="number">11</span>]</span><br><span class="line"><span class="number">11</span> - [<span class="number">11</span>]</span><br><span class="line"><span class="number">11</span> - []</span><br></pre></td></tr></table></figure>

<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deque接口是Queue接口的子接口，它代表一个双端队列，Deque定义了一些方法：</p>
<ul>
<li>void addFirst(Object e): 　　将指定元素添加到双端队列的头部。</li>
<li>void addLast(Object e):　　将指定元素添加到双端队列的尾部。</li>
<li>Iteratord descendingItrator():　　返回该双端队列对应的迭代器，该迭代器以逆向顺序来迭代队列中的元素。</li>
<li>Object getFirst():　　获取但不删除双端队列的第一个元素。</li>
<li>Object getLast():　　获取但不删除双端队列的最后一个元素。</li>
<li>boolean offFirst(Object e):　　将指定元素添加到双端队列的头部。</li>
<li>boolean offLast(OBject e):　　将指定元素添加到双端队列的尾部。</li>
<li>Object peekFirst():　　获取但不删除双端队列的第一个元素；如果双端队列为空，则返回null。</li>
<li>Object PeekLast():　　获取但不删除双端队列的最后一个元素；如果双端队列为空，则返回null。</li>
<li>Object pollFirst():　　获取并删除双端队列的第一个元素；如果双端队列为空，则返回null。</li>
<li>Object pollLast():　　获取并删除双端队列的最后一个元素；如果双端队列为空，则返回null。</li>
<li>Object pop()(栈方法):　　pop出该双端队列所表示的栈的栈顶元素。相当于removeFirst()。</li>
<li>void push(Object e)(栈方法)：　　将一个元素push进该双端队列所表示的栈的栈顶。相当于addFirst()。</li>
<li>Object removeFirst():　　获取并删除该双端队列的第一个元素。</li>
<li>Object removeFirstOccurence(Object o):　　删除该双端队列的第一次出现的元素o。</li>
<li>Object removeLast():　　获取并删除该双端队列的最后一个元素o。</li>
<li>Object removeLastOccurence(Object o):　　删除该双端队列的最后一次出现的元素o。</li>
</ul>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">可能报异常</th>
<th align="center">返回布尔值</th>
<th align="center">可能阻塞</th>
<th align="center">设定等待时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">入队</td>
<td align="center">add(e)</td>
<td align="center">offer(e)</td>
<td align="center">put(e)</td>
<td align="center">offer(e, timeout, unit)</td>
</tr>
<tr>
<td align="center">出队</td>
<td align="center">remove()</td>
<td align="center">poll()</td>
<td align="center">take()</td>
<td align="center">poll(timeout, unit)</td>
</tr>
<tr>
<td align="center">查看</td>
<td align="center">element()</td>
<td align="center">peek()</td>
<td align="center">无</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><p>此队列创建时必须指定大小.</p>
<p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p>
<p>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 </p>
<p>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</p>
<p>而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p>
<p>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>SynchronousQueue是一个没有数据缓冲的BlockingQueue(队列只能存储一个元素)，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样，消费者移除数据操作必须等待生产者的插入。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 是非阻塞队列,它是一个基于链接节点的、无界的、线程安全。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部是队列中时间最长的元素。队列的尾部是队列中时间最短的元素。新的元素插入到队列的尾部，队列检索操作从队列头部获得元素。当许多线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许 null 元素。</p>
<p>使用非阻塞队列，虽然能即时返回结果（消费结果），但必须自行编码解决返回为空的情况处理（以及消费重试等问题）。</p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p>包括:CopyOnWriteArrayList和CopyOnWriteArraySet。</p>
<ul>
<li>适用于读操作远远多于写操作，并且数据量较小的情况。</li>
<li>修改容器的代价是昂贵的，因此建议批量增加addAll、批量删除removeAll。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Java%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Java%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">Java注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 15:20:52" itemprop="dateCreated datePublished" datetime="2019-10-21T15:20:52+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2019/10/21/Java%E6%B3%A8%E8%A7%A3/" class="post-meta-item leancloud_visitors" data-flag-title="Java注解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/21/Java%E6%B3%A8%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/Java%E6%B3%A8%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>运行时注解：通过反射在运行时动态处理注解的逻辑</li>
<li>编译时注解：通过注解处理器在编译期动态处理相关逻辑</li>
</ul>
<p>使用代码自动生成，一是为了提高编码的效率，二是避免在运行期大量使用反射，通过在编译期利用反射生成辅助类和方法以供运行时使用。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/10/21/Java%E6%B3%A8%E8%A7%A3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/CMake%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/16/CMake%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">CMake笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 12:57:58" itemprop="dateCreated datePublished" datetime="2019-09-16T12:57:58+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          
            <span id="/2019/09/16/CMake%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="CMake笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/09/16/CMake%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/09/16/CMake%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="gcc，make，CMake"><a href="#gcc，make，CMake" class="headerlink" title="gcc，make，CMake"></a>gcc，make，CMake</h1><ol>
<li>gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。</li>
<li>程序只有一个源文件时，可以直接用gcc命令编译它。</li>
<li>当程序包含很多个源文件时，用gcc命令逐个去编译时，很容易混乱而且工作量大。</li>
<li>make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式：通过调用makefile文件中用户指定的命令来进行编译和链接的。</li>
<li>makefile就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。</li>
<li>makefile在一些简单的工程中可以人工编写，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。</li>
<li>cmake 是一个跨平台、开源的构建系统。它是一个集软件构建、测试、打包于一身的软件。它使用与平台和编译器独立的配置文件来对软件编译过程进行控制。cmake可以生成makefile文件，并且可以跨平台生成对应平台能用的makefile。</li>
<li>cmake根据CMakeLists.txt文件去生成makefile。</li>
</ol>
<h1 id="CMakeLists-txt语法"><a href="#CMakeLists-txt语法" class="headerlink" title="CMakeLists.txt语法"></a>CMakeLists.txt语法</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指定-cmake-的最小版本"><a href="#指定-cmake-的最小版本" class="headerlink" title="指定 cmake 的最小版本"></a>指定 cmake 的最小版本</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br></pre></td></tr></table></figure>

<p>这行命令是可选的，在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。</p>
<h3 id="设置项目名称"><a href="#设置项目名称" class="headerlink" title="设置项目名称"></a>设置项目名称</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project(demo)</span><br></pre></td></tr></table></figure>

<p>这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</p>
<h3 id="设置编译类型"><a href="#设置编译类型" class="headerlink" title="设置编译类型"></a>设置编译类型</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo demo.cpp) <span class="comment"># 生成可执行文件</span></span><br><span class="line">add_library(common STATIC util.cpp) <span class="comment"># 生成静态库</span></span><br><span class="line">add_library(common SHARED util.cpp) <span class="comment"># 生成动态库或共享库</span></span><br></pre></td></tr></table></figure>

<p>add_library 默认生成是静态库，通过以上命令生成文件名字，在 Linux 下是：</p>
<ul>
<li>demo</li>
<li>libcommon.a</li>
<li>libcommon.so</li>
</ul>
<p>在 Windows 下是：</p>
<ul>
<li>demo.exe</li>
<li>common.lib</li>
<li>common.dll</li>
</ul>
<h3 id="指定编译包含的源文件"><a href="#指定编译包含的源文件" class="headerlink" title="指定编译包含的源文件"></a>指定编译包含的源文件</h3><h4 id="明确指定包含哪些源文件"><a href="#明确指定包含哪些源文件" class="headerlink" title="明确指定包含哪些源文件"></a>明确指定包含哪些源文件</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(demo demo.cpp test.cpp util.cpp)</span><br></pre></td></tr></table></figure>

<h4 id="搜索所有的-cpp-文件"><a href="#搜索所有的-cpp-文件" class="headerlink" title="搜索所有的 cpp 文件"></a>搜索所有的 cpp 文件</h4><p>aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. SRC_LIST) <span class="comment"># 搜索当前目录下的所有.cpp文件</span></span><br><span class="line">add_library(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="自定义搜索规则"><a href="#自定义搜索规则" class="headerlink" title="自定义搜索规则"></a>自定义搜索规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB SRC_LIST <span class="string">&quot;*.cpp&quot;</span> <span class="string">&quot;protocol/*.cpp&quot;</span>)</span><br><span class="line">add_library(demo $&#123;SRC_LIST&#125;)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">file(GLOB SRC_LIST <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line">file(GLOB SRC_PROTOCOL_LIST <span class="string">&quot;protocol/*.cpp&quot;</span>)</span><br><span class="line">add_library(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">aux_source_directory(. SRC_LIST)</span><br><span class="line">aux_source_directory(protocol SRC_PROTOCOL_LIST)</span><br><span class="line">add_library(demo $&#123;SRC_LIST&#125; $&#123;SRC_PROTOCOL_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="查找指定的库文件"><a href="#查找指定的库文件" class="headerlink" title="查找指定的库文件"></a>查找指定的库文件</h3><p>find_library(VAR name path)查找到指定的预编译库，并将它的路径存储在变量中。默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find_library( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              log-lib</span><br><span class="line"> </span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              log )</span><br></pre></td></tr></table></figure>

<p>类似的命令还有 find_file()、find_path()、find_program()、find_package()。</p>
<h3 id="设置包含的目录"><a href="#设置包含的目录" class="headerlink" title="设置包含的目录"></a>设置包含的目录</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/<span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Linux 下还可以通过如下方式设置包含的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="设置链接库搜索目录"><a href="#设置链接库搜索目录" class="headerlink" title="设置链接库搜索目录"></a>设置链接库搜索目录</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">link_directories(</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>Linux 下还可以通过如下方式设置包含的目录</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="设置-target-需要链接的库"><a href="#设置-target-需要链接的库" class="headerlink" title="设置 target 需要链接的库"></a>设置 target 需要链接的库</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries( <span class="comment"># 目标库</span></span><br><span class="line">                       demo</span><br><span class="line"> </span><br><span class="line">                       <span class="comment"># 目标库需要链接的库</span></span><br><span class="line">                       <span class="comment"># log-lib 是上面 find_library 指定的变量名</span></span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure>

<p>在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</p>
<h4 id="指定链接动态库或静态库"><a href="#指定链接动态库或静态库" class="headerlink" title="指定链接动态库或静态库"></a>指定链接动态库或静态库</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(demo libface.a) <span class="comment"># 链接libface.a</span></span><br><span class="line">target_link_libraries(demo libface.so) <span class="comment"># 链接libface.so</span></span><br></pre></td></tr></table></figure>

<h4 id="指定全路径"><a href="#指定全路径" class="headerlink" title="指定全路径"></a>指定全路径</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.a)</span><br><span class="line">target_link_libraries(demo $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.so)</span><br></pre></td></tr></table></figure>

<h4 id="指定链接多个库"><a href="#指定链接多个库" class="headerlink" title="指定链接多个库"></a>指定链接多个库</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(demo</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs/libface.a</span><br><span class="line">    boost_system.a</span><br><span class="line">    boost_thread</span><br><span class="line">    pthread)</span><br></pre></td></tr></table></figure>

<h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><h4 id="set-直接设置变量的值"><a href="#set-直接设置变量的值" class="headerlink" title="set 直接设置变量的值"></a>set 直接设置变量的值</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(SRC_LIST main.cpp test.cpp)</span><br><span class="line">add_executable(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="set-追加设置变量的值"><a href="#set-追加设置变量的值" class="headerlink" title="set 追加设置变量的值"></a>set 追加设置变量的值</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(SRC_LIST main.cpp)</span><br><span class="line">set(SRC_LIST $&#123;SRC_LIST&#125; test.cpp)</span><br><span class="line">add_executable(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="list-追加或者删除变量的值"><a href="#list-追加或者删除变量的值" class="headerlink" title="list 追加或者删除变量的值"></a>list 追加或者删除变量的值</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set(SRC_LIST main.cpp)</span><br><span class="line">list(APPEND SRC_LIST test.cpp)</span><br><span class="line">list(REMOVE_ITEM SRC_LIST main.cpp)</span><br><span class="line">add_executable(demo $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><h4 id="if…elseif…else…endif"><a href="#if…elseif…else…endif" class="headerlink" title="if…elseif…else…endif"></a>if…elseif…else…endif</h4><p>逻辑判断和比较：</p>
<ul>
<li>if (expression)：expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真</li>
<li>if (not exp)：与上面相反</li>
<li>if (var1 AND var2)</li>
<li>if (var1 OR var2)</li>
<li>if (COMMAND cmd)：如果 cmd 确实是命令并可调用为真</li>
<li>if (EXISTS dir) if (EXISTS file)：如果目录或文件存在为真</li>
<li>if (file1 IS_NEWER_THAN file2)：当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径</li>
<li>if (IS_DIRECTORY dir)：当 dir 是目录时为真</li>
<li>if (DEFINED var)：如果变量被定义为真</li>
<li>if (var MATCHES regex)：给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 ${var}</li>
<li>if (string MATCHES regex)</li>
</ul>
<p>数字比较：</p>
<ul>
<li>if (variable LESS number)：LESS 小于</li>
<li>if (string LESS number)</li>
<li>if (variable GREATER number)：GREATER 大于</li>
<li>if (string GREATER number)</li>
<li>if (variable EQUAL number)：EQUAL 等于</li>
<li>if (string EQUAL number)</li>
</ul>
<p>字母表顺序比较：</p>
<ul>
<li>if (variable STRLESS string)</li>
<li>if (string STRLESS string)</li>
<li>if (variable STRGREATER string)</li>
<li>if (string STRGREATER string)</li>
<li>if (variable STREQUAL string)</li>
<li>if (string STREQUAL string)</li>
</ul>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if(MSVC)</span><br><span class="line">    set(LINK_LIBS common)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    set(boost_thread boost_log.a boost_system.a)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line">target_link_libraries(demo $&#123;LINK_LIBS&#125;)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">if(UNIX)</span><br><span class="line">    set(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -fpermissive -g&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    add_definitions(-D_SCL_SECURE_NO_WARNINGS</span><br><span class="line">    D_CRT_SECURE_NO_WARNINGS</span><br><span class="line">    -D_WIN32_WINNT=0x601</span><br><span class="line">    -D_WINSOCK_DEPRECATED_NO_WARNINGS)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"> </span><br><span class="line">if($&#123;CMAKE_BUILD_TYPE&#125; MATCHES <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h4 id="while…endwhile"><a href="#while…endwhile" class="headerlink" title="while…endwhile"></a>while…endwhile</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(condition)</span><br><span class="line">    ...</span><br><span class="line">endwhile()</span><br></pre></td></tr></table></figure>

<h4 id="foreach…endforeach"><a href="#foreach…endforeach" class="headerlink" title="foreach…endforeach"></a>foreach…endforeach</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(loop_var RANGE start stop [step])</span><br><span class="line">    ...</span><br><span class="line">endforeach(loop_var)</span><br></pre></td></tr></table></figure>

<p>start 表示起始数，stop 表示终止数，step 表示步长，示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foreach(i RANGE 1 9 2)</span><br><span class="line">    message($&#123;i&#125;)</span><br><span class="line">endforeach(i)</span><br><span class="line"><span class="comment"># 输出：13579</span></span><br></pre></td></tr></table></figure>

<h3 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message($&#123;PROJECT_SOURCE_DIR&#125;)</span><br><span class="line">message(<span class="string">&quot;build with debug mode&quot;</span>)</span><br><span class="line">message(WARNING <span class="string">&quot;this is warnning message&quot;</span>)</span><br><span class="line">message(FATAL_ERROR <span class="string">&quot;this build has many error&quot;</span>) <span class="comment"># FATAL_ERROR 会导致编译失败</span></span><br></pre></td></tr></table></figure>

<h3 id="包含其它-cmake-文件"><a href="#包含其它-cmake-文件" class="headerlink" title="包含其它 cmake 文件"></a>包含其它 cmake 文件</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(./common.cmake) <span class="comment"># 指定包含文件的全路径</span></span><br><span class="line"><span class="keyword">include</span>(def) <span class="comment"># 在搜索路径中搜索def.cmake文件</span></span><br><span class="line">set(CMAKE_MODULE_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/cmake) <span class="comment"># 设置include的搜索路径</span></span><br></pre></td></tr></table></figure>

<h2 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h2><h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><ul>
<li>PROJECT_SOURCE_DIR：工程的根目录</li>
<li>PROJECT_BINARY_DIR：运行 cmake 命令的目录，通常是 ${PROJECT_SOURCE_DIR}/build</li>
<li>PROJECT_NAME：返回通过 project 命令定义的项目名称</li>
<li>CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径</li>
<li>CMAKE_CURRENT_BINARY_DIR：target 编译目录</li>
<li>CMAKE_CURRENT_LIST_DIR：CMakeLists.txt 的完整路径</li>
<li>CMAKE_CURRENT_LIST_LINE：当前所在的行</li>
<li>CMAKE_MODULE_PATH：定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)，然后可以用INCLUDE命令来调用自己的模块</li>
<li>EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置</li>
<li>LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul>
<li>使用环境变量: <code>$ENV&#123;Name&#125;</code></li>
<li>写入环境变量: <code>set(ENV&#123;Name&#125; value)</code>(这里没有“$”符号)</li>
</ul>
<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul>
<li>CMAKE_MAJOR_VERSION：cmake 主版本号，比如 3.4.1 中的 3</li>
<li>CMAKE_MINOR_VERSION：cmake 次版本号，比如 3.4.1 中的 4</li>
<li>CMAKE_PATCH_VERSION：cmake 补丁等级，比如 3.4.1 中的 1</li>
<li>CMAKE_SYSTEM：系统名称，比如 Linux-­2.6.22</li>
<li>CMAKE_SYSTEM_NAME：不包含版本的系统名，比如 Linux</li>
<li>CMAKE_SYSTEM_VERSION：系统版本，比如 2.6.22</li>
<li>CMAKE_SYSTEM_PROCESSOR：处理器名称，比如 i686</li>
<li>UNIX：在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin</li>
<li>WIN32：在所有的 win32 平台下该值为 TRUE，包括 cygwin</li>
</ul>
<h3 id="主要开关选项"><a href="#主要开关选项" class="headerlink" title="主要开关选项"></a>主要开关选项</h3><ul>
<li>BUILD_SHARED_LIBS：这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库</li>
<li>CMAKE_C_FLAGS：设置 C 编译选项，也可以通过指令 add_definitions() 添加</li>
<li>CMAKE_CXX_FLAGS：设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</li>
<li>add_definitions(-DENABLE_DEBUG -DABC) 参数之间用空格分隔</li>
</ul>
<h2 id="项目示例"><a href="#项目示例" class="headerlink" title="项目示例"></a>项目示例</h2><h3 id="简单项目（单个源文件）"><a href="#简单项目（单个源文件）" class="headerlink" title="简单项目（单个源文件）"></a>简单项目（单个源文件）</h3><h4 id="新建cpp文件main-cpp"><a href="#新建cpp文件main-cpp" class="headerlink" title="新建cpp文件main.cpp"></a>新建cpp文件main.cpp</h4><h4 id="新建CMakeList-txt"><a href="#新建CMakeList-txt" class="headerlink" title="新建CMakeList.txt"></a>新建CMakeList.txt</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project(HELLO)</span><br><span class="line">add_executable(hello main.c)</span><br></pre></td></tr></table></figure>

<h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><p>一般采用 cmake 的 out-of-source 方式来构建（即生成的中间产物和源代码分离），这样做可以让生成的文件和源文件不会弄混，且目录结构看起来也会清晰明了。所以推荐使用这种方式，至于这个文件夹的命名并无限制，习惯命名为 build。在build目录下依次执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure>

<p>然后执行make命令即可生成可执行文件。</p>
<h3 id="复杂项目"><a href="#复杂项目" class="headerlink" title="复杂项目"></a>复杂项目</h3><p>目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">└── util</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── util.cpp</span><br><span class="line">    └── util.hpp</span><br></pre></td></tr></table></figure>

<p>demo 根目录下的 CMakeLists.txt 文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line">project(demo)</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 添加math子目录</span></span><br><span class="line">add_subdirectory(util)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line">add_executable(demo $&#123;DIR_SRCS&#125;)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line">target_link_libraries(demo Util)</span><br></pre></td></tr></table></figure>

<p>math 目录下的 CMakeLists.txt 文件如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line">add_library(Util $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">敏捷开发基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-12 11:36:40" itemprop="dateCreated datePublished" datetime="2019-09-12T11:36:40+08:00">2019-09-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:58" itemprop="dateModified" datetime="2021-05-14T14:14:58+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">其它</span></a>
                </span>
            </span>

          
            <span id="/2019/09/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" class="post-meta-item leancloud_visitors" data-flag-title="敏捷开发基础" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/09/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/09/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CI：持续集成（CONTINUOUS-INTEGRATION）"><a href="#CI：持续集成（CONTINUOUS-INTEGRATION）" class="headerlink" title="CI：持续集成（CONTINUOUS INTEGRATION）"></a>CI：持续集成（CONTINUOUS INTEGRATION）</h1><p>CI的全称是Continuous Integration，表示持续集成。</p>
<p>在CI环境中，开发人员将会频繁地向主干提交代码。这些新提交的代码在最终合并到主干前，需要经过编译和自动化测试流进行验证。持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并主线之后的质量问题，对可能出现的一些问题进行预警。</p>
<h1 id="CD：持续部署（CONTINUOUS-DEPLOYMENT）"><a href="#CD：持续部署（CONTINUOUS-DEPLOYMENT）" class="headerlink" title="CD：持续部署（CONTINUOUS DEPLOYMENT）"></a>CD：持续部署（CONTINUOUS DEPLOYMENT）</h1><p>CD的全称是Continuous Deployment，表示持续部署。</p>
<p>在CD环境中，通过自动化的构建、测试和部署循环来快速交付高质量的产品。某种程度上代表了一个开发团队工程化的程度，任何修改通过了所有已有的工作流就会直接和客户见面，只有当一个修改在工作流中构建失败才能阻止它部署到产品线。</p>
<p>持续部署是一个很优秀的方式，可以加速与客户的反馈循环，但是会给团队带来压力，因为不再有“发布日”了。开发人员可以专注于构建软件，他们看到他们的修改在他们完成工作后几分钟就上线了。</p>
<p>基本上，当开发人员在主分支中合并一个提交时，这个分支将被构建、测试，如果一切顺利，则部署到生产环境中。</p>
<h1 id="CD：持续交付（CONTINUOUS-DELIVERY）"><a href="#CD：持续交付（CONTINUOUS-DELIVERY）" class="headerlink" title="CD：持续交付（CONTINUOUS DELIVERY）"></a>CD：持续交付（CONTINUOUS DELIVERY）</h1><p>持续交付的英文全称是：Continuous delivery，缩写也是CD，它是一种软件工程手法。</p>
<p>它可以让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以释出的状况。它的目标在于让软件的建置、测试与释出变得更快以及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。</p>
<p>有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。</p>
<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps是Development和Operations的组合，是一种方法论，是一组过程、方法与系统的统称，用于促进应用开发、应用运维和质量保障（QA）部门之间的沟通、协作与整合。以期打破传统开发和运营之间的壁垒和鸿沟。</p>
<p>DevOps是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。具体来说，就是在软件交付和部署过程中提高沟通与协作的效率，旨在更快、更可靠的的发布更高质量的产品。</p>
<p>也就是说DevOps是一组过程和方法的统称，并不指代某一特定的软件工具或软件工具组合。各种工具软件或软件组合可以实现DevOps的概念方法。其本质是一整套的方法论，而不是指某种或某些工具集合，与软件开发中设计到的OOP、AOP、IOC（或DI）等类似，是一种理论或过程或方法的抽象或代称。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/11/Android%E7%BB%84%E4%BB%B6%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/11/Android%E7%BB%84%E4%BB%B6%E5%8C%96/" class="post-title-link" itemprop="url">Android组件化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-11 17:40:10" itemprop="dateCreated datePublished" datetime="2019-09-11T17:40:10+08:00">2019-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-16 16:25:33" itemprop="dateModified" datetime="2021-06-16T16:25:33+08:00">2021-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
            <span id="/2019/09/11/Android%E7%BB%84%E4%BB%B6%E5%8C%96/" class="post-meta-item leancloud_visitors" data-flag-title="Android组件化" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/09/11/Android%E7%BB%84%E4%BB%B6%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/09/11/Android%E7%BB%84%E4%BB%B6%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>模块</strong></p>
<p>模块指的是独立的业务模块，比如<code>直播模块</code>，<code>会员模块</code>等。</p>
<p><strong>组件</strong></p>
<p>组件指的是单一的功能组件，如<code>登录组件</code>、<code>上报组件</code>等，每个组件都可以以一个单独的module开发，并且可以单独抽出来作为SDK对外发布使用。</p>
<p><code>模块</code>和<code>组件</code>间最明显的区别就是模块相对与组件来说粒度更大，一个模块中可能包含多个组件。并且两种方式的本质思想是一样的，都是为了代码重用和业务解耦。在划分的时候，模块化是业务导向，组件化是功能导向。</p>
<p><img src="%E7%BB%84%E4%BB%B6%E5%8C%96.jpg" alt="组件化"></p>
<p>一个可用的组件化架构图从上向下分别为APP壳，业务层、组件层和基础层：</p>
<ul>
<li>基础层：基础层包含的是一些基础库以及对基础库的封装，比如常用的图片加载，网络请求，数据上报操作等等，其他模块或者组件甚至App应用都可以引用同一套基础库，因此这些基础库最好在另一个项目/git仓库中维护。在基础库上面可以再增加一个Common组件，它位于App应用所在的项目中，用来添加一些都需要引用到的依赖以及本App应用独有的共有方法，UI控件等。</li>
<li>组件层：基础层往上是组件层，组件层包含一些功能组件，比如分享，登录，下载，播放等等。</li>
<li>业务层：组件层往上是业务层，一个具体的业务模块会按需引用不同的组件，最终实现业务功能。</li>
<li>APP壳：在APP模块中根据需求统筹各个业务组件，最终输出为一个完整的应用。</li>
</ul>
<h1 id="组件单独调试"><a href="#组件单独调试" class="headerlink" title="组件单独调试"></a>组件单独调试</h1><p>Android Gradle提供了三种插件，在开发中可以通过配置不同的插件来配置不同的工程。</p>
<ul>
<li>App插件：com.android.application</li>
<li>Library插件：com.android.libraay</li>
<li>Test插件：com.android.test</li>
</ul>
<p>可以在gradle.properties配置文件中声明一个boolean变量：isAlone，在build.gradle中通过判断这个变量来动态加载不同的插件，ApplicationId以及AndroidManifest文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- main/manifest/AndroidManifest.xml 单独调试 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.hearing.share&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ShareActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- main/AndroidManifest.xml 集成调试 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.hearing.share&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ShareActivity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在组件的build.gradle中配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAlone.toBoolean()) &#123;</span><br><span class="line">            <span class="comment">// 单独调试时添加 applicationId ，集成调试时移除</span></span><br><span class="line">            applicationId <span class="string">&quot;com.hearing.login&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            <span class="comment">// 单独调试与集成调试时使用不同的 AndroidManifest.xml 文件</span></span><br><span class="line">            <span class="keyword">if</span> (isAlone.toBoolean()) &#123;</span><br><span class="line">                manifest.srcFile <span class="string">&#x27;src/main/manifest/AndroidManifest.xml&#x27;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                manifest.srcFile <span class="string">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外为了使组件化项目中的所有组件的compileSdkVersion、buildToolsVersion以及开源库版本等都能保持统一，也为了方便修改版本号，统一在Android工程根目录下的build.gradle中定义这些版本号，当然也可以在项目根目录添加一个单独的gradle文件定义这些常量，然后由根build.gradle引入。</p>
<h1 id="组件混淆方案"><a href="#组件混淆方案" class="headerlink" title="组件混淆方案"></a>组件混淆方案</h1><p>组件化项目的代码混淆方案采用在集成模式下集中在app壳工程中混淆，各个业务组件不配置混淆文件。</p>
<h1 id="组件Application"><a href="#组件Application" class="headerlink" title="组件Application"></a>组件Application</h1><p>组件化开发中每一个组件可能都会自定义一个Application类，当所有组件要打包合并在一起的时候，由于程序只能有一个Application，组件中自己定义的Application无法使用。因此需要想办法在任何一个业务组件中都能获取到一个可用的全局Context，而且这个Context不管是在组件开发模式还是在集成开发模式都是生效的。</p>
<p>在基础库组件中封装了项目中用到的各种Base类（BaseActivity，BaseFragment等），这些基类中有一个BaseApplication类，它主要作用是使各个业务组件和app壳工程中都能访问到全局Context，且在其中可以存储一些全局对象：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> BaseApplication &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mGlobalObjects = mutableMapOf&lt;Any, Any&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mApplication: Application? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mContext: Context? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">        mApplication = application</span><br><span class="line">        mContext = application.baseContext</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getContext</span><span class="params">()</span></span>: Context? &#123;</span><br><span class="line">        <span class="keyword">return</span> mContext ?: mApplication</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getApplication</span><span class="params">()</span></span>: Application? &#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">putGlobalObject</span><span class="params">(key: <span class="type">Any</span>, obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        mGlobalObjects[key] = obj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getGlobalObject</span><span class="params">(key: <span class="type">Any</span>)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> mGlobalObjects[key]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeGlobalObject</span><span class="params">(key: <span class="type">Any</span>)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> mGlobalObjects.remove(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以在本应用的Common组件中定义一个公用的Application基类，然后在各自组件中定义一个Application继承这个基类，这样就可以通过BaseApplication来获取全局的Context了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBaseApplication</span> : <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachBaseContext</span><span class="params">(base: <span class="type">Context</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base)</span><br><span class="line">        BaseApplication.<span class="keyword">init</span>(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外需要在项目从组件模式转换到集成模式后将组件的Application剔除出项目，可以在组件的Java文件夹下创建一个debug文件夹，用于存放不会在业务组件中引用的类，比如说Application类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAlone.toBoolean()) &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/module/AndroidManifest.xml&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class="line">            <span class="comment">// 集成开发模式下排除debug文件夹中的所有Java文件</span></span><br><span class="line">            java &#123;</span><br><span class="line">                exclude <span class="string">&#x27;debug/**&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组件间数据传递与方法调用"><a href="#组件间数据传递与方法调用" class="headerlink" title="组件间数据传递与方法调用"></a>组件间数据传递与方法调用</h1><p>接下来模拟一个组件间数据传递和方法调用的场景：分享组件分享时需要根据用户是否登录来判断分享的动作。</p>
<h2 id="base-component"><a href="#base-component" class="headerlink" title="base_component"></a>base_component</h2><p>base_component组件用来提供组件间数据传递和方法调用的功能。</p>
<p><strong>ILoginService</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILoginService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isLogin</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getUserId</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空实现：EmptyLoginService</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyLoginService</span> : <span class="type">ILoginService &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isLogin</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserId</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Service工厂：ServiceFactory</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ServiceFactory &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mServices = CopyOnWriteArrayList&lt;Any&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(service: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mServices.contains(service)) &#123;</span><br><span class="line">            mServices.add(service)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">getService</span><span class="params">(cls: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        mServices.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls.isInstance(it)) &#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getLoginService</span><span class="params">()</span></span>: ILoginService &#123;</span><br><span class="line">        <span class="keyword">val</span> service = getService(ILoginService::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">return</span> service <span class="keyword">as</span>? ILoginService ?: EmptyLoginService()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="component-login"><a href="#component-login" class="headerlink" title="component_login"></a>component_login</h2><p>登录组件中提供ILoginService的具体实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> : <span class="type">ILoginService &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isLogin</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUserId</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1024&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="component-share"><a href="#component-share" class="headerlink" title="component_share"></a>component_share</h2><p>分享组件中进行分享的逻辑判断：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ShareHelper &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">share</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> loginService = ServiceFactory.getLoginService()</span><br><span class="line">        <span class="keyword">if</span> (loginService.isLogin()) &#123;</span><br><span class="line">            Toast.makeText(</span><br><span class="line">                BaseApplication.getContext(),</span><br><span class="line">                <span class="string">&quot;Share from <span class="subst">$&#123;loginService.getUserId()&#125;</span>&quot;</span>, Toast.LENGTH_SHORT</span><br><span class="line">            ).show()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(</span><br><span class="line">                BaseApplication.getContext(),</span><br><span class="line">                <span class="string">&quot;Not login&quot;</span>, Toast.LENGTH_SHORT</span><br><span class="line">            ).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>在App主Module中进行ILoginService服务的注册：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> : <span class="type">MyBaseApplication</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        ServiceFactory.register(LoginService())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后根据业务逻辑调用分享组件的功能：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        findViewById&lt;TextView&gt;(R.id.text_view).setOnClickListener &#123;</span><br><span class="line">            ShareHelper.share()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组件间界面跳转"><a href="#组件间界面跳转" class="headerlink" title="组件间界面跳转"></a>组件间界面跳转</h1><p>可以使用开源框架：<a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter">ARouter</a>或者<a target="_blank" rel="noopener" href="https://github.com/luckybilly/CC">CC</a>等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上组件化的内容是在参考了网络上一些关于Android组件化的解析后，结合了自己的理解与思考得到的一些想法，在实际场景里可能会有问题，期待在以后的开发中有更多的实践与思考！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/10/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-title-link" itemprop="url">Android四大组件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-10 14:49:41" itemprop="dateCreated datePublished" datetime="2019-09-10T14:49:41+08:00">2019-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Framework/" itemprop="url" rel="index"><span itemprop="name">Framework</span></a>
                </span>
            </span>

          
            <span id="/2019/09/10/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Android四大组件" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/09/10/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/09/10/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="Activity生命周期.png"/>

<p>看一下以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序启动</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.687</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onCreate</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.819</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">34.823</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入SecondActivity</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.802</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.815</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onCreate</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">53.824</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onResume</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">05</span>:<span class="number">54.156</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.672</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onPause</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.716</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.717</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">04.718</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onStop</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">05.071</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: SecondActivity-onDestroy</span><br><span class="line"><span class="comment">// 按下home键</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.703</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.722</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">14.723</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 返回应用</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.968</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onRestart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">18.970</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 按下back键</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">20.822</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.274</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">21.275</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br><span class="line"><span class="comment">// 进入应用</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.925</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onCreate</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.959</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStart</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">39.963</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onResume</span><br><span class="line"><span class="comment">// 进入task</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.056</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onPause</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.068</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onStop</span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">47.088</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: onTrimMemory</span><br><span class="line"><span class="comment">// 后台终止</span></span><br><span class="line">09-<span class="number">25</span> <span class="number">22</span>:<span class="number">06</span>:<span class="number">51.310</span> <span class="number">13204</span>-<span class="number">13204</span>/com.hearing.demo D/LLL: MainActivity-onDestroy</span><br></pre></td></tr></table></figure>

<p>各个生命周期的作用：</p>
<ul>
<li>onCreate: Activity <code>已创建</code> 状态，在 Activity 的整个生命周期中只发生一次，用来进行 Activity 的一些初始化工作。</li>
<li>onStart: 为 Activity 可见做准备工作，此时还不在前台。</li>
<li>onResume: Activity 进入前台，对用户可见了。</li>
<li>onPause: 将要离开 Activity, 此时 Activity 依旧可见。可以做一些轻量级数据存储任务，因为在跳转 Activity 时只有当一个 Activity 执行完了 onPause 方法后另一个 Activity 才会启动。</li>
<li>onStop: 此时 Activity 已经不可见了，但是 Activity 对象还在内存中，在此可以做一些资源回收操作。</li>
<li>onDestroy: Activity 被销毁。</li>
</ul>
<p>关于 onRestoreInstanceState 和 onSaveInstanceState 方法：</p>
<ul>
<li>onSaveInstanceState 在 onStop 后被调用；</li>
<li>onRestoreInstanceState 在 onStart 后被调用；</li>
</ul>
<p>在 Activity 中有一个属性 — <code>View mDecor</code>, 在 PhoneWindow 中有一个属性 — <code>DecorView mDecor</code>，在 handleResumeActivity 方法中，会把 PhoneWindow 中的 mDecor 赋值给 Activity.mDecor。</p>
<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><p><strong>standard</strong></p>
<p>standard 是 Activity 默认的启动模式。在 standard 模式下，每启动一个 Activity 都会创建一个新的实例进入任务栈栈顶。</p>
<p><strong>singleTop</strong></p>
<p>singleTop 模式与 standard 类似，不同的是当启动的 Activity 已经位于栈顶时，则直接使用它不创建新的实例，此时栈顶的 Activity 实例会调 onNewIntent 方法。如果启动的 Activity 没有位于栈顶时，则创建一个新的实例位于栈顶。</p>
<p><strong>singleTask</strong></p>
<p>当 Activity 的启动模式指定为 singleTask，每次启动该 Activity 时，系统首先会检查栈中是否存在该 Activity 的实例，如果发现已经存在则直接使用该实例，此时栈顶的 Activity 实例会调 onNewIntent 方法，并将当前 Activity 之上的所有 Activity 出栈，如果没有发现则创建一个新的实例。</p>
<p><strong>singleInstance</strong></p>
<p>在程序开发过程中，如果需要 Activity 在整个系统中都只有一个实例，这时就需要用到 singleInstance 模式。指定为 singleInstance 模式的 Activity 会启动一个新的任务栈来管理这个 Activity。</p>
<p>singleInstance模式加载Activity时，无论从哪个任务栈中启动该Activity，只会创建一个Activity实例，并且会使用一个全新的任务栈来装载该Activity实例。采用这种模式启动Activity会分为一下两种情况：</p>
<ul>
<li>如果要启动的Activity不存在，系统会创建一个新的任务栈，在创建该Activity的实例，并把该Activity加入栈顶.</li>
<li>如果要启动的Activity已经存在，无论位于哪个应用程序或者哪个任务栈中，系统都会把该Activity所在的任务栈转到前台，从而使该Activity显示出来。</li>
</ul>
<h2 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。</p>
<h3 id="allowTaskReparenting"><a href="#allowTaskReparenting" class="headerlink" title="allowTaskReparenting"></a>allowTaskReparenting</h3><p>如果该Activity的allowTaskReparenting设置为true，它进入后台，当一个和它有相同affinity的Task进入前台时，它会重新宿主，进入到该前台的task中。</p>
<table>
<thead>
<tr>
<th align="center">Application</th>
<th align="center">Activity</th>
<th align="center">taskAffinity</th>
<th align="center">allowTaskReparenting</th>
</tr>
</thead>
<tbody><tr>
<td align="center">application1</td>
<td align="center">Activity1</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">application2</td>
<td align="center">Activity2</td>
<td align="center">com.winuxxan.affinity</td>
<td align="center">false</td>
</tr>
</tbody></table>
<p>创建两个工程：application1和application2，分别含有Activity1和Activity2，它们的taskAffinity相同，Activity1的allowTaskReparenting为true。</p>
<p>首先，我们启动application1,加载Activity1，然后按Home键，使该task（假设为task1）进入后台。然后启动application2，默认加载Activity2。本来应该是显示Activity2，但是我们却看到了Activity1。实际上Activity2也被加载了，只是Activity1重新宿主，所以看到了Activity1。</p>
<h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>如果加载某个Activity的intent，Flag被设置成FLAG_ACTIVITY_NEW_TASK时，它会首先检查是否存在与自己taskAffinity相同的Task，如果存在，那么它会直接宿主到该Task中，如果不存在则重新创建Task。</p>
<p>写一个应用，包含两个Activity：Activity1的taskAffinity为<code>com.hearing.task</code>，Activity2为入口，且点击Activity2会以FLAG_ACTIVITY_NEW_TASK启动Activity1。再写一个应用MyActivity，它包含一个Activity（MyActivity），其taskAffinity为<code>com.hearing.task</code>。</p>
<p>首先启动MyActivity，然后Home回桌面，然后打开Activity2，点击Activity2，进入Activity1。然后按返回键。进入Activity的顺序为Activity2-&gt;Activity1，而返回时顺序为Activity1-&gt;MyActivity。这就说明了一个问题，Activity1在启动时，重新宿主到了MyActivity所在的Task中去了。</p>
<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li>当一个应用程序加载一个singleTask模式的Activity时，首先该Activity会检查是否存在与它的taskAffinity相同的Task。如果存在，那么检查是否实例化，如果已经实例化，那么销毁在该Activity以上的Activity并调用onNewIntent。如果没有实例化，那么该Activity实例化并入栈。如果不存在，那么就重新创建Task，并入栈。</li>
<li>当一个应用程序加载一个singleInstance模式的Activity时，如果该Activity没有被实例化，那么就重新创建一个Task，并入栈，如果已经被实例化，那么就调用该Activity的onNewIntent.singleInstance的Activity所在的Task不允许存在其他Activity，任何从该Activity加载的其它Activity（假设为Activity2）都会被放入其它的Task中，如果存在与Activity2相同affinity的Task，则在该Task内创建Activity2。如果不存在，则重新生成新的Task并入栈。</li>
</ul>
<h2 id="启动方式的问题"><a href="#启动方式的问题" class="headerlink" title="启动方式的问题"></a>启动方式的问题</h2><p>MainActivity是SingleTask或者SingleInstance模式，启动TestActivity，TestActivity马上跳转到MainActivity，这种情况下，MainActivity的onResume会回调两次。日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onCreate</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onStart</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">TestActivity onCreate</span><br><span class="line">TestActivity onStart</span><br><span class="line">TestActivity onResume</span><br><span class="line">TestActivity onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onNewIntent</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onPause</span><br><span class="line">com.hearing.activitytest.MainActivity@2c5d2eb onResume</span><br><span class="line">TestActivity onStop</span><br></pre></td></tr></table></figure>

<p>适当延时500ms再跳转回MainActivity可以解决这个问题（可能由于业务场景不同，会带来新的问题）。</p>
<p>在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11092101/startactivity-on-foreground-application-causes-onpause-onresume">stackoverflow</a>上也有人发现过类似的问题。</p>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>普通广播（Normal Broadcast）</li>
<li>系统广播（System Broadcast）</li>
<li>有序广播（Ordered Broadcast）</li>
<li>粘性广播（Sticky Broadcast）（已弃用）</li>
<li>App应用内广播（Local Broadcast）</li>
</ul>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="BroadcastReceiver-1"><a href="#BroadcastReceiver-1" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul>
<li>继承BroadcastReceivre基类</li>
<li>复写抽象方法onReceive()方法</li>
</ul>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><ul>
<li>常驻：不受任何组件声明周期影响</li>
<li>耗电，占内存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    //此<span class="attr">broadcastReceiver</span>能否接收其他<span class="attr">App</span>的发出的广播</span></span><br><span class="line"><span class="tag">    //默认值是由<span class="attr">receiver</span>中有无<span class="attr">intent-filter</span>决定的：如果有<span class="attr">intent-filter</span>，默认值为<span class="attr">true</span>，否则为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">[</span>&quot;<span class="attr">true</span>&quot; | &quot;<span class="attr">false</span>&quot;]</span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;drawable resource&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;string resource&quot;</span></span></span><br><span class="line"><span class="tag">    //继承<span class="attr">BroadcastReceiver</span>子类的类名</span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.mBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    //具有相应权限的广播发送者发送的广播才能被此<span class="attr">BroadcastReceiver</span>所接收；</span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">BroadcastReceiver</span>运行所处的进程</span></span><br><span class="line"><span class="tag">    //默认为<span class="attr">app</span>的进程，可以指定独立的进程</span></span><br><span class="line"><span class="tag">    //注：<span class="attr">Android</span>四大基本组件都可以通过此属性指定自己的独立进程</span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;string&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    //用于指定此广播接收器将接收的广播类型</span><br><span class="line">    //本示例中给出的是用于接收网络状态改变时发出的广播</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><ul>
<li>非常驻，灵活</li>
<li>手动释放</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    mBroadcastReceiver mBroadcastReceiver = <span class="keyword">new</span> mBroadcastReceiver();</span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);</span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>生命周期:</p>
<ol>
<li><p>startService()</p>
<ul>
<li>作用：启动Service服务</li>
<li>手动调用startService()后，自动调用内部方法：onCreate()、onStartCommand() </li>
<li>如果一个service被startService多次启动，onCreate()只会调用一次 </li>
<li>onStartCommand()调用次数=startService()次数</li>
</ul>
</li>
<li><p>stopService()</p>
<ul>
<li>作用：关闭Service服务 </li>
<li>手动调用stopService()后，自动调用内部方法：onDestory() </li>
<li>如果一个service被启动且被绑定，如果没有在绑定的前提下stopService()是无法停止服务的。</li>
</ul>
</li>
<li><p>bindService()</p>
<ul>
<li>作用：绑定Service服务 </li>
<li>手动调用bindService()后，自动调用内部方法：onCreate()、onBind()</li>
</ul>
</li>
<li><p>unbindService()</p>
<ul>
<li>作用：解绑Service服务 </li>
<li>手动调用unbindService()后，自动调用内部方法：onCreate()、onBind()、onDestory()</li>
</ul>
</li>
</ol>
<p>接口函数：</p>
<ul>
<li>onStartCommand()：当其他组件调用startService()方法请求启动Service时，该方法被回调。一旦Service启动，它会在后台独立运行。当Service执行完以后，需调用stopSelf() 或 stopService()方法停止Service。（若您只希望bind Service，则无需调用这些方法）</li>
<li>onBind()：当其他组件调用bindService()方法请求绑定Service时，该方法被回调。该方法返回一个IBinder接口，该接口是Service与绑定的组件进行交互的桥梁。若Service未绑定其他组件，该方法应返回null。</li>
<li>onCreate()：当Service第一次创建时，回调该方法。该方法只被回调一次，并在onStartCommand() 或 onBind()方法被回调之前执行。若Service处于运行状态，该方法不会回调。</li>
<li>onDestroy()：当Service被销毁时回调，在该方法中应清除一些占用的资源，如停止线程、接触绑定注册的监听器或broadcast receiver 等。该方法是Service中的最后一个回调。</li>
</ul>
<p>启动方式：</p>
<ul>
<li>Started：其他组件调用startService()方法启动一个Service。一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。通常，一个被start的Service会在后台执行单独的操作，也并不给启动它的组件返回结果。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</li>
<li>Bound：其他组件调用bindService()方法绑定一个Service。通过绑定方式启动的Service是一个client-server结构，该Service可以与绑定它的组件进行交互。一个bound service仅在有组件与其绑定时才会运行（A bound service runs only as long as another application component is bound to it），多个组件可与一个service绑定，service不再与任何组件绑定时，该service会被destroy。</li>
</ul>
<p>注意：</p>
<ul>
<li>Service运行在主线程中（A service runs in the main thread of its hosting process），Service并不是一个新的线程，也不是新的进程。也就是说，若您需要在Service中执行较为耗时的操作（如播放音乐、执行网络请求等），需要在Service中创建一个新的线程。这可以防止ANR的发生，同时主线程可以执行正常的UI操作。</li>
<li>如果某个组件通过调用startService()启动了Service（系统会回调onStartCommand()方法），那么直到在Service中手动调用stopSelf()方法、或在其他组件中手动调用stopService()方法，该Service才会停止。</li>
<li>如果某个组件通过调用bindService()绑定了Service（系统不会回调onStartCommand()方法），只要该组件与Service处于绑定状态，Service就会一直运行，当Service不再与组件绑定时，该Service将被destroy。</li>
<li>当系统内存低时，系统将强制停止Service的运行；若Service绑定了正在与用户交互的activity，那么该Service将不大可能被系统kill（ less likely to be killed）。如果创建的是前台Service，那么该Service几乎不会被kill（almost never be killed）。否则，当创建了一个长时间在后台运行的Service后，系统会降低该Service在后台任务栈中的级别——这意味着它容易被kill（lower its position in the list of background tasks over time and the service will become highly susceptible to killing），所以在开发Service时，需要使Service变得容易被restart，因为一旦Service被kill，再restart它需要其资源可用时才行</li>
</ul>
<h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.servicetest.MyService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="继承IntentService类"><a href="#继承IntentService类" class="headerlink" title="继承IntentService类"></a>继承IntentService类</h2><ul>
<li>默认在子线程中处理回传到onStartCommand()方法中的Intent；</li>
<li>在重写的onHandleIntent()方法中处理按时间排序的Intent队列，所以不用担心多线程带来的问题。</li>
<li>当所有请求处理完成后，自动停止service，无需手动调用stopSelf()方法；</li>
<li>默认实现了onBind()方法，并返回null；</li>
<li>默认实现了onStartCommand()方法，并将回传的Intent以序列的形式发送给onHandleIntent()，只需重写该方法并处理Intent即可。</li>
</ul>
<p>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">IntentService</span></span>(<span class="string">&quot;MyService&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LLL&quot;</span>, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LLL&quot;</span>, <span class="string">&quot;onStartCommand: <span class="variable">$startId</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LLL&quot;</span>, <span class="string">&quot;onDestroy&quot;</span>)</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHandleIntent</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;LLL&quot;</span>, <span class="string">&quot;Current thread: <span class="subst">$&#123;Thread.currentThread().name&#125;</span>&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;LLL&quot;</span>, <span class="string">&quot;Intent: <span class="subst">$&#123;intent?.getStringExtra(<span class="string">&quot;name&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MyService::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hearing-1&quot;</span>)</span><br><span class="line">startService(intent)</span><br><span class="line">Thread.sleep(<span class="number">20</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hearing-2&quot;</span>)</span><br><span class="line">startService(intent)</span><br><span class="line">Thread.sleep(<span class="number">20</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hearing-3&quot;</span>)</span><br><span class="line">startService(intent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志</span></span><br><span class="line">D/LLL: onCreate</span><br><span class="line">D/LLL: onStartCommand: <span class="number">1</span></span><br><span class="line">D/LLL: onStartCommand: <span class="number">2</span></span><br><span class="line">D/LLL: onStartCommand: <span class="number">3</span></span><br><span class="line">D/LLL: Current thread: IntentService[MyService]</span><br><span class="line">D/LLL: Intent: hearing-<span class="number">1</span></span><br><span class="line">D/LLL: Current thread: IntentService[MyService]</span><br><span class="line">D/LLL: Intent: hearing-<span class="number">2</span></span><br><span class="line">D/LLL: Current thread: IntentService[MyService]</span><br><span class="line">D/LLL: Intent: hearing-<span class="number">3</span></span><br><span class="line">D/LLL: onDestroy</span><br></pre></td></tr></table></figure>

<p>如果启动的 Service 存在则不会再次创，而会回调 onStartCommand 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        <span class="comment">// 会检查 id 是否为最后一个 id，是则停止服务</span></span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承Service类"><a href="#继承Service类" class="headerlink" title="继承Service类"></a>继承Service类</h2><p>如果需要在Service中执行多线程而不是处理一个请求队列，那么需要继承Service类，分别处理每个Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MyService&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCreate() executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onStartCommand() executed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onDestroy() executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;startDownload() executed&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行具体的下载任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>onStartCommand()返回一个整形变量，该变量必须是下列常量之一：</p>
<ul>
<li>START_NOT_STICKY：若执行完onStartCommand()方法后，系统就kill了service，不要再重新创建service，除非系统回传了一个pending intent。这避免了在不必要的时候运行service，您的应用也可以restart任何未完成的操作。</li>
<li>START_STICKY：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()。dangerous不要重新传递最后一个Intent（do not redeliver the last intent）。相反，系统回调onStartCommand()时回传一个空的Intent，除非有 pending intents传递，否则Intent将为null。该模式适合做一些类似播放音乐的操作。</li>
<li>START_REDELIVER_INTENT：若系统在onStartCommand()执行并返回后kill了service，那么service会被recreate并回调onStartCommand()并将最后一个Intent回传至该方法。任何 pending intents都会被轮流传递。该模式适合做一些类似下载文件的操作。</li>
</ul>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>startService(intent)方法将立即返回，并回调onStartCommand()（请不要手动调用该方法），若该Service未处于运行状态，系统将首先回调onCreate()，接着再回调onStartCommand()。若您希望Service可以返回结果，那么需要通过调用getBroadcast 返回的PendingIntent启动Service（将PendingIntent包装为Intent），service可使用broadcast 传递结果。</p>
<p>多个启动Service的请求可能导致onStartCommand()多次调用，但只需调用stopSelf() 、 stopService()这两个方法之一，就可停止该服务。</p>
<h2 id="绑定Service"><a href="#绑定Service" class="headerlink" title="绑定Service"></a>绑定Service</h2><ul>
<li>通过其他组件调用bindService()方法可以绑定一个Service以保持长连接（long-standing connection），这时一般不允许其他组件调用startService()启动Service。</li>
<li>当其他组件需要与Service交互或者需要跨进程通信时，可以创建一个bound Service。</li>
<li>为创建一个bound Service，必须重写onBind()回调，该方法返回一个IBinder接口。该接口时组件与Service通信的桥梁。组件调用bindService()与Service绑定，该组件可获取IBinder接口，一旦获取该接口，就可以调用Service中的方法。一旦没有组件与Service绑定，系统将destroy它，您不必手动停止它。</li>
<li>为创建一个bound Service，必须定义一个接口 ，该接口指定组件与Service如何通信。定义的接口在组件与Service之间，且必须实现IBinder接口。这正是onBind()的返回值。一旦组件接收了IBinder，组件与Service便可以开始通信。</li>
<li>多个组件可同时与Service绑定，当组件与Service交互结束后，可调用unbindService()方法解绑。bound Service比start Service要复杂，故我将在后续单独翻译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService.MyBinder myBinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            myBinder = (MyService.MyBinder) service;</span><br><span class="line">            myBinder.startDownload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.start_service:</span><br><span class="line">            Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">            startService(startIntent);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.stop_service:</span><br><span class="line">            Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">            stopService(stopIntent);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.bind_service:</span><br><span class="line">            Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</span><br><span class="line">            bindService(bindIntent, connection, BIND_AUTO_CREATE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.unbind_service:</span><br><span class="line">            unbindService(connection);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行前台Service"><a href="#运行前台Service" class="headerlink" title="运行前台Service"></a>运行前台Service</h2><ul>
<li>前台Service用于动态通知消息，如天气预报。该Service不易被kill。前台Service必须提供status bar，只有前台Service被destroy后，status bar才能消失。</li>
<li>举例来说，一个播放音乐的Service必须是前台Service，只有这样用户才能确知其运行状态。为前台Service提供的status bar可以显示当前音乐的播放状态，并可以启动播放音乐的Activity。</li>
<li>调用startForeground()可以启动前台Service。该方法接收两个参数，参数一是一个int型变量，用户指定该通知的唯一性标识，而参数而是一个Notification用于配置status bar</li>
</ul>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>ContentProvider 需要实现的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs,  String sortOrder)</span>　 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span></span></span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<ul>
<li>projection: 返回内容(conlumn名)，null 表示返回所有</li>
<li>selection: 设置条件</li>
<li>selectionArgs: selection 参数条件的内容</li>
<li>sortOrder: ASC(升序)，DESC(降序)，默认升序</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = contentResolver.query(uri, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;name&quot;</span>&#125;, <span class="string">&quot;name=?&quot;</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hearing&quot;</span>&#125;, <span class="string">&quot;id DESC&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以通过 ContentResolver 类与 ContentProvider 统一进行交互；可以通过 ContentObserver 类监听 ContentProvider 中指定 Uri 的数据变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onChange(selfChange, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤1：注册内容观察者ContentObserver</span></span><br><span class="line">getContentResolver().registerContentObserver(uri, <span class="keyword">true</span>, myOberver);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContentProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123; </span><br><span class="line">        db.insert(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;userid&quot;</span>, values); </span><br><span class="line">        getContext().getContentResolver().notifyChange(uri, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：解除观察者</span></span><br><span class="line">getContentResolver().unregisterContentObserver(myOberver);</span><br></pre></td></tr></table></figure>

<h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><p>Uri 的四个组成部分：<code>content://contacts/people/5</code></p>
<ul>
<li>schema：已由Android固定设置为content://</li>
<li>authority：ContentProvider权限，在AndroidMenifest中设置权限</li>
<li>path：要操作的数据库表</li>
<li>id：查询的关键字（可选字段）</li>
</ul>
<p>Uri匹配模式：Uri的匹配表示要查询的数据，对于单个数据查询，可直接使用Uri定位具体的资源位置，但当范围查询时就需要结合通配符的使用，Uri提供以下两种通配符：</p>
<ul>
<li><code>*</code>：匹配由任意长度的任何有效字符组成的字符串</li>
<li><code>#</code>：匹配由任意长度的数字字符组成的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content:<span class="comment">//com.example.app.provider/table2/*  //多数据查询</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/#</span></span><br><span class="line">content:<span class="comment">//com.example.app.provider/table3/6  //单数据查询</span></span><br></pre></td></tr></table></figure>

<h2 id="ContentUris"><a href="#ContentUris" class="headerlink" title="ContentUris"></a>ContentUris</h2><p>核心方法有两个：</p>
<ul>
<li>withAppendedId()：向Uri追加一个id</li>
<li>parseId()：从Uri中获取id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.hearing.provider/user&quot;</span>)</span><br><span class="line"><span class="comment">// 生成的Uri为：content://com.hearing.provider/user/7</span></span><br><span class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;content://com.hearing.provider/user/7&quot;</span>)</span><br><span class="line"><span class="comment">//获取的结果为:7</span></span><br><span class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);</span><br></pre></td></tr></table></figure>

<h2 id="UriMatcher"><a href="#UriMatcher" class="headerlink" title="UriMatcher"></a>UriMatcher</h2><p>UriMatcher的作用：</p>
<ul>
<li>在 ContentProvider 中注册Uri</li>
<li>根据 Uri 匹配 ContentProvider 中对应的数据表</li>
</ul>
<p>使用步骤：</p>
<ol>
<li>初始化UriMatcher对象</li>
<li>在ContentProvider 中注册URI（addURI()）</li>
<li>根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match()）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：初始化UriMatcher对象</span></span><br><span class="line"><span class="comment">// 常量UriMatcher.NO_MATCH：不匹配任何路径的返回码</span></span><br><span class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：在ContentProvider 中注册URI</span></span><br><span class="line"><span class="keyword">int</span> URI_CODE_a = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">int</span> URI_CODE_b = <span class="number">2</span>；</span><br><span class="line">matcher.addURI(<span class="string">&quot;com.hearing.provider&quot;</span>, <span class="string">&quot;user1&quot;</span>, URI_CODE_a); </span><br><span class="line">matcher.addURI(<span class="string">&quot;com.hearing.provider&quot;</span>, <span class="string">&quot;user2&quot;</span>, URI_CODE_b); </span><br><span class="line"><span class="comment">// 若URI资源路径 = content://com.hearing.provider/user1 ，则返回注册码URI_CODE_a</span></span><br><span class="line"><span class="comment">// 若URI资源路径 = content://com.hearing.provider/user2 ，则返回注册码URI_CODE_b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    Uri uri = Uri.parse(<span class="string">&quot;content://com.hearing.provider/user1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(matcher.match(uri)) &#123;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_a:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser1;</span><br><span class="line">        <span class="keyword">case</span> URI_CODE_b:</span><br><span class="line">            <span class="keyword">return</span> tableNameUser2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>指定其他应用访问提供程序的数据所必须具备权限的属性。</p>
<h3 id="grantUriPermssions"><a href="#grantUriPermssions" class="headerlink" title="grantUriPermssions"></a>grantUriPermssions</h3><p><code>android:grantUriPermssions</code>：表示是否可以通过临时权限访问数据，默认为false，在开发中可以只对限定的内容提供临时权限，如对照片的内容 URI 设置临时权限。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:grantUriPermissions=&quot;false&quot;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">grant-uri-permission</span> <span class="attr">android:path</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPattern</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pathPrefix</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>true：系统会向整个系统授予临时权限，并替代其他设置的权限。</li>
<li>false：需添加<code>&lt;grant-uri-permission&gt;</code>并表明可以授权临时权限所对应的URI<ul>
<li>path：表示绝对路径Uri</li>
<li>pathPattern：表示限定完整的路径但可以使用./*通配符匹配</li>
<li>pathPrefix：限定路径的初始部分后面可以变化，只要初始部分符合即可授权</li>
</ul>
</li>
</ul>
<h3 id="permission"><a href="#permission" class="headerlink" title="permission"></a>permission</h3><ul>
<li>android:permission：统一提供程序范围读取/写入权限</li>
<li>android:readPermission：提供程序范围读取权限，优先于permission权限</li>
<li>android:writePermission：提供程序范围写入权限，优先于permission权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:readPermission=&quot;com.hearing.provider.permission.READ_PERMISSION&quot;</span><br><span class="line">android:writePermission=&quot;com.hearing.provider.permission.WRITE_PERMISSION&quot;</span><br><span class="line">android:permission=&quot;com.hearing.provider.permission.PERMISSION&quot;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建两个程序A和B，在程序A中使用ContentProvider保存数据，在程序B中进行查询，在开始A程序中不设置任何权限，B程序进行访问数据会报错；</li>
<li>修改A程序清单文件添加android:exported=”true”，再次访问数据访问成功；</li>
<li>在A程序的清单文件中，为Provider添加两个读写权限，添加完权限后再次在B程序中获取数据，还是会报错，也很正常因为已经对数据的访问设置了门槛，所以在B程序中声明读写权限即可。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A程序 --&gt;</span></span><br><span class="line">android:writePermission=&quot;com.hearing.provider.provider.WRITE&quot;</span><br><span class="line">android:readPermission=&quot;com.hearing.provider.provider.READ&quot;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- B程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.provider.READ&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.provider.WRITE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实例：IPC"><a href="#实例：IPC" class="headerlink" title="实例：IPC"></a>实例：IPC</h2><h3 id="进程一"><a href="#进程一" class="headerlink" title="进程一"></a>进程一</h3><p><strong>创建数据库类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">&quot;finch.db&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JOB_TABLE_NAME = <span class="string">&quot;job&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DBHelper</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个表格:用户表 和职业表</span></span><br><span class="line">        db.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + USER_TABLE_NAME + <span class="string">&quot;(_id INTEGER PRIMARY KEY AUTOINCREMENT,&quot;</span> + <span class="string">&quot; name TEXT)&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;CREATE TABLE IF NOT EXISTS &quot;</span> + JOB_TABLE_NAME + <span class="string">&quot;(_id INTEGER PRIMARY KEY AUTOINCREMENT,&quot;</span> + <span class="string">&quot; job TEXT)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span>   </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义ContentProvider：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    DBHelper mDbHelper = <span class="keyword">null</span>;</span><br><span class="line">    SQLiteDatabase db = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ContentProvider的唯一标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOHORITY = <span class="string">&quot;com.hearing.provider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> User_Code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Job_Code = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UriMatcher类使用:在ContentProvider 中注册URI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher mMatcher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">&quot;user&quot;</span>, User_Code);</span><br><span class="line">        mMatcher.addURI(AUTOHORITY, <span class="string">&quot;job&quot;</span>, Job_Code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        <span class="comment">// 在ContentProvider创建时对数据库进行初始化，不能做耗时操作，此处仅作展示</span></span><br><span class="line">        mDbHelper = <span class="keyword">new</span> DBHelper(getContext());</span><br><span class="line">        db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">&quot;delete from user&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into user values(1,&#x27;Carson&#x27;);&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into user values(2,&#x27;Kobe&#x27;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        db.execSQL(<span class="string">&quot;delete from job&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into job values(1,&#x27;Android&#x27;);&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;insert into job values(2,&#x27;iOS&#x27;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        db.insert(table, <span class="keyword">null</span>, values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">return</span> db.query(table, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不作展开</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (mMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> User_Code:</span><br><span class="line">                tableName = DBHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Job_Code:</span><br><span class="line">                tableName = DBHelper.JOB_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注册ContentProvider：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;MyProvider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:authorities</span>=<span class="string">&quot;com.hearing.provider.myprovider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:permission</span>=<span class="string">&quot;com.hearing.provider.PROVIDER&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:readPermission</span> = <span class="string">&quot;com.hearing.provider.Read&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:writePermission</span> = <span class="string">&quot;com.hearing.provider.Write&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.Read&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;normal&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.Write&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;normal&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.PROVIDER&quot;</span> <span class="attr">android:protectionLevel</span>=<span class="string">&quot;normal&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="进程二"><a href="#进程二" class="headerlink" title="进程二"></a>进程二</h3><p><strong>声明权限：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.PROVIDER&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.Read&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;com.hearing.provider.Write&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>访问ContentProvider：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URI</span></span><br><span class="line">        Uri uri_user = Uri.parse(<span class="string">&quot;content://com.hearing.provider.myprovider/user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">&quot;_id&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        values.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jordan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver.insert(uri_user, values);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor = resolver.query(uri_user, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;_id&quot;</span>,<span class="string">&quot;name&quot;</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;query book:&quot;</span> + cursor.getInt(<span class="number">0</span>) +<span class="string">&quot; &quot;</span>+ cursor.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源</span></span><br><span class="line">        Uri uri_job = Uri.parse(<span class="string">&quot;content://com.hearing.provider.myprovider/job&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入表中数据</span></span><br><span class="line">        ContentValues values2 = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values2.put(<span class="string">&quot;_id&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        values2.put(<span class="string">&quot;job&quot;</span>, <span class="string">&quot;NBA Player&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ContentResolver</span></span><br><span class="line">        ContentResolver resolver2 = getContentResolver();</span><br><span class="line">        <span class="comment">// 通过ContentResolver 根据URI 向ContentProvider中插入数据</span></span><br><span class="line">        resolver2.insert(uri_job,values2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ContentResolver 向ContentProvider中查询数据</span></span><br><span class="line">        Cursor cursor2 = resolver2.query(uri_job, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;_id&quot;</span>,<span class="string">&quot;job&quot;</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (cursor2.moveToNext()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;query job:&quot;</span> + cursor2.getInt(<span class="number">0</span>) +<span class="string">&quot; &quot;</span>+ cursor2.getString(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>对于面向Android 7.0及以上的应用，Android禁止在应用外部公开<code>file://url</code>。如果一项包含文件URI的intent离开应用，则应用会抛出FileUriExposedException异常。</p>
<p>解决方案：要在应用间共享文件，应发送一项content://URI，并授予URI临时访问权限。进行此授权的最简单方式是使用FileProvider类。FileProvider是ContentProvider的一个特殊的子类，它让应用间共享文件变得更加容易，其通过创建一个Content URI来代替File URI。</p>
<h3 id="注册FileProvider"><a href="#注册FileProvider" class="headerlink" title="注册FileProvider"></a>注册FileProvider</h3><p>由于FileProvider中已经包含了为file生成Content URI的基本代码了，所以开发者不必再去定义一个FileProvider的子类。你可以在XML文件中指定一个FileProvider：在manifest中使用<code>&lt;provider&gt;</code>标签来指定。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;android.support.v4.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">&quot;com.hearing.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>name的值一般都固定为android.support.v4.content.FileProvider。如果开发者继承了FileProvider，则可以写上其绝对路径。</li>
<li>authorities字段的值用来表明使用的使用者，在FileProvider的函数getUriForFile需要传入该参数。</li>
<li>exported 的值为false，表示该FileProvider只能本应用使用，不是public的。</li>
<li>grantUriPermissions 的值为true，表示允许赋予临时权限。</li>
</ul>
<h3 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h3><p>只有事先指定了目录，一个FileProvider才可以为文件生成一个对应的Content URI。要指定一个路径，需要在XML文件中指定其存储的路径。使用<code>&lt;paths&gt;</code>标签。例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">&quot;my_images&quot;</span> <span class="attr">path</span>=<span class="string">&quot;images/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;root-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>/</code></li>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>/data/data/&lt;package-name&gt;/files/path/</code></li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>/data/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>Context.getExternalFilesDir(null) + &quot;/path/&quot;</code>，<code>/storage/emulated/0/Android/data/&lt;package_name&gt;/files/path/</code></li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>Context.getExternalCacheDir() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/data/&lt;package-name&gt;/cache/path/</code></li>
<li><code>&lt;external-media-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>Context.getExternalMediaDirs() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/Android/media/&lt;package-name&gt;/path/</code></li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>: <code>Environment.getExternalStorageDirectory() + &quot;/path/&quot;</code>，即<code>/storage/emulated/0/path/</code></li>
</ul>
<p>在res目录下新建xml目录，然后新建文件file_paths.xml，根据上述内容编写。</p>
<h3 id="获取Content-Uri"><a href="#获取Content-Uri" class="headerlink" title="获取Content Uri"></a>获取Content Uri</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">&quot;/text&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">Uri data;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    data = FileProvider.getUriForFile(mContext, <span class="string">&quot;com.hearing.fileprovider&quot;</span>, file);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    data = Uri.fromFile(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋予临时权限"><a href="#赋予临时权限" class="headerlink" title="赋予临时权限"></a>赋予临时权限</h3><p>两种方法：（通常使用第2种）</p>
<ol>
<li>Context.grantUriPermission(package, Uri, mode_flags)</li>
<li>Intent.setFlags()：<code>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION);</code></li>
</ol>
<p>Flag意义如下：</p>
<ul>
<li>FLAG_GRANT_READ_URI_PERMISSION：表示读取权限； </li>
<li>FLAG_GRANT_WRITE_URI_PERMISSION：表示写入权限。</li>
</ul>
<h3 id="分享文件URI"><a href="#分享文件URI" class="headerlink" title="分享文件URI"></a>分享文件URI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;shareFile: &quot;</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    ComponentName componentName = <span class="keyword">new</span> ComponentName(<span class="string">&quot;com.hearing.fileproviderclient&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.hearing.fileproviderclient.MainActivity&quot;</span>);</span><br><span class="line">    intent.setComponent(componentName);</span><br><span class="line">    File file = <span class="keyword">new</span> File(mContext.getFilesDir() + <span class="string">&quot;/text&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    Uri data;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        data = FileProvider.getUriForFile(mContext, FILE_PROVIDER_AUTHORITIES, file);</span><br><span class="line">        <span class="comment">// 给目标应用一个临时授权</span></span><br><span class="line">        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.setData(data);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mime-Type"><a href="#Mime-Type" class="headerlink" title="Mime Type"></a>Mime Type</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>MIME：多用途互联网邮件扩展（Multipurpose Internet Mail Extensions）是一个互联网标准，它扩展了电子邮件标准，使其能够支持非ASCII字符、二进制格式附件等多种格式的邮件消息。</p>
<p>MIME TYPE一般以这种形式出现：<code>[type]/[subtype]</code></p>
<p>type标识内容type，有下面的形式：</p>
<ul>
<li>Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；</li>
<li>Multipart：用于连接消息体的多个部分构成一个消息，这些部分可以是不同类型的数据；</li>
<li>Application：用于传输应用程序数据或者二进制数据；</li>
<li>Message：用于包装一个E-mail消息；</li>
<li>Image：用于传输静态图片数据；</li>
<li>Audio：用于传输音频或者音声数据；</li>
<li>Video：用于传输动态影像数据，可以是与音频编辑在一起的视频数据格式。</li>
</ul>
<p>subtype用于指定type的详细形式。<code>content-type/subtype</code>配对的集合和与此相关的参数，将随着时间而增长。为了确保这些值在一个有序而且公开的状态下开发，MIME使用Internet Assigned Numbers Authority (IANA)作为中心的注册机制来管理这些值。常用的subtype值如下所示：</p>
<ul>
<li>text/plain（纯文本）</li>
<li>text/html（HTML文档）</li>
<li>application/xhtml+xml（XHTML文档）</li>
<li>image/gif（GIF图像）</li>
<li>image/jpeg（JPEG图像）</li>
<li>image/png（PNG图像）</li>
<li>video/mpeg（MPEG动画）</li>
<li>application/octet-stream（任意的二进制数据）</li>
<li>application/pdf（PDF文档）</li>
<li>application/msword（Microsoft Word文件）</li>
<li>message/rfc822（RFC 822形式）</li>
<li>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）</li>
<li>application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</li>
<li>multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</li>
</ul>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>当Android系统接收到一个隐式Intent要启动一个Activity(或其他组件)时，Android会根据以下三个信息比较Intent的信息与注册的组件的intent-filter的信息，从而为该Intent选择出最匹配的Activity(或其他组件)：</p>
<ul>
<li>intent中的action</li>
<li>intent中的category</li>
<li>intent中的data（包含Uri以及data的MIME类型）</li>
</ul>
<p>也就是隐式intent对象要满足要启动的目标组件中注册的intent-filter中的<code>&lt;action/&gt;</code>、<code>&lt;category/&gt;</code>、<code>&lt;data/&gt;</code>三个标签中的信息，即要分别通过action测试、category测试以及data测试。</p>
<p>MINI类型即在data中指定。</p>
<h1 id="Intent和Intent-filter"><a href="#Intent和Intent-filter" class="headerlink" title="Intent和Intent-filter"></a>Intent和Intent-filter</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Intent 是一个消息传递对象，可以用来从其他应用组件请求操作, Intent 包括显式和隐式。</li>
<li>Intent-filter 是 Manifest 中的一个表达式，用于指定该组件要接收的 Intent 类型。</li>
</ul>
<p>为了确保应用的安全性，启动 Service 时应该始终使用显式 Intent，且不要为服务声明 Intent-filter。</p>
<h2 id="构建Intent"><a href="#构建Intent" class="headerlink" title="构建Intent"></a>构建Intent</h2><h3 id="Component-name"><a href="#Component-name" class="headerlink" title="Component name"></a>Component name</h3><p>可选项，如果没有组件名称，则 Intent 为隐式，如需在应用中启动特定的组件，则应指定该组件的名称。可以使用 setComponent(), setClass(), setClassName() 或 Intent 构造函数设置组件名称。</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>可以指定自己的 action。以下是一些用于启动 Activity 的常见操作：</p>
<ol>
<li>ACTION_VIEW: 拥有一些可向用户显示的信息(查看照片 或 观看视频等)。</li>
<li>ACTION_SEND：拥有一些用户可通过其他应用(例如电子邮件应用 或 社交共享应用)共享的数据。</li>
</ol>
<p>可以使用 setAction() 或 Intent 构造函数为 Intent 指定操作。</p>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>指定数据 MIME 类型的 URI，提供的数据类型通常由 Intent 的 Action 决定，例如如果操作是 ACTION_EDIT 则数据应包含待编辑文档的 URI。</p>
<p>可以使用 setData() 设置数据 URI；可以使用 setType() 设置 MIME 类型；可以使用 setDataAndType() 同时显式设置二者。注意：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。</p>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>一个包含应处理 Intent 组件类型的附加信息的字符串。可以将任意数量的Category放入一个 Intent 中，但大多数 Intent 均不需要 Category。以下是一些常见category：</p>
<ul>
<li>CATEGORY_BROWSABLE：目标 Activity 允许本身通过网络浏览器启动，以显示链接引用的数据，如图像或电子邮件。</li>
<li>CATEGORY_LAUNCHER：该 Activity 是任务的初始 Activity，在系统的应用启动器中列出。</li>
<li>CATEGORY_HOME：桌面应用需要声明。</li>
<li>CATEGORY_DEFAULT：通过隐式启动Activity时，Android会默认加上一个CATEGORY_DEFAULT，所以如果Activity要支持隐式启动的话，除了默认LaunchActivity，其余都需要加上CATEGORY_DEFAULT。</li>
</ul>
<p>可以使用 addCategory() 指定 category。</p>
<h3 id="Extras"><a href="#Extras" class="headerlink" title="Extras"></a>Extras</h3><p>携带完成请求操作所需的附加信息的键值对，可以使用各种 putExtra() 方法添加 extra 数据。</p>
<h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><p>可以使用 setFlags() 方法添加Flags。</p>
<h2 id="接收隐式-Intent"><a href="#接收隐式-Intent" class="headerlink" title="接收隐式 Intent"></a>接收隐式 Intent</h2><p>应用组件应当为自身可执行的每个独特作业声明单独的filter。例如，图像库应用中的一个 Activity 可能会有两个filter，分别用于查看图像和编辑图像。</p>
<p>在 <code>&lt;intent-filter&gt;</code> 内部可以使用以下三个元素中的一个或多个指定要接受的 Intent 类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在 name 属性中，声明接受的 Intent 操作。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据 URI（scheme、host、port、path）各个方面和 MIME 类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在 name 属性中，声明接受的 Intent category。</li>
</ul>
<p>请注意：要接收隐式 Intent，必须将 CATEGORY_DEFAULT category 包括在 Intent-filter中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT category的方式处理所有 Intent。如果未在 Intent-filter中声明此category，则隐式 Intent 不会解析为您的 Activity。</p>
<p>可以创建一个包括多个 <code>&lt;action&gt;</code>、<code>&lt;data&gt;</code> 或 <code>&lt;category&gt;</code> 实例的filter，创建时，需确定组件能够处理这些filter元素的任何及所有组合。系统通过将 Intent 与所有这三个元素进行比较，根据filter测试隐式 Intent。隐式 Intent 若要传递给组件，必须通过所有这三项测试。</p>
<h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当收到隐式 Intent 以启动 Activity 时，系统会根据以下三个方面将该 Intent 与 Intent-filter进行比较，搜索该 Intent 的最佳 Activity：</p>
<ul>
<li>Action</li>
<li>Data（URI 和数据类型）。</li>
<li>Category</li>
</ul>
<h3 id="Action测试"><a href="#Action测试" class="headerlink" title="Action测试"></a>Action测试</h3><p>要指定接受的 Intent action，Intent-filter既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素。要通过此filter，Intent 中指定的action必须与filter中列出的某一action匹配。</p>
<h3 id="Category测试"><a href="#Category测试" class="headerlink" title="Category测试"></a>Category测试</h3><p>要指定接受的 Intent category，Intent-filter既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素。要使 Intent 通过category测试，则 Intent 中的每个category均必须与filter中的category匹配。Intent-filter声明的category可以超出 Intent 中指定的数量，因此不含category的 Intent 应当始终会通过此测试，无论filter中声明何种category均是如此。</p>
<p>请注意：Android 会自动将 CATEGORY_DEFAULT category应用于传递给 startActivity() 和 startActivityForResult() 的所有隐式 Intent。如需 Activity 接收隐式 Intent，则必须将 “android.intent.category.DEFAULT” 的category包括在其 Intent-filter中。</p>
<h3 id="Data测试"><a href="#Data测试" class="headerlink" title="Data测试"></a>Data测试</h3><p>要指定接受的 Intent 数据，Intent-filter既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素，如下例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;video/mpeg&quot;</span> <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;audio/mpeg&quot;</span> <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：scheme、host、port 和 path：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code></p>
<p>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p>
<ul>
<li>如果未指定scheme，则会忽略host。</li>
<li>如果未指定host，则会忽略port。</li>
<li>如果未指定scheme和host，则会忽略path。</li>
</ul>
<p>将 Intent 中的 URI 与filter中的 URI 规范进行比较时，它仅与filter中包含的部分 URI 进行比较。例如：</p>
<ul>
<li>如果filter仅指定scheme，则具有该scheme的所有 URI 均与该filter匹配。</li>
<li>如果filter指定scheme和host，但未指定path，则具有相同scheme和host的所有 URI 都会通过filter，无论其path如何均是如此。</li>
<li>如果filter指定scheme、host和path，则仅具有相同scheme、host和path的 URI 才会通过filter。</li>
</ul>
<p>请注意：path规范可以包含星号通配符 (*)，因此仅需部分匹配路径名即可。</p>
<p>数据测试会将 Intent 中的 URI 和 MIME 类型与filter中指定的 URI 和 MIME 类型进行比较。规则如下：</p>
<ul>
<li>仅当filter未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li>
<li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与filter的 URI 格式匹配、且filter同样未指定 MIME 类型时，才会通过测试。</li>
<li>仅当filter列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li>
<li>仅当 MIME 类型与filter中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与filter中的 URI 匹配，或者如果 Intent 具有 content: 或 file: URI 且filter未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果filter只是列出 MIME 类型，则假定组件支持 content: 和 file: 数据。</li>
</ul>
<p>请注意：如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <code>&lt;intent-filter&gt;</code> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p>
<p>最后一条规则反映出对组件能够从文件中或内容提供程序处获得本地数据的预期。因此，其filter只能列出数据类型，不需要显式命名 content: 和 file: scheme。以下是一个典型示例，说明 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从内容提供程序处获得并显示图像数据：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;image/*&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于大部分可用数据均由内容提供程序分发，因此指定数据类型（而非 URI）的filter也许最为常见。</p>
<p>另一常见的配置是具有scheme和数据类型的filter。例如，下文中的 <code>&lt;data&gt;</code> 元素向 Android 指出，组件可从网络中检索视频数据以执行操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;video/*&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/Android%E5%8A%A8%E7%94%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/10/Android%E5%8A%A8%E7%94%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Android动画笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-10 14:20:19" itemprop="dateCreated datePublished" datetime="2019-09-10T14:20:19+08:00">2019-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Framework/" itemprop="url" rel="index"><span itemprop="name">Framework</span></a>
                </span>
            </span>

          
            <span id="/2019/09/10/Android%E5%8A%A8%E7%94%BB%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Android动画笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/09/10/Android%E5%8A%A8%E7%94%BB%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/09/10/Android%E5%8A%A8%E7%94%BB%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="View动画（补间动画）"><a href="#View动画（补间动画）" class="headerlink" title="View动画（补间动画）"></a>View动画（补间动画）</h1><table>
<thead>
<tr>
<th align="center">XML</th>
<th align="center">Java</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">alph</td>
<td align="center">AlphaAnimation</td>
<td align="center">渐变透明度动画效果</td>
</tr>
<tr>
<td align="center">scale</td>
<td align="center">ScaleAnimation</td>
<td align="center">渐变尺寸伸缩动画效果</td>
</tr>
<tr>
<td align="center">translate</td>
<td align="center">TranslateAnimation</td>
<td align="center">画面转换位置移动动画效果</td>
</tr>
<tr>
<td align="center">rotate</td>
<td align="center">RotateAnimation</td>
<td align="center">画面转移旋转动画效果</td>
</tr>
</tbody></table>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/09/10/Android%E5%8A%A8%E7%94%BB%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/Linux%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/27/Linux%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-27 17:55:01" itemprop="dateCreated datePublished" datetime="2019-08-27T17:55:01+08:00">2019-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2019/08/27/Linux%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Linux笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/08/27/Linux%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/08/27/Linux%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="多条命令执行结果不输出到终端"><a href="#多条命令执行结果不输出到终端" class="headerlink" title="多条命令执行结果不输出到终端"></a>多条命令执行结果不输出到终端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用;分隔的多条命令执行结果之间互不干扰</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls;lls;ls</span></span><br><span class="line">Downloads  termux-packages</span><br><span class="line">zsh: command not found: lls</span><br><span class="line">Downloads  termux-packages</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用&amp;&amp;分割的多条命令后一条会在前一条命令执行成功后才执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls&amp;&amp;lls&amp;&amp;ls</span></span><br><span class="line">Downloads  termux-packages</span><br><span class="line">zsh: command not found: lls</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用cmd &gt; /dev/null 2&gt;&amp;1将输出重定向到null，即不输出到终端</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用<span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> 1; <span class="keyword">else</span> <span class="built_in">echo</span> 0;<span class="keyword">fi</span>;可以得到上一条命令的执行结果（$?表示上一条命令的执行结果）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls &gt; /dev/null 2&gt;&amp;1;<span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> 1; <span class="keyword">else</span> <span class="built_in">echo</span> 0;<span class="keyword">fi</span>;</span></span><br><span class="line">0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用&#123;&#125;包裹起来的多条命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> &#123;ls&amp;&amp;ls&amp;&amp;ls&#125; &gt; /dev/null 2&gt;&amp;1;<span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">echo</span> 1; <span class="keyword">else</span> <span class="built_in">echo</span> 0;<span class="keyword">fi</span>;</span></span><br><span class="line">0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span>指定-e参数可开启转移，添加/c可不换行输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;please input a value:\c&quot;</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，解决办法有两种途径：</p>
<ul>
<li>让进程忽略 HUP 信号；</li>
<li>让进程运行在新的会话里从而成为不属于此终端的子进程。</li>
</ul>
<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>nohup 的用途就是让提交的命令忽略 hangup 信号，一般我们可在结尾加上”&amp;”来将命令同时放入后台运行，也可用”&gt;filename 2&gt;&amp;1”来更改缺省的重定向文件名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nohup ping www.baidu.com &amp;</span></span><br><span class="line">[1] 3059</span><br><span class="line">nohup: appending output to &#x27;nohup.out&#x27;</span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef |grep 3059</span></span><br><span class="line">root      3059   984  0 21:06 pts/3    00:00:00 ping www.baidu.com</span><br><span class="line">root      3067   984  0 21:06 pts/3    00:00:00 grep 3059</span><br></pre></td></tr></table></figure>

<h3 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h3><p>换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能做到这一点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> setsid ping www.baidu.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef |grep www.baidu.com</span></span><br><span class="line">root     31094     1  0 07:28 ?        00:00:00 ping www.baidu.com</span><br><span class="line">root     31102 29217  0 07:29 pts/4    00:00:00 grep www.baidu.com</span><br></pre></td></tr></table></figure>

<p>进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>将一个或多个命名包含在<code>()</code>中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能。</p>
<p>当我们将<code>&amp;</code>也放入<code>()</code>内之后，就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> (ping www.baidu.com &amp;)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -ef |grep www.baidu.com</span></span><br><span class="line">root     16270     1  0 14:13 pts/4    00:00:00 ping www.baidu.com</span><br><span class="line">root     16278 15362  0 14:13 pts/4    00:00:00 grep www.baidu.com</span><br></pre></td></tr></table></figure>

<p>从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。</p>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存），一个进程总共可访问的地址空间。其大小还包括了可能不在RAM中的内存（比如虽然malloc分配了空间，但尚未写入）。 VSS 很少被用于判断一个进程的真实内存使用量。</li>
<li>RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存），一个进程在RAM中真实存储的总内存。但是RSS还是可能会造成误导，因为它仅仅表示该进程所使用的所有共享库的大小，它不管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况。 </li>
<li>PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存），按比例表示使用的共享库， 例如：如果有三个进程都使用了一个共享库，共占用了30页内存。那么PSS将认为每个进程分别占用该共享库10页的大小。 PSS是非常有用的数据，因为系统中所有进程的PSS都相加的话，就刚好反映了系统中的总共占用的内存。 而当一个进程被销毁之后， 其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程。这样PSS可能会造成一点的误导，因为当一个进程被销毁后，PSS不能准确地表示返回给全局系统的内存（the memory returned to the overall system）。</li>
<li>USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存），一个进程所占用的私有内存。即该进程独占的内存。 USS是非常非常有用的数据，因为它反映了运行一个特定进程真实的边际成本（增量成本）。当一个进程被销毁后，USS是真实返回给系统的内存。当进程中存在一个可疑的内存泄露时，USS是最佳观察数据。</li>
</ul>
<p>一般来说内存占用大小有如下规律：VSS &gt;= RSS &gt;= PSS &gt;= USS</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> free -h</span></span><br><span class="line">       total       used        free      shared  buff/cache   available</span><br><span class="line">Mem:   7.9G        6.6G        1.0G         17M        223M        1.1G</span><br><span class="line">Swap:  19G         566M         19G                                    </span><br></pre></td></tr></table></figure>

<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 得到进程的pid</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidof sleep</span></span><br><span class="line">602</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> top指定查看PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> top -p 602</span></span><br><span class="line">top - 11:01:36 up 23 min,  0 users,  load average: 0.52, 0.58, 0.59</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.7 us,  0.9 sy,  0.0 ni, 98.2 id,  0.0 wa,  0.2 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  8266588 total,  2224708 free,  5812528 used,   229352 buff/cache</span><br><span class="line">KiB Swap: 20680852 total, 19784620 free,   896232 used.  2320328 avail Mem</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">602 hearing   15 42+   13956    808    688 S   0.0  0.0   0:00.01 sleep</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> top查看某些指定的PID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> top -p 602,666,1001</span></span><br></pre></td></tr></table></figure>

<ul>
<li>键入 <code>P</code> 按照CPU排序输出</li>
<li>键入 <code>M</code> 按照内存排序输出</li>
</ul>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps是显示瞬间进程的状态，并不动态连续；如果想对进程进行实时监控应该用top命令。如果输出较多可以结合less命令和管道来使用，即 <code>ps -ef | less</code> 。</p>
<ul>
<li>-A：所有的进程均显示出来，与 -e 具有同样的效用</li>
<li>-a：显示现行终端机下的所有进程，包括其他用户的进程</li>
<li>-u：以用户为主的进程状态/以针对用户的格式输出</li>
<li>-x：通常与 a 这个参数一起使用，可列出较完整信息</li>
<li>-l：较长、较详细的将该PID 的的信息列出；</li>
<li>-j：工作的格式 (jobs format)</li>
<li>-f：做一个更为完整的输出。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据CPU使用率来升序排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -aux --sort -pcpu | less</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据内存使用率来升序排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -aux --sort -pmem | less</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并命令，并通过管道显示前10个结果</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps -aux --sort -pcpu,+pmem | head -n 10</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>-C</code> 参数查看指定进程的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -f -C sleep</span></span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">hearing    348     7  0 10:45 tty1     00:00:00 sleep 555</span><br></pre></td></tr></table></figure>

<p>也可以结合<code>watch</code>命令实时查看信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每秒执行一次ps -aux --sort -pmem, -pcpu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch -n 1 <span class="string">&#x27;ps -aux --sort -pmem, -pcpu&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/<span class="variable">$pid</span>/status</span></span><br><span class="line">Name:	main</span><br><span class="line">State:	S (sleeping)</span><br><span class="line">Tgid:	24154</span><br><span class="line">Pid:	24154</span><br><span class="line">PPid:	1</span><br><span class="line">TracerPid:	0</span><br><span class="line">Uid:	2000	2000	2000	2000</span><br><span class="line">Gid:	2000	2000	2000	2000</span><br><span class="line">FDSize:	32</span><br><span class="line">Groups:	1004 1007 1011 1015 1028 3001 3002 3003 3006</span><br><span class="line">VmPeak:	  777484 kB</span><br><span class="line">VmSize:	  777484 kB</span><br><span class="line">VmLck:	       0 kB</span><br><span class="line">VmPin:	       0 kB</span><br><span class="line">VmHWM:	   26960 kB</span><br><span class="line">VmRSS:	   26960 kB</span><br><span class="line">VmData:	   11680 kB</span><br><span class="line">VmStk:	    8192 kB</span><br><span class="line">VmExe:	      12 kB</span><br><span class="line">VmLib:	   52812 kB</span><br><span class="line">VmPTE:	     134 kB</span><br><span class="line">VmSwap:	       0 kB</span><br><span class="line">Threads:	13</span><br><span class="line">SigQ:	0/6947</span><br><span class="line">SigPnd:	0000000000000000</span><br><span class="line">ShdPnd:	0000000000000000</span><br><span class="line">SigBlk:	0000000000001204</span><br><span class="line">SigIgn:	0000000000000001</span><br><span class="line">SigCgt:	00000002000094f8</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000000000000000</span><br><span class="line">CapEff:	0000000000000000</span><br><span class="line">CapBnd:	00000000000000c0</span><br><span class="line">Seccomp:	0</span><br><span class="line">Cpus_allowed:	f</span><br><span class="line">Cpus_allowed_list:	0-3</span><br><span class="line">voluntary_ctxt_switches:	18</span><br><span class="line">nonvoluntary_ctxt_switches:	76</span><br></pre></td></tr></table></figure>

<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="procrank"><a href="#procrank" class="headerlink" title="procrank"></a>procrank</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">rocrank</span><br><span class="line">  PID      Vss      Rss      Pss      Uss  cmdline</span><br><span class="line"> 1078   59840K   59708K   42125K   39344K  com.csr.BTApp</span><br><span class="line"> 2683   59124K   59040K   37960K   33032K  com.android.launcher</span><br><span class="line"> 1042   51572K   51488K   35686K   33604K  android.process.acore</span><br><span class="line">  782   32808K   32748K   16775K   14716K  system_server</span><br><span class="line">  667   20560K   17560K   12739K    8940K  /system/bin/surfaceflinger</span><br><span class="line">  851   30124K   30036K   12085K    7996K  com.android.systemui</span><br><span class="line"> 2999   27680K   27596K    9929K    7040K  com.baidu.input</span><br><span class="line">  959   20764K   20676K    5522K    3788K  com.android.phone</span><br><span class="line"> 3468   21892K   21800K    4591K    1920K  com.apical.dreamthemetime</span><br><span class="line">  982   19880K   19792K    4438K    2644K  com.csr.csrservices</span><br><span class="line">  668   19592K   19480K    3525K    1360K  zygote</span><br><span class="line">  670    2960K    2960K    2407K    2356K  /system/bin/mediaserver</span><br><span class="line">  663    1784K    1784K    1209K    1116K  /system/bin/synergy_service</span><br><span class="line">  756    3404K    1348K    1133K    1124K  /usr/bin/gpsexe</span><br><span class="line">  669    1468K    1468K     959K     928K  /system/bin/drmserver</span><br><span class="line">  675     692K     692K     692K     692K  /bin/sh</span><br><span class="line"> 3482     656K     652K     456K     444K  procrank</span><br><span class="line">    1     164K     164K     144K     144K  /init</span><br><span class="line">                          ------   ------  ------</span><br><span class="line">                         195031K  163724K  TOTAL</span><br><span class="line"></span><br><span class="line">RAM: 480380K total, 3624K free, 732K buffers, 299788K cached, 264844K shmem, 7632K slab</span><br></pre></td></tr></table></figure>

<h4 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dumpsys [options]</span><br><span class="line">        meminfo 显示内存信息</span><br><span class="line">        cpuinfo 显示CPU信息</span><br><span class="line">        account 显示accounts信息</span><br><span class="line">        activity 显示所有的activities的信息</span><br><span class="line">        window 显示键盘，窗口和它们的关系</span><br><span class="line">        wifi 显示wifi信息</span><br></pre></td></tr></table></figure>

<p>可以在其后通过包名或者进程pid展示指定进程的信息。</p>
<h1 id="UNIX与Linux"><a href="#UNIX与Linux" class="headerlink" title="UNIX与Linux"></a>UNIX与Linux</h1><p>Linux 是一个类似 Unix 的操作系统（类UNIX系统），Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化，所以 Linux 模仿了 UNIX（但并没有抄袭 UNIX 的源码），使得 Linux 在外观和交互上与 UNIX 非常类似。</p>
<p>二者的区别：</p>
<ul>
<li>UNIX 系统大多是与硬件配套的，也就是说，大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上；</li>
<li>UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的。</li>
</ul>
<p>UNIX/Linux系统结构：可以粗糙地抽象为 3 个层次：底层是 UNIX/Linux 操作系统，即系统内核（Kernel）；中间层是 Shell 层，即命令解释层；高层则是应用层。</p>
<ol>
<li>内核层：内核层是 UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。</li>
<li>Shell层：Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。目前主要有下列版本的shell：<ul>
<li>Bourne Shell(sh)：贝尔实验室开发的 　</li>
<li>Bourne Again Shell(bash)：GNU操作系统上默认的shell，大部分linux的发行套件使用的都是这种shell</li>
<li>Korn Shell：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容</li>
<li>C Shell：是SUN公司Shell的BSD版本</li>
</ul>
</li>
<li>应用层：应用层提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能，可系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window。</li>
</ol>
<h1 id="Linux内核与发行版"><a href="#Linux内核与发行版" class="headerlink" title="Linux内核与发行版"></a>Linux内核与发行版</h1><p>Linux内核是计算机操作系统的核心。一个完整的 Linux发行版包括了内核与一些其他与文件相关的操作，用户管理系统，和软件包管理器等一系列软件。每个工具都是整个系统的一小部分。这些工具通常都是一个个独立的项目，有相应的开发者来开发及维护。</p>
<p>Linux的众多发行版可能是基于不同的内核版本的。例如：流行的 RHEL6发行版是基于很老但是很稳定的 2.6.32 版本的Linux内核的。其他的一些发行版可能会很快的更新以适应最新的内核版本。需要特别注意的一点是，内核并不是一个非此即彼的命题，例如RHEL6就在2.6.32的内核中引进了新版本内核的许多改进。</p>
<p>各发行版提供的其他基本工具和组成部分还有包括以下的内容：C/C++编译器，gdbdebugger 调试工具，核心系统库应用程序，用于在屏幕上绘图的底层接口以及高级的桌面环境，以及供安装和更新包括内核在内的众多组建的系统</p>
<p>Debian是包括Ubuntu在内许多发行版的上游，而Ubuntu又是Linux Mint及其他发行版的上游。Debian在服务器和桌面电脑领域都有着广泛的应用。Debian是一个纯开源计划并着重在一个关键点上，稳定性。它同时也提供了最大的和完整的软件仓库给用户。</p>
<h1 id="Android与Linux"><a href="#Android与Linux" class="headerlink" title="Android与Linux"></a>Android与Linux</h1><ul>
<li>Android采用Linux作为内核</li>
<li>Android对Linux内核做了修改，目的是适应在移动设备上使用</li>
<li>Android开始作为Linux的一个分支，后来由于无法并入Linux的主开发树，已被Linux Kernel小组从开发树中删除</li>
</ul>
<p>Android是在Linux内核基础上运行的，提供的核心系统服务包括安全、内存管理、进程管理、网络组和驱动模型等内容。在硬件层和系统中其他软件之间添加了硬件抽象层（HAL），严格上来说Android不算是Linux系统</p>
<p>Android内核是有标准的Linux内核修改而来的，继承了Linux内核的诸多优点，保留了Linux内核的主题框架，同时Android按照移动设备的要求，在文件系统、内存管理、进程间通信机智和电源管理方面进行了修改，添加了相关的驱动程序和必要的新功能。Android在很大程度上保留了Linux的基本架构。</p>
<h1 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h1><p>GPL：GNU通用公共许可协议（英语：GNU General Public License，缩写GNU GPL 或 GPL），是被广泛使用的自由软件许可证，给予了终端用户运行、学习、共享和修改软件的自由。</p>
<p>GNU是一个自由的操作系统，其内容软件完全以GPL方式发布。这个操作系统是GNU计划的主要目标，名称来自GNU’s Not Unix!的递归缩写，因为GNU的设计类似Unix，但它不包含具著作权的Unix代码。GNU的创始人，理查德·马修·斯托曼，将GNU视为“达成社会目的技术方法”。</p>
<p>作为操作系统，GNU的发展仍未完成，其中最大的问题是具有完备功能的内核尚未被开发成功。GNU的内核，称为Hurd，是自由软件基金会发展的重点，但是其发展尚未成熟。在实际使用上，多半使用Linux内核、FreeBSD等替代方案，作为系统核心，其中主要的操作系统是Linux的发行版。Linux操作系统包涵了Linux内核与其他自由软件项目中的GNU组件和软件，可以被称为GNU/Linux。</p>
<p>GNU/Linux命名争议，是在自由及开放源代码软件社群成员内的，关于是应该把使用GNU软件与Linux内核组合之操作系统称为“GNU/Linux”还是“Linux”的争议。</p>
<p>GNU/Linux这一名称是由自由软件基金会的创立者与GNU计划的发起人理查德·斯托曼所提出的。GNU的开发者与其支持者，希望以该名称来作为此操作系统的正式名称。他们认为，此操作系统，包括了GNU系统软件包与Linux kernel，使用GNU/Linux这个名称，可以良好概括它的主要内容。况且，GNU项目原本就是以发展一个自由的操作系统为远程项目，但迟迟没有完成。而Linux kernel的出现刚好可以补足这个缺口。</p>
<p>Linux内核本身并不是GNU计划的一部分，GNU/Linux这个名称在Linux社群中并没有得到一致认同。一些发行版社群例如Debian采用了GNU/Linux这一名称，但许多Linux社群中的成员认为使用Linux这一名称是更好的，为此提出了数项理由，主张Linux这个名称朗朗上口，且在公众与媒体中更为通用。Linux内核项目的发起人林纳斯·托瓦兹（Linus Torvalds）偏好于使用Linux，但对于GNU/Linux这个名字并不强烈反感。</p>
<h1 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>linux/unix下的哲学核心思想是<strong>一切皆文件</strong>。它指的是，对所有文件（目录、字符设备、块设备、套接字、打印机、进程、线程、管道等）操作，读写都可用<code>fopen()/fclose()/fwrite()/fread()</code>等函数进行处理，屏蔽了硬件的区别，所有设备都抽象成文件，提供统一的接口给用户，虽然类型各不相同，但是对其提供的却是同一套操作界面，更进一步，对文件的操作也可以跨文件系统执行。</p>
<p>操作一个已经打开的文件：使用文件描述符（file descriptor），简称fd，它是一个对应某个已经打开的文件的索引（非负整数）。</p>
<p>Windows的内部实现也近似于“一切皆文件”的思想，当然，这一切都只在内核里才有，下载一个WinObj这软件就可以看到，Windows上各种设备、分区、虚拟对象都是挂载到根“\”下的，通过这个树可以访问各种设备、驱动、文件系统等。</p>
<p>Windows与Linux不同的就是把这些对象又重新封装了一层WindowsAPI，对外以设备、盘符、文件等等表现出来，重新封装WindowsAPI的目的是为了兼容性，而设备、盘符、文件这些是为了让普通用户更好理解。</p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p><img src="Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B.png" alt="Linux文件类型"></p>
<h1 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>inode是一个重要概念，是理解Unix/Linux文件系统和硬盘储存的基础。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>
<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<h2 id="inode的内容"><a href="#inode的内容" class="headerlink" title="inode的内容"></a>inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的User ID</li>
<li>文件的Group ID</li>
<li>文件的读、写、执行权限</li>
<li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li>
<li>链接数，即有多少文件名指向这个inode</li>
<li>文件数据block的位置</li>
</ul>
<p>可以用stat命令，查看某个文件的inode信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">stat</span> README.md</span></span><br><span class="line">  File: README.md</span><br><span class="line">  Size: 15              Blocks: 0          IO Block: 4096   regular file</span><br><span class="line">Device: fh/15d  Inode: 30680772461790950  Links: 1</span><br><span class="line">Access: (0777/-rwxrwxrwx)  Uid: ( 1000/ hearing)   Gid: ( 1000/ hearing)</span><br><span class="line">Access: 2019-08-16 20:56:58.121431000 +0800</span><br><span class="line">Modify: 2019-08-16 20:56:58.121431000 +0800</span><br><span class="line">Change: 2019-08-16 20:56:58.121431000 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>

<p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p>
<h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>
<p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>
<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用<code>df -i</code>命令。</p>
<p>查看每个inode节点的大小，可以用如下命令：<code>sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;</code></p>
<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>
<h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>
<p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>
<p>使用ls -i命令，可以看到文件名对应的inode号码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -i README.md</span></span><br><span class="line">30680772461790950 README.md</span><br></pre></td></tr></table></figure>

<h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>
<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls命令只列出目录文件中的所有文件名：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">HybridAccessory  README.md  _config.yml  db.json  gulpfile.js  node_modules  package-lock.json  package.json  scaffolds  source  themes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -i命令列出整个目录文件，即文件名和inode号码：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -i</span></span><br><span class="line">  281474976845551 HybridAccessory   5348024557503872 db.json         281474976858064 package-lock.json    281474976858853 source</span><br><span class="line">30680772461790950 README.md          281474976845560 gulpfile.js     281474976858065 package.json         281474976859117 themes</span><br><span class="line"> 1125899906905575 _config.yml        281474976845561 node_modules    281474976858849 scaffolds</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ls -l命令列出文件的详细信息：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 280</span><br><span class="line">drwxrwxrwx 1 hearing hearing   4096 Jul 22 14:06 HybridAccessory</span><br><span class="line">-rwxrwxrwx 1 hearing hearing     15 Aug 16 20:56 README.md</span><br><span class="line">-rwxrwxrwx 1 hearing hearing   2189 Aug 19 12:34 _config.yml</span><br><span class="line">-rwxrwxrwx 1 hearing hearing    174 Aug 27 17:55 db.json</span><br><span class="line">-rwxrwxrwx 1 hearing hearing   1596 Jul 22 14:06 gulpfile.js</span><br><span class="line">drwxrwxrwx 1 hearing hearing   4096 Jul 22 14:06 node_modules</span><br><span class="line">-rwxrwxrwx 1 hearing hearing 277830 Jul 22 14:06 package-lock.json</span><br><span class="line">-rwxrwxrwx 1 hearing hearing    686 Jul 22 14:06 package.json</span><br><span class="line">drwxrwxrwx 1 hearing hearing   4096 Jul 22 14:06 scaffolds</span><br><span class="line">drwxrwxrwx 1 hearing hearing   4096 Jul 29 11:35 source</span><br><span class="line">drwxrwxrwx 1 hearing hearing   4096 Aug 16 20:51 themes</span><br></pre></td></tr></table></figure>

<p>目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p>
<p>查看目录大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -h --max-depth=1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> du -h -d 1</span></span><br></pre></td></tr></table></figure>

<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p>
<p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p>
<p>ln命令可以创建硬链接：<code>ln 源文件 目标文件</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -li</span></span><br><span class="line">total 0</span><br><span class="line">16044073672577795 drwxrwxrwx 1 hearing hearing 4096 Aug 27 18:07 test</span><br><span class="line">14918173765727074 -rw-rw-rw- 1 hearing hearing    0 Aug 27 18:06 test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln test.txt test1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -li</span></span><br><span class="line">total 0</span><br><span class="line">16044073672577795 drwxrwxrwx 1 hearing hearing 4096 Aug 27 18:07 test</span><br><span class="line">14918173765727074 -rw-rw-rw- 2 hearing hearing    0 Aug 27 18:06 test.txt</span><br><span class="line">14918173765727074 -rw-rw-rw- 2 hearing hearing    0 Aug 27 18:06 test1</span><br></pre></td></tr></table></figure>

<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>
<p>创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -ai</span></span><br><span class="line"> 9570149208327005 .   1970324837227736 ..  16044073672577795 test   4785074604151560 test2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -i ../</span></span><br><span class="line"> 9570149208327005 Downloads</span><br></pre></td></tr></table></figure>

<p>目录不能创建硬链接（hard link not allowed for directory）。</p>
<h2 id="软链接-快捷方式"><a href="#软链接-快捷方式" class="headerlink" title="软链接(快捷方式)"></a>软链接(快捷方式)</h2><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p>
<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p>
<p>ln -s命令可以创建软链接：<code>ln -s 源文文件或目录 目标文件或目录</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ln -s test2 test1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 0</span><br><span class="line">drwxrwxrwx 1 hearing hearing 4096 Aug 27 18:07 test</span><br><span class="line">lrwxrwxrwx 1 hearing hearing    5 Aug 27 18:17 test1 -&gt; test2</span><br><span class="line">-rw-rw-rw- 1 hearing hearing    5 Aug 27 18:09 test2</span><br></pre></td></tr></table></figure>

<h2 id="inode的特殊作用"><a href="#inode的特殊作用" class="headerlink" title="inode的特殊作用"></a>inode的特殊作用</h2><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>
<ol>
<li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li>
<li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li>
<li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li>
</ol>
<p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>
<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</p>
<p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p>
<h2 id="文件描述符、文件、进程间的关系"><a href="#文件描述符、文件、进程间的关系" class="headerlink" title="文件描述符、文件、进程间的关系"></a>文件描述符、文件、进程间的关系</h2><p>1.描述：</p>
<ul>
<li>每个文件描述符会与一个打开的文件相对应</li>
<li>不同的文件描述符也可能指向同一个文件</li>
<li>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</li>
</ul>
<p>2.系统为维护文件描述符，建立了三个表</p>
<ul>
<li>进程级的文件描述符表</li>
<li>系统级的文件描述符表</li>
<li>文件系统的i-node表 </li>
</ul>
<img src="文件描述符.png"/>

<img src="三个表的关系.png"/>

<ul>
<li>在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（#23），这可能是该进程多次对执行打开操作</li>
<li>进程A中的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（#73），这种情况有几种可能，1.进程A和进程B可能是父子进程关系;2.进程A和进程B打开了同一个文件，且文件描述符相同（低概率事件=_=）；3.A、B中某个进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程。</li>
<li>进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（#1936），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了打开请求。同一个进程两次打开同一个文件，也会发生类似情况。</li>
</ul>
<h2 id="文件描述符限制"><a href="#文件描述符限制" class="headerlink" title="文件描述符限制"></a>文件描述符限制</h2><p>“文件描述符”也是一种资源，系统中的每个进程都需要有“文件描述符”才能进行一些操作。</p>
<img src="文件描述符限制.png"/>

<p>永久修改用户级限制时有三种设置类型：</p>
<ul>
<li>soft 指的是当前系统生效的设置值</li>
<li>hard 指的是系统中所能设定的最大值</li>
<li><code>-</code> 指的是同时设置了 soft 和 hard 的值</li>
</ul>
<h2 id="检查某个进程的文件描述符相关内容"><a href="#检查某个进程的文件描述符相关内容" class="headerlink" title="检查某个进程的文件描述符相关内容"></a>检查某个进程的文件描述符相关内容</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看指定进程的限制：在 Max open files 那一行，可以看到当前设置中最大文件描述符的数量为1024</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/803/limits</span></span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        0                    unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             8041                 8041                 processes</span><br><span class="line">Max open files            1024                 4096                 files</span><br><span class="line">Max locked memory         65536                65536                bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       8041                 8041                 signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         40                   40</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看该进程占用了多少个文件描述符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /proc/803/fd | wc -l</span></span><br><span class="line">5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ll /proc/803/fd</span></span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 hearing hearing 0 Aug 27 20:14 0 -&gt; /dev/tty3</span><br><span class="line">lrwx------ 1 hearing hearing 0 Aug 27 20:14 1 -&gt; /dev/tty3</span><br><span class="line">lrwx------ 1 hearing hearing 0 Aug 27 20:14 10 -&gt; /dev/tty3</span><br><span class="line">lrwx------ 1 hearing hearing 0 Aug 27 20:14 2 -&gt; /dev/tty3</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际应用过程中，如果出现“Too many open files” , 可以通过增大进程可用的文件描述符数量来解决，但往往故事不会这样结束，很多时候，并不是因为进程可用的文件描述符过少，而是因为程序bug，打开了大量的文件连接（web连接也会占用文件描述符）而没有释放。程序申请的资源在用完后及时释放，才是解决“Too many open files”的根本之道。</p>
<h1 id="证书-amp-CA"><a href="#证书-amp-CA" class="headerlink" title="证书&amp;CA"></a>证书&amp;CA</h1><ul>
<li>证书（“digital certificate”或“public key certificate”）：它是用来证明某某东西确实是某某东西的东西</li>
<li>CA（Certificate Authority）：证书授权中心，负责管理和签发证书的第三方机构</li>
<li>CA 证书：就是CA颁发的证书</li>
</ul>
<h1 id="apt-amp-dpkg"><a href="#apt-amp-dpkg" class="headerlink" title="apt&amp;dpkg"></a>apt&amp;dpkg</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>在Linux平台下使用源代码进行软件编译可以具有定制化的设置，但对于Linux distribution的发行商来说，毕竟不是每个人都会进行源代码编译的，这个问题将会严重的影响linux平台上软件的发行与推广。</p>
<p>为了解决上述的问题，厂商先在他们的系统上面编译好了用户所需要的软件，然后将这个编译好并可执行的软件直接发布给用户安装。不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营：Debian 的”.deb”，和 Red Hat的”.rpm”。</p>
<h2 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>dpkg - package manager for Debian。dpkg是Debian的一个底层包管理工具，主要用于对已下载到本地和已安装的软件包进行管理。</p>
<p>通过dpkg的机制，Debian提供的软件就能够简单的安装起来，同时能提供安装后的软件信息，只要派生于Debian的其它Linux distributions大多使用dpkg这个机制来管理，包括B2D，Ubuntu，Deepin等。</p>
<h3 id="deb软件包名规则"><a href="#deb软件包名规则" class="headerlink" title="deb软件包名规则"></a>deb软件包名规则</h3><p>格式为：<code>Package_Version-Build_Architecture.deb</code>，如：nano_1.3.10-2_i386.deb：</p>
<ul>
<li>软件包名称(Package Name): nano</li>
<li>版本(Version Number):1.3.10</li>
<li>修订号(Build Number):2</li>
<li>平台(Architecture):i386</li>
</ul>
<h3 id="dpkg软件包相关文件"><a href="#dpkg软件包相关文件" class="headerlink" title="dpkg软件包相关文件"></a>dpkg软件包相关文件</h3><ul>
<li>/etc/dpkg/dpkg.cfg：dpkg包管理软件的配置文件【Configuration file with default options】</li>
<li>/var/log/dpkg.log：dpkg包管理软件的日志文件【Default log file (see /etc/dpkg/dpkg.cfg(5) and option –log)】</li>
<li>/var/lib/dpkg/available：存放系统所有安装过的软件包信息【List of available packages.】</li>
<li>/var/lib/dpkg/status：存放系统现在所有安装软件的状态信息</li>
<li>/var/lib/dpkg/info：记安装软件包控制目录的控制信息文件</li>
</ul>
<h3 id="dpkg数据库"><a href="#dpkg数据库" class="headerlink" title="dpkg数据库"></a>dpkg数据库</h3><p>dpkg 使用文本文件作为数据库来维护系统中软件，包括文件清单, 依赖关系, 软件状态, 等等详细的内容，通常在 /var/lib/dpkg 目录下。通常在 status 文件中存储软件状态和控制信息。在 info/ 目录下备份控制文件，并在其下的 .list 文件中记录安装文件清单，其下的 .mdasums 保存文件的 MD5 编码。</p>
<h3 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装软件包，必须是deb包的完整名称。（软件的安装可被拆分为两个对立的过程“解包”和“配置”）</span></span><br><span class="line">dpkg -i package-name.deb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> “解包”：解开软件包到系统目录但不配置,如果和-R一起使用，参数可以是一个目录</span></span><br><span class="line">dpkg --unpack package-name.deb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> “配置”：配置软件包</span></span><br><span class="line">dpkg --configure package-name.deb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出 deb 包的内容</span></span><br><span class="line">dpkg -c package-name.deb</span><br></pre></td></tr></table></figure>

<p>安装相关选项：</p>
<ul>
<li>-R：递归地指向特定目录的所有安装包，可以结合-i, -A, –install, –unpack 与 –avail一起使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --remove，移除软件包，但保留其配置文件</span></span><br><span class="line">dpkg -r package-name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --purge，清除软件包的所有文件（removes everything，including conffiles）</span></span><br><span class="line">dpkg -P package-name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --list, 查看系统中软件包名符合pattern模式的软件包</span></span><br><span class="line">dpkg -l package-name-pattern</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --listfiles, 查看package-name对应的软件包安装的文件及目录</span></span><br><span class="line">dpkg -L package-name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --print-avail, 显示包的具体信息</span></span><br><span class="line">dpkg -p package-name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --status, 查看package-name（已安装）对应的软件包信息</span></span><br><span class="line">dpkg -s package-name</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --search，从已经安装的软件包中查找包含filename的软件包名称 （Tip：也可使用子命令dpkg-query来进行查询操作）</span></span><br><span class="line">dpkg -S filename-search-pattern</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解包</span></span><br><span class="line">dpkg -X pkg.deb</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例：列出系统上安装的与dpkg相关的软件包</span></span><br><span class="line">dpkg -l \*dpkg*</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例：查看dpkg软件包安装到系统中的文件</span></span><br><span class="line">dpkg -L dpkg</span><br></pre></td></tr></table></figure>

<h2 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h2><h3 id="apt简介"><a href="#apt简介" class="headerlink" title="apt简介"></a>apt简介</h3><p>虽然我们在使用dpkg时，已经解决掉了软件安装过程中的大量问题，但是当依赖关系不满足时，仍然需要手动解决，而apt这个工具解决了这样的问题，linux distribution 先将软件放置到对应的服务器中，然后分析软件的依赖关系，并且记录下来，然后当客户端有安装软件需求时，通过清单列表与本地的dpkg以存在的软件数据相比较，就能从网络端获取所有需要的具有依赖属性的软件了。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Debian 采用集中式的软件仓库机制，将各式各样的软件包分门别类地存放在软件仓库中，进行有效地组织和管理。然后，将软件仓库置于许许多多的镜像服务器中，并保持基本一致。这样，所有的 Debian 用户随时都能获得最新版本的安装软件包。因此，对于用户，这些镜像服务器就是他们的软件源（Reposity）</p>
<p>然而，由于每位用户所处的网络环境不同，不可能随意地访问各镜像站点。为了能够有选择地访问，在 Debian 系统中，使用软件源配置文件/etc/apt/sources.list列出最合适访问的镜像站点地址。</p>
<p><code>apt udpate</code>过程：</p>
<ol>
<li>执行apt-get update</li>
<li>程序分析/etc/apt/sources.list</li>
<li>自动连网寻找list中对应的Packages/Sources/Release列表文件，如果有更新则下载之，存入/var/lib/apt/lists/目录</li>
<li>然后 apt-get install 相应的包，下载并安装。</li>
</ol>
<p>用户可以使用“apt-get update”命令刷新软件源，建立更新软件包列表。它会扫描每一个软件源服务器，并为该服务器所具有软件包资源建立索引文件，存放在本地的/var/lib/apt/lists/目录中。使用apt执行安装、更新操作时，都将依据这些索引文件，向软件源服务器申请资源。</p>
<h3 id="apt相关文件"><a href="#apt相关文件" class="headerlink" title="apt相关文件"></a>apt相关文件</h3><ul>
<li>var/lib/dpkg/available 文件的内容是软件包的描述信息, 该软件包括当前系统所使用的Debian 安装源中的所有软件包，其中包括当前系统中已安装的和未安装的软件包.</li>
<li>/etc/apt/sources.list 记录软件源的地址（当你执行 sudo apt-get install xxx 时，Ubuntu 就去这些站点下载软件包到本地并执行安装）</li>
<li>/var/cache/apt/archives 已经下载到的软件包都放在这里（用 apt-get install 安装软件时，软件包的临时存放路径）</li>
<li>/var/lib/apt/lists 使用apt-get update命令会从/etc/apt/sources.list中下载软件列表，并保存到该目录</li>
</ul>
<h3 id="创建apt软件源"><a href="#创建apt软件源" class="headerlink" title="创建apt软件源"></a>创建apt软件源</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>以下是我搭建的软件源目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">hearing/</span><br><span class="line">├── bootstraps</span><br><span class="line">│   ├── bootstrap-aarch64</span><br><span class="line">│   ├── bootstrap-aarch64.zip</span><br><span class="line">│   ├── bootstrap-arm.zip</span><br><span class="line">│   ├── bootstrap-i686.zip</span><br><span class="line">│   └── bootstrap-x86_64.zip</span><br><span class="line">├── repository</span><br><span class="line">│   ├── dists</span><br><span class="line">│   |    └── stable</span><br><span class="line">│   |       ├── InRelease</span><br><span class="line">│   |       ├── main</span><br><span class="line">│   |       │   ├── binary-aarch64</span><br><span class="line">│   |       │   │   └── Packages</span><br><span class="line">│   |       │   ├── binary-all</span><br><span class="line">│   |       │   │   └── Packages</span><br><span class="line">│   |       │   ├── binary-arm</span><br><span class="line">│   |       │   │   └── Packages</span><br><span class="line">│   |       │   ├── binary-i686</span><br><span class="line">│   |       │   │   └── Packages</span><br><span class="line">│   |       │   └── binary-x86_64</span><br><span class="line">│   |       │       └── Packages</span><br><span class="line">│   |       ├── Release</span><br><span class="line">|   |       ├── Release.gpg</span><br><span class="line">|   |       └── repo.asc</span><br><span class="line">│   └── pool</span><br><span class="line">│       ├── aarch64</span><br><span class="line">│       |   ├── xxx.deb</span><br><span class="line">│       ├── all</span><br><span class="line">│       |   ├── xxx.deb</span><br><span class="line">│       ├── arm</span><br><span class="line">│       |   ├── xxx.deb</span><br><span class="line">│       ├── i686</span><br><span class="line">│       |   ├── xxx.deb</span><br><span class="line">│       └── x86_64</span><br><span class="line">│           ├── xxx.deb</span><br><span class="line">└── tmp</span><br><span class="line">    ├── xxx.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>bootstraps目录下放的是最终编译成功的zip文件</li>
<li>repository是自己制作的软件仓库</li>
<li>tmp放置的是上一步编译中下载失败的一些依赖</li>
</ul>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>根据<code>https://wiki.debian.org/DebianRepository/Setup</code>中的说法，仓库分为两种，一种比较简单的是trivial archive，而另外一种复杂的仓库称为official archive。在一个official archive中，典型特征是顶层有个 dists 目录和 pool 目录。这样的好处是:</p>
<ul>
<li>将所有类型CPU的包列表(Packages或者Packages.gz文件)放在一个文件里面，这样每个机器要获取的包列表就比较小。</li>
<li>不同套件/不同CPU可共用的deb包（主要是那些 _all.deb）和源代码包，也只在 pool/all目录下存放一份。</li>
<li>源代码包(.dsc，orig.tar.xz)有路径存放，这样 dget / apt source 可以取到源代码包。</li>
</ul>
<p>对应的<code>/etc/apt/sources.list</code>配置如下:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://192.168.56.47:80/hearing/repository stable main</span><br></pre></td></tr></table></figure>

<p>配置软件源的格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb|deb-src uri distribution [component1] [component2] [...]</span><br></pre></td></tr></table></figure>

<h4 id="生成Packages"><a href="#生成Packages" class="headerlink" title="生成Packages"></a>生成Packages</h4><p>Packages文件包括每个deb包的位置，描述，版本等信息，生成命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg-scanpackages all/ /dev/null| gzip -9c &gt; dists/stable/main/binary-all/Packages.gz</span><br><span class="line">dpkg-scanpackages all/ /dev/null| &gt; dists/stable/main/binary-all/Packages</span><br></pre></td></tr></table></figure>

<h4 id="生成Release"><a href="#生成Release" class="headerlink" title="生成Release"></a>生成Release</h4><p>Release文件里面包含了 Packages 等文件的大小和校验和(包含MD5/SHA1/SHA256/SHA512 多种值)，如果这个文件里面所描述的 Packages 大小与校验和与实际读取到的文件不一致，apt 会拒绝这个仓库。生成命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-ftparchive release $dir &gt; Release</span><br></pre></td></tr></table></figure>

<h4 id="生成Release-gpg-和-InRelease-文件"><a href="#生成Release-gpg-和-InRelease-文件" class="headerlink" title="生成Release.gpg 和 InRelease 文件"></a>生成Release.gpg 和 InRelease 文件</h4><p>Release.gpg 是一个签名文件，随同 Release 一起出现的，比较老的客户端只认这两个文件，而 InRelease 是内嵌签名的（也就是说，将原来 Release 的内容和 Release.gpg 的内容揉到一起了，注意这里不是简单地拼到一起），新的客户端才支持这个这个文件，观察一下 Debian 和 Ubuntu 的仓库 ( <a target="_blank" rel="noopener" href="http://mirrors.ustc.edu.cn/debian/dists/jessie/">http://mirrors.ustc.edu.cn/debian/dists/jessie/</a>, <a target="_blank" rel="noopener" href="http://mirrors.ustc.edu.cn/ubuntu/dists/xenial/">http://mirrors.ustc.edu.cn/ubuntu/dists/xenial/</a> ) ，可以看到 Debian 的仓库只有 Release 和 Release.gpg 这两个文件，而 Ubuntu 仓库里面这三个文件都有。</p>
<p>如何生成这两个文件：</p>
<ul>
<li>生成自己的gpg key: <code>gpg --list-keys || gpg --gen-key</code></li>
<li>生成Release.gpg: <code>gpg --armor --detach-sign --sign -o Release.gpg Release</code></li>
<li>生成InRelease: <code>gpg --clearsign -o InRelease Release</code></li>
</ul>
<h4 id="导入公钥"><a href="#导入公钥" class="headerlink" title="导入公钥"></a>导入公钥</h4><p>当运行<code>apt update</code>的时候，会出现警告：<code>The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY 722D2AFAD8BAD548</code>。</p>
<p>也就是说 InRelease / Release.gpg 虽然签名了，但由于这个签名所用的公钥没有被接受，因此还是不能正常使用，有三种解决方法：</p>
<ol>
<li><p>服务端将公钥导出，然后提供给客户端导入：</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 导出</span></span><br><span class="line">gpg --export --armor 722D2AFAD8BAD548 -o my-repo.gpg-key.asc</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入</span></span><br><span class="line">sudo apt-key add my-repo.gpg-key.asc</span><br></pre></td></tr></table></figure></li>
<li><p>客户端在执行<code>apt update</code>的时候，添加<code>--allow-insecure-repositories</code>选项；在执行<code>apt install pkg</code>的时候，添加<code>--allow-unauthenticated</code>选项。</p>
</li>
<li><p>用户修改仓库的配置，改为<code>deb [trusted=yes] http://192.168.56.47:80/hearing/repository stable main</code></p>
</li>
</ol>
<h3 id="使用手册-1"><a href="#使用手册-1" class="headerlink" title="使用手册"></a>使用手册</h3><ol>
<li>apt-get update 更新源</li>
<li>apt-get dist-upgrade 升级系统到相应的发行版(根据 source.list 的配置)</li>
<li>apt-get upgrade 更新所有已经安装的软件包</li>
<li>apt-get install package_name 安装软件包(加上 –reinstall重新安装)，apt-get install package_name=version 安装指定版本的软件包</li>
<li>apt-get remove package_name 卸载一个已安装的软件包（保留配置文件）</li>
<li>apt-get purge package_name 移除软件包（删除配置信息）或apt-get –purge remove packagename</li>
<li>apt-get check 检查是否有损坏的依赖</li>
<li>apt-get autoclean：删除你已经删掉的软件（定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。可以使用apt-get<br>clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除）</li>
<li>apt-get clean 把安装的软件的备份也删除，不过这样不会影响软件的使用</li>
</ol>
<p>apt-cache对APT的程序包缓存执行各种操作。apt-cache不会操纵系统状态，但会提供操作以从包元数据中搜索并生成输出。</p>
<ol>
<li>apt-cache depends packagename 了解使用依赖</li>
<li>apt-cache rdepends packagename 是查看该包被哪些包依赖</li>
<li>apt-cache search packagename 搜索包</li>
<li>apt-cache show packagename 获取包的相关信息，如说明、大小、版本等</li>
<li>apt-cache showpkg packagename 显示软件包的大致信息</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">163</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
