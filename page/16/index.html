<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:type" content="website">
<meta property="og:title" content="苍耳的博客">
<meta property="og:url" content="http://yoursite.com/page/16/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="诗歌，宋词，后台，Android，Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/13/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">MongoDB学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-13 11:35:26" itemprop="dateCreated datePublished" datetime="2018-08-13T11:35:26+08:00">2018-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span id="/2018/08/13/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="MongoDB学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/08/13/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/08/13/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MongoDB是一个C++编写的基于分布式文件存储的数据库，是一个介于关系和非关系之间的数据库，当然也属于NoSQL的行列，存储方式和Redis类似，是json格式的kav-value存储方式，只是Redis是内存存储，而MongoDB是和普通的数据库目录一样存储在硬盘上。</p>
<p>配置文件：</p>
<pre><code>dbpath = /home/hearing/Software/mongodb/data/db
logpath = /home/hearing/Software/mongodb/log/mongodb.log
logappend = true
port = 27017</code></pre>
<p>启动：</p>
<ul>
<li>./bin/mongod -f conf/mongod.conf</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Redis学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-12 20:57:19" itemprop="dateCreated datePublished" datetime="2018-08-12T20:57:19+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span id="/2018/08/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Redis学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/08/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/08/12/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL（Not Only SQL）：非关系型数据库。有些数据的数据类型不需要固定的模式，无需多余操作就可以横向扩展。NoSQL无需为事先为要存储的数据建立字段，随时可以存储自定义的数据格式。</p>
<ul>
<li>KV键值对：Redis</li>
<li>文档型数据库：MongoDB</li>
<li>列存储数据库</li>
<li>图关系数据库</li>
</ul>
<h1 id="分布式数据库的CAP和BASE"><a href="#分布式数据库的CAP和BASE" class="headerlink" title="分布式数据库的CAP和BASE"></a>分布式数据库的CAP和BASE</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>一个Redis实例存在16个数据库，默认连接的是0号数据库，使用select num选择连接的数据库。</li>
<li>move key db：将某个key移动到某个数据库。</li>
<li>ping：返回PONG则连接成功</li>
<li>keys pattern</li>
<li>del key [key …]</li>
<li>exists key [key …]</li>
<li>type key</li>
<li>dbsize: 查看当前数据库key数量</li>
<li>flushdb</li>
<li>flushall</li>
</ul>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>set key value [EX seconds] [PX milliseconds] [NX|XX]</li>
<li>get key</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li>有排序的字符串集合，允许重复元素</li>
<li>llen list</li>
<li>lpush key value [value …]</li>
<li>rpush key value [value …]</li>
<li>lrange key start stop （从0开始）</li>
<li>lpop key</li>
<li>rpop key</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>无排序的字符串集合，不允许重复元素</li>
<li>sadd key member [member …]</li>
<li>smembers：获取所有元素</li>
<li>scard：获取集合中元素个数</li>
<li>spop key：随机出栈</li>
<li>smove key1 key2 key1中某个值：将key1中某个值移到key2</li>
<li>sismember：是否为set中的元素</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><ul>
<li>hset key field value</li>
<li>hget key field</li>
<li>hdel key field [field …]</li>
</ul>
<h2 id="sorted-set（Zset）"><a href="#sorted-set（Zset）" class="headerlink" title="sorted-set（Zset）"></a>sorted-set（Zset）</h2><ul>
<li>zadd key [NX|XX] [CH] [INCR] score member [score member …]</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul>
<li>multi：开始事务</li>
<li>discard:取消事务</li>
<li>exec：执行事务</li>
<li>watch key [key …]：如果事务开始前这些key被其他命令修改过，那么事务被打断</li>
<li>unwatch</li>
<li>正常执行</li>
<li>放弃事务</li>
<li>全体连坐：当某条命令不等执行EXEC便报错，则全部命令放弃执行。</li>
<li>冤头债主：当某条命令在EXEC后才报错，则只会影响它自己的执行。</li>
<li>Watch监控：执行了exec或unwatch后所有监控锁都会被清除。</li>
</ul>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB方式（Redis-DataBase）"><a href="#RDB方式（Redis-DataBase）" class="headerlink" title="RDB方式（Redis DataBase）"></a>RDB方式（Redis DataBase）</h2><ul>
<li>在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时直接将快照文件恢复到内存。</li>
<li>保存在dump.rdb文件中。</li>
<li>优势：只有一个文件，时间间隔的数据，可以归档为一个文件，方便压缩转移（就一个文件）</li>
<li>劣势：如果宕机，数据损失比较大，因为它是没一个时间段进行持久化操作的。也就是积攒的数据比较多，一旦懵逼，就彻底懵逼了。另外，fork的时候内存中的数据被克隆了一份，大致两倍的膨胀性。</li>
<li>默认打开。</li>
</ul>
<h2 id="AOF方式（Append-only-file）"><a href="#AOF方式（Append-only-file）" class="headerlink" title="AOF方式（Append only file）"></a>AOF方式（Append only file）</h2><ul>
<li>以日志的形式来记录每个写操作，不记录读操作，只能追加文件而不能修改，redis启动之初会根据日志来恢复。</li>
<li>保存在appendonly.aof文件中。</li>
<li>优势：即使宕机，也不会损失数据，也不会破坏原有日志文件，保证数据的安全性。</li>
<li>劣势：文件比rdb大，效率更低。</li>
<li>在redis.conf文件中，默认关闭。</li>
</ul>
<h1 id="主从复制，读写分离"><a href="#主从复制，读写分离" class="headerlink" title="主从复制，读写分离"></a>主从复制，读写分离</h1><ul>
<li><p>Master以写为主，Slave以读为主。</p>
</li>
<li><p>哨兵模式：</p>
<ol>
<li>6379带着6380和6381</li>
<li>conf文件所在目录下新建sentinel.conf文件（名字不能错）。</li>
<li>配置哨兵：在sentinel文件中填写：sentinel monitor 被监控数据库名字（自己起） 127.0.0.1 6379 1（1表示主机挂掉以后slave投票决定下一个master是谁）</li>
<li>启动哨兵：Reids-sentinel …/sentinel.conf。</li>
<li>若哨兵监控到master挂了，则投票使某个slave成为master（假设是6380），当6379重新启动后，它将成为6380的slave。</li>
</ol>
</li>
</ul>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>直接连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;刘家东&quot;</span>);</span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<p>连接池方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(<span class="number">30</span>);</span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line">jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction transaction = jedis.multi();</span><br><span class="line">transaction.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;11&quot;</span>);</span><br><span class="line">transaction.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">transaction.exec();</span><br></pre></td></tr></table></figure>

<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis_M = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">Jedis jedis_S = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6380</span>);</span><br><span class="line"></span><br><span class="line">jedis_S.slaveof(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">jedis_M.set(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;1122V2&quot;</span>);</span><br><span class="line">String result = jedis_S.get(<span class="string">&quot;class&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">                    JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    <span class="comment">//配置一个pool可分配多少个jedis实例，如果复制为-1则表示不限制。</span></span><br><span class="line">                    poolConfig.setMaxActive(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//控制一个pool最多有多少个状态为空闲的jedis实例</span></span><br><span class="line">                    poolConfig.setMaxIdle(<span class="number">32</span>);</span><br><span class="line">                    <span class="comment">//当borrow一个jedis实例时，最大的等待时间</span></span><br><span class="line">                    poolConfig.setMaxWait(<span class="number">100</span>*<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//获得一个jedis实例时是否检查连接可用，如果为true，则得到的所有jedis实例都是可用的</span></span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool,Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">            jedisPool.returnResourceObject(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Redisson是架设在Redis基础上的一个Java驻内存数据网格。</p>
<h2 id="Jedis和Redisson对比"><a href="#Jedis和Redisson对比" class="headerlink" title="Jedis和Redisson对比"></a>Jedis和Redisson对比</h2><ul>
<li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</li>
<li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li>
<li>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li>
<li>Jedis中的方法调用是比较底层的暴露的Redis的API，也即Jedis中的Java方法基本和Redis的API保持着一致，了解Redis的API，也就能熟练的使用Jedis。</li>
<li>Redisson中的方法则是进行比较高的抽象，每个方法调用可能进行了一个或多个Redis方法调用。</li>
<li>在分布式开发中，Redisson可提供更便捷的方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">数据结构学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-09 21:35:39" itemprop="dateCreated datePublished" datetime="2018-08-09T21:35:39+08:00">2018-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:58" itemprop="dateModified" datetime="2021-05-14T14:14:58+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
            </span>

          
            <span id="/2018/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> 创建一个空堆栈</span></span><br><span class="line"><span class="function">2. <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> 测试堆栈是否为空</span></span><br><span class="line"><span class="function">3. <span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> 移除堆栈顶部的对象，并作为此函数的值返回该对象</span></span><br><span class="line"><span class="function">4. <span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> 把项压入堆栈顶部</span></span><br><span class="line"><span class="function">5. <span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> 查看堆栈顶部的对象，但不从堆栈中移除它</span></span><br><span class="line"><span class="function">6. <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> 测试堆栈是否为空</span></span><br></pre></td></tr></table></figure>

<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">()</span> 增加一个元索，如果队列已满，则抛出一个 IIIegaISlabEepeplian 异常</span></span><br><span class="line"><span class="function">2. <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">()</span> 添加一个元素并返回<span class="keyword">true</span>，如果队列已满，则返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function">3. <span class="keyword">void</span> <span class="title">put</span><span class="params">()</span> 添加一个元素，如果队列满，则阻塞</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4. E <span class="title">remove</span><span class="params">()</span> 移除并返回队列头部的元素，如果队列为空，则抛出一个 NoSuchElementException 异常</span></span><br><span class="line"><span class="function">5. E <span class="title">poll</span><span class="params">()</span> 移除并返问队列头部的元素，如果队列为空，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function">6. E <span class="title">take</span><span class="params">()</span> 移除并返回队列头部的元素，如果队列为空，则阻塞</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">7. E <span class="title">element</span><span class="params">()</span> 返回队列头部的元素，如果队列为空，则抛出一个 NoSuchElementException 异常</span></span><br><span class="line"><span class="function">8. E <span class="title">peek</span><span class="params">()</span> 返回队列头部的元素，如果队列为空，则返回<span class="keyword">null</span></span></span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><strong>满二叉树</strong></p>
<p>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点，节点数为 <code>2^h-1</code>。</p>
<p><strong>完全二叉树</strong></p>
<p>若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。一棵完全二叉树的两棵子树，至少有一棵是满二叉树。</p>
<p><strong>大顶堆/小顶堆</strong></p>
<p>任一结点的值是其子树所有结点的最大值或最小值：</p>
<ol>
<li>最大值时，称为“最大堆”，也称大顶堆；</li>
<li>最小值时，称为“最小堆”，也称小顶堆；</li>
</ol>
<p><strong>二叉查找树</strong></p>
<p>也称为二叉搜索树、有序二叉树或排序二叉树，是指一棵空树或者具有下列性质的二叉树：</p>
<ul>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ul>
<p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(log n)。</p>
<p><strong>平衡二叉树</strong></p>
<p>空树或者左右两个子树的高度差绝对值不超过1且左右两个子树也都是平衡树。</p>
<p>当在二叉排序树中插入一个节点时，首先检查是否因插入而破坏了平衡，若破坏，则找出其中的最小不平衡二叉树，在保持二叉排序树特性的情况下，调整最小不平衡子树中节点之间的关系，以达到新的平衡。所谓最小不平衡子树，指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。</p>
<p>随着树的高度的增加，动态插入和删除的代价也随之增加。</p>
<h2 id="节点数"><a href="#节点数" class="headerlink" title="节点数"></a>节点数</h2><p><strong>普通二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: <code>O(N)</code></p>
<p><strong>满二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点数为 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度: <code>O(logN)</code></p>
<p><strong>完全二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode l = root, r = root;</span><br><span class="line">    <span class="comment">// 记录左、右子树的高度</span></span><br><span class="line">    <span class="keyword">int</span> hl = <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右子树的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为一棵完全二叉树的两棵子树，至少有一棵是满二叉树，因此时间复杂度: <code>O(logN*logN)</code> 而不是 <code>O(N*logN)</code>。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><table>
<thead>
<tr>
<th align="center">前序</th>
<th align="center">中</th>
<th align="center">左</th>
<th align="center">右</th>
</tr>
</thead>
<tbody><tr>
<td align="center">中序</td>
<td align="center">左</td>
<td align="center">中</td>
<td align="center">右</td>
</tr>
<tr>
<td align="center">后序</td>
<td align="center">左</td>
<td align="center">右</td>
<td align="center">中</td>
</tr>
</tbody></table>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><strong>递归算法</strong>：中序遍历的顺序为leftTree， root， rightTree，显然先遍历左子树，然后是根，最后右子树。中序遍历的递归算法自然也就出来了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inorder(node.left, result);</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        inorder(node.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)，其中 n 是二叉树的节点数，每一个节点恰好被遍历一次。</li>
<li>空间复杂度: O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<p><strong>非递归算法</strong>：按从左到右进行访问。先指针往左探寻到底，然后观察最后一个非空节点是否有右节点，若有，将该右节点作为新的探寻起点，再进行下一轮的探寻,需要使用stack来帮助缓存之前的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)，其中 n 是二叉树的节点数，每一个节点恰好被遍历一次。</li>
<li>空间复杂度: O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p><strong>递归算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    preOrder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        preOrder(node.left, result);</span><br><span class="line">        preOrder(node.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)，其中 n 是二叉树的节点数，每一个节点恰好被遍历一次。</li>
<li>空间复杂度: O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<p><strong>非递归算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)，其中 n 是二叉树的节点数，每一个节点恰好被遍历一次。</li>
<li>空间复杂度: O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><strong>递归算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    postOrder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrder(node.left, result);</span><br><span class="line">        postOrder(node.right, result);</span><br><span class="line">        result.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)，其中 n 是二叉树的节点数，每一个节点恰好被遍历一次。</li>
<li>空间复杂度: O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<p><strong>非递归算法</strong>：和之前中序和前序算法不同，后续遍历的root节点要最后才能被访问，因此，我们若想访问某节点，那么我们需要知道该节点的右节点是否已经被访问过。只有该节点的右节点为null，或者已被访问过，那么该节点才能被访问；否则需要先将右节点访问完。为了判断该节点的右节点是否已经被访问过，需另外设一个记录指针last来指示已经访问过的节点，如果之前访问过的节点last恰为该节点的右节点，说明其右子树已经访问完，应该访问该节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || node.right == last) &#123;</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            last = node;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)，其中 n 是二叉树的节点数，每一个节点恰好被遍历一次。</li>
<li>空间复杂度: O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>借助队列实现，且没有递归算法。初始时，根结点入队列；然后 while 循环判断队列不空时，弹出一个结点并访问它，并把它的孩子结点入队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">levelOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>排序算法大体可分为两种：</p>
<ul>
<li>比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。</li>
<li>非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。</li>
</ul>
<img src="比较排序复杂度.jpg">

<p>排序算法的稳定性:如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的.</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ol>
<li>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<img src="冒泡排序.gif">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个flag来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;         <span class="comment">// 每次最大元素就像气泡一样&quot;浮&quot;到数组的最后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> - j; i++) &#123; <span class="comment">// 依次比较相邻的两个元素,使较大的那个向后移</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;           <span class="comment">// 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</span></span><br><span class="line">                Swap(A, i, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="鸡尾酒排序-冒泡排序改进"><a href="#鸡尾酒排序-冒泡排序改进" class="headerlink" title="鸡尾酒排序(冒泡排序改进)"></a>鸡尾酒排序(冒泡排序改进)</h2><p>此算法与冒泡排序的不同处在于从低到高然后从高到低。</p>
<img src="鸡尾酒排序.gif">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;                            <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;   <span class="comment">// 前半轮,将最大元素放到后面</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(A, i, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--) &#123;  <span class="comment">// 后半轮,将最小元素放到前面</span></span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">                Swap(A, i - <span class="number">1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<img src="选择排序.gif">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)         <span class="comment">// i为已排序序列的末尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)     <span class="comment">// 未排序序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min])              <span class="comment">// 找出未排序序列中的最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(A, min, i);    <span class="comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="插入排序.gif">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 ------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)         <span class="comment">// 类似抓扑克牌排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;                  <span class="comment">// 拿在左手上的牌总是排序好的</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)    <span class="comment">// 将抓到的牌与手牌从右向左进行比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];            <span class="comment">// 如果该手牌比抓到的牌大，就将其右移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get; <span class="comment">// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分插入排序-插入排序"><a href="#二分插入排序-插入排序" class="headerlink" title="二分插入排序(插入排序)"></a>二分插入排序(插入排序)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n^2)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];                    <span class="comment">// 右手抓到一张扑克牌</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                    <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;                <span class="comment">// 手牌左右边界进行初始化</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; get)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[left] = get;                    <span class="comment">// 将抓到的牌插入手牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序-插入排序"><a href="#希尔排序-插入排序" class="headerlink" title="希尔排序(插入排序)"></a>希尔排序(插入排序)</h2><img src="希尔排序.gif">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- 根据步长序列的不同而不同。</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= n)                          <span class="comment">// 生成初始增量</span></span><br><span class="line">    &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - h;</span><br><span class="line">            <span class="keyword">int</span> get = A[i];</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; get)</span><br><span class="line">            &#123;</span><br><span class="line">                A[j + h] = A[j];</span><br><span class="line">                j = j - h;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + h] = get;</span><br><span class="line">        &#125;</span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;                    <span class="comment">// 递减增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的实现分为递归实现与非递归(迭代)实现。</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<img src="归并排序.gif">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个已排好序的数组[left...mid]和[mid+1...right]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left;   <span class="comment">// 前一数组的起始元素</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 后一数组的起始元素</span></span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        tmp[index++] = arr[i] &lt; arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        tmp[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        arr[left++] = tmp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 当待排序的序列长度为1时，递归开始回溯，进行merge操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(arr, left, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(arr, left, mid, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol>
<li>由输入的无序数组构造一个最大堆，作为初始的无序区</li>
<li>把堆顶元素（最大值）和堆尾元素互换</li>
<li>把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整</li>
<li>重复步骤2，直到堆的尺寸为1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(1)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapSize = buildHeap(arr); <span class="comment">// 建立一个最大堆</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">1</span>) &#123; <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></span><br><span class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建堆，时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heapSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i]向下进行堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;   <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;  <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="keyword">int</span> max = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; heapSize &amp;&amp; arr[left] &gt; arr[max]) &#123;</span><br><span class="line">        max = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[max]) &#123;</span><br><span class="line">        max = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">        swap(arr, i, max); <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></span><br><span class="line">        heapify(arr, max, heapSize); <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><img src="快速排序.gif">

<p>以第一个数字6作为基数，使用双指针i, j进行双向遍历：</p>
<ol>
<li>i从左往右寻找第一位大于基数（6）的数字，j从右往左寻找第一位小于基数（6）的数字；</li>
<li>找到后将两个数字进行交换。继续循环交换直到i&gt;=j结束循环；</li>
<li>最终指针i=j,此时交换基数和i(j)指向的数字即可将数组划分为小于基数（6）/基数（6）/大于基数（6）的三部分，即完成一趟快排；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 ------------ 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ---------- 不稳定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = patition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, index - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, index + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">patition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = arr[left];    <span class="comment">// 第一个数作为基准</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= key &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;  <span class="comment">// 从右往左找第一个小于基数的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt;= key &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, left, i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><ol>
<li>统计数组A中每个值A[i]出现的次数，存入C[A[i]]</li>
<li>从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就变成了代表数组A中小于等于A[i]的元素个数</li>
<li>反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]个位置（下标为C[A[i]] - 1），每放一个元素就将C[A[i]]递减</li>
</ol>
<img src="计数排序.gif">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 ------------ 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n + k)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + k)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">100</span>;   <span class="comment">// 基数为100，排序[0,99]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];            <span class="comment">// 计数数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)   <span class="comment">// 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 使C[i]保存着等于i的元素个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[A[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)   <span class="comment">// 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">// 分配临时空间,长度为n，用来暂存中间数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)    <span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        B[--C[A[i]]] = A[i];      <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                  <span class="comment">// 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)   <span class="comment">// 把临时空间B中的数据拷贝回A</span></span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);    <span class="comment">// 释放临时空间 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><img src="基数排序.jpg">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n * dn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n * dn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dn = <span class="number">3</span>;                <span class="comment">// 待排序的元素为三位数及以下</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = <span class="number">10</span>;                <span class="comment">// 基数为10，每一位的数字都是[0,9]内的整数</span></span><br><span class="line"><span class="keyword">int</span> C[k];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span>          <span class="comment">// 获得元素x的第d位数字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix[] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span> &#125;;<span class="comment">// 最大为三位数，所以这里只要到百位就满足了</span></span><br><span class="line">    <span class="keyword">return</span> (x / radix[d]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n, <span class="keyword">int</span> d)</span><span class="comment">// 依据元素的第d位数字，对A数组进行计数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[GetDigit(A[i], d)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dight = GetDigit(A[i], d);  <span class="comment">// 元素A[i]当前位数字为dight   </span></span><br><span class="line">        B[--C[dight]] = A[i];           <span class="comment">// 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">        <span class="comment">// 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LsdRadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>     <span class="comment">// 最低位优先基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= dn; d++)     <span class="comment">// 从低位到高位</span></span><br><span class="line">        CountingSort(A, n, d);        <span class="comment">// 依据第d位数字对A进行计数排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">20</span>, <span class="number">90</span>, <span class="number">64</span>, <span class="number">289</span>, <span class="number">998</span>, <span class="number">365</span>, <span class="number">852</span>, <span class="number">123</span>, <span class="number">789</span>, <span class="number">456</span> &#125;;<span class="comment">// 针对基数排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    LsdRadixSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;基数排序结果：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。</p>
<img src="桶排序.jpg">

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分类 ------------- 内部非比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 --------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(n)，每个元素占一个桶</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n + bn)</span></span><br><span class="line"><span class="comment">// 稳定性 ----------- 稳定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本程序用数组模拟桶 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bn = <span class="number">5</span>;    <span class="comment">// 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量</span></span><br><span class="line"><span class="keyword">int</span> C[bn];           <span class="comment">// 计数数组，存放桶的边界信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++)  <span class="comment">// 从第二张牌开始抓，直到最后一张牌</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> get = A[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; A[j] &gt; get)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j + <span class="number">1</span>] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MapToBucket</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">10</span>;    <span class="comment">// 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)     <span class="comment">// 使C[i]保存着i号桶中元素的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[MapToBucket(A[i])]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; bn; i++)    <span class="comment">// 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] = C[i] + C[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((n) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b = MapToBucket(A[i]);  <span class="comment">// 元素A[i]位于b号桶</span></span><br><span class="line">        B[--C[b]] = A[i];           <span class="comment">// 把每个元素A[i]放到它在输出数组B中的正确位置上</span></span><br><span class="line">                                    <span class="comment">// 桶的边界被更新：C[b]为b号桶第一个元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CountingSort(A, n);          <span class="comment">// 利用计数排序确定各个桶的边界（分桶）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; i++) <span class="comment">// 对每一个桶中的元素应用插入排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = C[i];         <span class="comment">// C[i]为i号桶第一个元素的位置</span></span><br><span class="line">        <span class="keyword">int</span> right = (i == bn - <span class="number">1</span> ? n - <span class="number">1</span> : C[i + <span class="number">1</span>] - <span class="number">1</span>);<span class="comment">// C[i+1]-1为i号桶最后一个元素的位置</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)        <span class="comment">// 对元素个数大于1的桶进行桶内插入排序</span></span><br><span class="line">            InsertionSort(A, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">29</span>, <span class="number">25</span>, <span class="number">3</span>, <span class="number">49</span>, <span class="number">9</span>, <span class="number">37</span>, <span class="number">21</span>, <span class="number">43</span> &#125;;<span class="comment">// 针对桶排序设计的输入</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    BucketSort(A, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;桶排序结果：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><p>Java 中ArrayList和Collections的sort方法都是调用了Arrays.sort()方法,对于基础类型的排序,使用了更为高效的快速排序(不稳定).而对于非基础类型,在jdk1.8之前使用了归并排序,后来弃用,使用了TimSort.sort()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="comment">// Android-changed: LegacyMergeSort is no longer supported</span></span><br><span class="line">        <span class="comment">// if (LegacyMergeSort.userRequested)</span></span><br><span class="line">        <span class="comment">//     legacyMergeSort(a, fromIndex, toIndex, c);</span></span><br><span class="line">        <span class="comment">// else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>时间复杂度为O(n)。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)。折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找（折半查找），版本1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找，递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> BinarySearch2(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>查找成功或者失败的时间复杂度均为O(log2(log2n))。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> value, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> InsertionSearch(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。</p>
<p>斐波那契查找是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p>
<p>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>
<ol>
<li>相等，mid位置的元素即为所求</li>
<li>&gt;，low=mid+1,k-=2;<ul>
<li>说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= F(k)-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</li>
</ul>
</li>
<li>&lt;，high=mid-1,k-=1。<ul>
<li>说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归的应用斐波那契查找。</li>
</ul>
</li>
</ol>
<p>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</p>
<h2 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h2><h3 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h3><img src="二叉查找树.jpg"/>

<p>复杂度分析：</p>
<ul>
<li>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡</li>
</ul>
<p>二叉查找树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
</ol>
<p>二叉查找树性质：</p>
<ul>
<li>对二叉查找树进行中序遍历，即可得到有序的数列。</li>
</ul>
<h3 id="平衡查找树之2-3查找树"><a href="#平衡查找树之2-3查找树" class="headerlink" title="平衡查找树之2-3查找树"></a>平衡查找树之2-3查找树</h3><h3 id="平衡查找树之红黑树"><a href="#平衡查找树之红黑树" class="headerlink" title="平衡查找树之红黑树"></a>平衡查找树之红黑树</h3><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。</p>
<p>除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……</p>
<ol>
<li>先选取各块中的最大关键字构成一个索引表；</li>
<li>查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</li>
</ol>
<h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><p>算法思想：</p>
<ul>
<li>如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</li>
</ul>
<p>算法流程：</p>
<ol>
<li>用给定的哈希函数构造哈希表；</li>
<li>根据选择的冲突处理方法解决地址冲突；</li>
<li>在哈希表的基础上执行哈希查找。</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</li>
</ul>
<h1 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h1><p>贪心算法，分治算法，动态规划算法，随机划分算法，回溯算法等。</p>
<h1 id="Lru算法"><a href="#Lru算法" class="headerlink" title="Lru算法"></a>Lru算法</h1><p>参考 <a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/10/21/Java-Android-Collection/#LinkedHashMap">LinkedHashMap</a> 可知，LinkedHashMap 保存了记录的插入顺序，还可以在此基础上再根据访问顺序(get,put)来排序，可以用来实现 Lru 算法。它继承自 HashMap, 查看 HashMap 的 put 方法可知在 putVal 方法最后会调用 afterNodeInsertion 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 若 removeEldestEntry 返回 true 则删除第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此可以重写 removeEldestEntry() 方法，当 map 里面的元素个数大于缓存最大容量则删除链表的顶端元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruLinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    LruLinkedHashMap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="深度-广度优先"><a href="#深度-广度优先" class="headerlink" title="深度/广度优先"></a>深度/广度优先</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/Spring%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/31/Spring%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">Spring基础复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-31 09:37:43" itemprop="dateCreated datePublished" datetime="2018-07-31T09:37:43+08:00">2018-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/" itemprop="url" rel="index"><span itemprop="name">后台</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          
            <span id="/2018/07/31/Spring%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="Spring基础复习" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/07/31/Spring%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/07/31/Spring%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><ul>
<li>应用IOC和AOP机制,降低系统组件之间的耦合度,便于组件的维护扩展和替换。IOC特性可以降低action 和dao之间的关联,利用AOP进行事务管理或处理共通的部分程序已经做好了,其中一个需求发生改变,不需要大面积改变代码。spring相当于一个开发平台,在上面可以整合各种技术。</li>
<li>IOC:控制反转,控制权的转移,应用程序本身不负责依赖对象的创建和维护,而是由外部容器负责创建和维护。获得依赖对象的过程被反转了。</li>
<li>DI:依赖注入,IOC 的另一种表述。即组件以一些预定义好的方式(如 getter 方法)接受来自容器的注入。</li>
<li>Bean生命周期</li>
</ul>
<img src="Bean生命周期.jpg"/>

<pre><code>（1）BeanFactoryPostProcessor的postProcessorBeanFactory()方法：若某个IoC容器内添加了实现了BeanFactoryPostProcessor接口的实现类Bean，那么在该容器中实例化任何其他Bean之前可以回调该Bean中的postPrcessorBeanFactory()方法来对Bean的配置元数据进行更改，比如从XML配置文件中获取到的配置信息。

（2）Bean的实例化：Bean的实例化是使用反射实现的。

（3）Bean属性注入：Bean实例化完成后，利用反射技术实现属性及依赖Bean的注入。

（4）BeanNameAware的setBeanName()方法：如果某个Bean实现了BeanNameAware接口，那么Spring将会将Bean实例的ID传递给setBeanName()方法，在Bean类中新增一个beanName字段，并实现setBeanName()方法。

（5）BeanFactoryAware的setBeanFactory()方法：如果某个Bean实现了BeanFactoryAware接口，那么Spring将会将创建Bean的BeanFactory传递给setBeanFactory()方法，在Bean类中新增了一个beanFactory字段用来保存BeanFactory的值，并实现setBeanFactory()方法。

（6）ApplicationContextAware的setApplicationContext()方法：如果某个Bean实现了ApplicationContextAware接口，那么Spring将会将该Bean所在的上下文环境ApplicationContext传递给setApplicationContext()方法，在Bean类中新增一个ApplicationContext字段用来保存ApplicationContext的值，并实现setApplicationContext()方法。

（7）BeanPostProcessor预初始化方法：如果某个IoC容器中增加的实现BeanPostProcessor接口的实现类Bean，那么在该容器中实例化Bean之后，执行初始化之前会调用BeanPostProcessor中的postProcessBeforeInitialization()方法执行预初始化处理。

（8）InitializingBean的afterPropertiesSet()方法：如果Bean实现了InitializingBean接口，那么Bean在实例化完成后将会执行接口中的afterPropertiesSet()方法来进行初始化。

（9）自定义的inti-method指定的方法：如果配置文件中使用init-method属性指定了初始化方法，那么Bean在实例化完成后将会调用该属性指定的初始化方法进行Bean的初始化。

（10）BeanPostProcessor初始化后方法：如果某个IoC容器中增加的实现BeanPostProcessor接口的实现类Bean，那么在该容器中实例化Bean之后并且完成初始化调用后执行该接口中的postProcessorAfterInitialization()方法进行初始化后处理。

（11）使用Bean：此时有关Bean的所有准备工作均已完成，Bean可以被程序使用了，它们将会一直驻留在应用上下文中，直到该上下文环境被销毁。

（12）DisposableBean的destory()方法：如果Bean实现了DisposableBean接口，Spring将会在Bean实例销毁之前调用该接口的destory()方法，来完成一些销毁之前的处理工作。

（13）自定义的destory-method指定的方法：如果在配置文件中使用destory-method指定了销毁方法，那么在Bean实例销毁之前会调用该指定的方法完成一些销毁之前的处理工作。


1、BeanFactoryPostProcessor接口与BeanPostProcessor接口的作用范围是整个上下文环境中，使用方法是单独新增一个类来实现这些接口，那么在处理其他Bean的某些时刻就会回调响应的接口中的方法。

2、BeanNameAware、BeanFactoryAware、ApplicationContextAware的作用范围的Bean范围，即仅仅对实现了该接口的指定Bean有效，所有其使用方法是在要使用该功能的Bean自己来实现该接口。

3、第8点与第9点所述的两个初始化方法作用是一样的，我们完全可以使用其中的一种即可，一般情况我们使用第9点所述的方式，尽量少的去来Bean中实现某些接口，保持其独立性，低耦合性，尽量不要与Spring代码耦合在一起。第12和第13也是如此。</code></pre>
<ul>
<li><p>applicationConfig.ml 中使用反射方式在 IOC 容器中创建 Bean。</p>
</li>
<li><p>AOP:面向切面编程,通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。主要功能是:日志记录,性能统计,安全控制,事务处理,异常处理等。</p>
</li>
<li><p>AOP实现方法：1.动态代理。2.AspectJ</p>
</li>
<li><p>使用@RequestMapping 注解映射请求的 URL。可以修饰类和方法。</p>
</li>
<li><p>@PathVariable 将占位符参数绑定到控制器处理方法的入参中。</p>
</li>
<li><p>@RequestParam 映射请求参数</p>
</li>
<li><p>@RequestHeader 映射请求头信息</p>
</li>
<li><p>POJO 作为处理方法的参数: Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配,支持级联属性。</p>
</li>
<li><p>Session和Cookie的区别</p>
<ul>
<li>在服务器端保存用户信息：在客户端保存用户信息</li>
<li>Session中保存的是Object类型：在Cookie中保存的是String类型</li>
<li>随对话的结束而将其存储的数据销毁，重启浏览器Session 会失效,可以利用 Cookie 将 Session 持久化：Cookie可以长期保存在客户端</li>
<li>保存重要的信息：保存不重要的信息</li>
</ul>
</li>
<li><p>ModelAndView</p>
</li>
<li><p>重定向：response.sendRedirect()，本质上相当于两次请求，地址栏的URL会变。</p>
</li>
<li><p>请求转发：request.getRequestDispatch().forward(req, resp)，是一次请求，转发后请求对象会保存，地址栏URL不会变。</p>
</li>
<li><p>MyBatis正向工程：</p>
<ol>
<li>导包</li>
<li>Spring全局配置文件</li>
<li>写接口，接口不用实现（代理），与sql映射文件中的一句sql对应</li>
<li>写sql映射文件</li>
<li>获取使用</li>
</ol>
</li>
<li><p>MyBatis逆向工程</p>
<ol>
<li>导包</li>
<li>Spring全局配置文件</li>
<li>建立数据库表</li>
<li>逆向工程配置文件</li>
<li>代码中运行该配置文件，生成接口和sql映射文件</li>
<li>获取使用</li>
</ol>
</li>
<li><p>MyBatis缓存</p>
<ul>
<li>一级缓存：SqlSession级别的缓存，一直开启。与数据库同一次会话期间查询到的数据会放在本地缓存中，以后可以直接从缓存取。两次相同查询期间执行了增删改操作，则缓存会失效。</li>
<li>二级缓存（全局缓存）：基于namespace级别的缓存，一个namespace对应一个二级缓存。不同namespace（Mapper）对应的缓存放在自己的map中。只有关闭了会话后，数据才会从一级缓存存入二级缓存中。</li>
</ul>
</li>
<li><p>EhCache是进程内的缓存框架，在集群模式下时，各应用服务器之间的缓存都是独立的，因此在不同服务器的进程间会存在缓存不一致的情况。即使EhCache提供了集群环境下的缓存同步策略，但是同步依然需要一定的时间，短暂的缓存不一致依然存在。在一些要求高一致性（任何数据变化都能及时的被查询到）的系统和应用中，需要使用集中式缓存，比如Redis。</p>
</li>
<li><p>JPA：JPA全称为Java Persistence API，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。使用JPA持久化对象，并不是依赖于某一个ORM框架。</p>
</li>
<li><p>SpringData Repository<br>  Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法.</p>
<p>  public interface Repository&lt;T, ID extends Serializable&gt; { } </p>
<p>  Spring Data可以让我们只定义接口，只要遵循 Spring Data的规范，就无需写实现类。Repository是一个空接口，即一个标记接口，会被IOC容器识别为一个Repository Bean纳入到IOC容器中，进而可以在该接口中定义满足一定规范的方法。</p>
<p>  基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下： </p>
<ul>
<li>Repository： 仅仅是一个标识，表明任何继承它的均为仓库接口类</li>
<li>CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法 </li>
<li>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法 </li>
<li>JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 </li>
<li>自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。</li>
<li>JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法 </li>
</ul>
</li>
<li><p>ORM框架</p>
<p>  Object Relational Mapping，对象-关系映射。项目中的业务实体有两种表现形式：对象和关系数据，即在内存中表现为对象，在数据库中表现为关系数据。</p>
<ul>
<li><p>为什么需要ORM框架</p>
<p>因为对象之间可以存在关联和继承关系，但是在数据库中，关系数据无法表达多对多关联和继承关系。（ps：在数据库原理中，会把逻辑上的多对多转换为多个一对关系才能实现）因此，对象和关系（业务实体的两种表现形式）想要映射正确，项目系统一般以中间件的形式，即持久层框架。</p>
</li>
</ul>
</li>
<li><p>Hibernate的特点</p>
<ul>
<li>Hibernate通过修改一个“持久化”对象的属性，从而修改数据库表中对应的记录数据</li>
<li>提供线程和进程两个级别的缓存提升应用程序性能</li>
<li>有丰富的映射方式将Java对象之间的关系（POJO）转换为数据库表之间的关系</li>
<li>屏蔽不同数据库实现之间的差异。在Hibernate中只需通过“方言”的形式指定当前使用的数据库，就可以根据底层数据库的实际情况生成适合的SQL语句</li>
<li>非侵入式。Hibernate不要求持久化类实现任何接口或继承任何类，POJO即可</li>
</ul>
</li>
<li><p>Mybaits的特点：</p>
<ul>
<li>简单易学。没有任何第三方依赖，最简单只需要2个jar包+几个sql映射文件，通过文档和源代码，即可比较完全的掌握它的设计思路和实现</li>
<li>灵活。不会对应用程序或者数据库的现有设计强加任何影响。Sql写在xml里面，便于统一管理和优化。通过sql基本上可以实现我们不使用数据访问框架可以实现的所有功能。</li>
<li>解除sql与程序代码的耦合。通过提供DAL层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li>Hibernate 对数据库提供了较为完整的封装,封装了基本的DAO层操作,有较好的数据库移植性</li>
<li>Mybatis 可以进行更细致的SQL优化,查询必要的字段,但是需要维护SQL和查询结果集的映射,而且数据库的移植性较差,针对不同的数据库编写不同的SQL,</li>
<li>Spring Data JPA 极大的简化了数据库访问,可以通过命名规范、注解的方式较快的编写SQL。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/27/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/27/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C-学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-27 17:11:00" itemprop="dateCreated datePublished" datetime="2018-07-27T17:11:00+08:00">2018-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          
            <span id="/2018/07/27/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="C-学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/07/27/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/07/27/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cc = gcc</span><br><span class="line">prom = multisum</span><br><span class="line">deps = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.h&quot;)</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.c&quot;)</span></span><br><span class="line">obj = $(src:%.c=%.o)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	<span class="variable">$(cc)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span> -lpthread</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(deps)</span></span></span><br><span class="line">	<span class="variable">$(cc)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(obj)</span> <span class="variable">$(prom)</span></span><br></pre></td></tr></table></figure>

<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is a pthread.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> id;</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    ret = pthread_create(&amp;id, <span class="literal">NULL</span>, (<span class="keyword">void</span> *) thread, <span class="literal">NULL</span>); <span class="comment">// 成功返回0，错误返回错误编号</span></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Create pthread error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the main process.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pthread_t id:</p>
</li>
<li><p>int pthread_create(&amp;id, NULL, (void *) thread, (void *)arg):</p>
<ol>
<li>第一个参数为指向线程标识符的指针，第二个参数用来设置线程属性，第三个参数是线程运行函数的起始地址，最后一个参数是运行函数的参数。当创建线程成功时，函数返回0，若不为0则说明创建线程失败，常见的错误返回代码为EAGAIN和EINVAL。前者表示系统限制创建新的线程，例如线程数目过多了；后者表示第二个参数代表的线程属性值非法。创建线程成功后，新创建的线程则运行参数三和参数四确定的函数，原来的线程则继续运行下一行代码。</li>
<li>多个参数:必须申明一个结构体来包含所有的参数，然后再传入线程函数。</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">parameter</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> size,</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在main函数将这个结构体指针，作为void *形参的实际参数传递</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">parameter</span> <span class="title">arg</span>;</span></span><br><span class="line">pthread_create(&amp;ntid, <span class="literal">NULL</span>, fn,&amp; (arg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数中需要定义一个parameter类型的结构指针来引用这个参数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">parameter</span> *<span class="title">pstru</span>;</span></span><br><span class="line">    pstru = ( struct parameter *) arg;</span><br><span class="line">    <span class="comment">// 然后在这个函数中就可以使用指针来使用相应的变量的值了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int pthread_join(id, NULL);</p>
<p>  函数pthread_join用来等待一个线程的结束。第一个参数为被等待的线程标识符，第二个参数为一个用户定义的指针，它可以用来存储被等待线程的返回值。这个函数是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。一个线程的结束有两种途径，一种是像上面的例子一样，函数结束了，调用它的线程也就结束了；另一种方式是通过函数pthread_exit来实现。</p>
</li>
<li><p>void pthread_exit(arg);</p>
<p>  唯一的参数是函数的返回代码，只要pthread_join中的第二个参数thread_return不是NULL，这个值将被传递给thread_return。</p>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><p>在主线程中初始化锁为解锁状态</p>
<p>  pthread_mutex_t mutex;<br>  pthread_mutex_init(&amp;mutex, NULL);</p>
</li>
<li><p>在编译时初始化锁为解锁状态</p>
<p>  锁初始化 pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p>
</li>
<li><p>访问对象时的加锁操作与解锁操作</p>
<p>  加锁 pthread_mutex_lock(&amp;mutex)<br>  释放锁 pthread_mutex_unlock(&amp;mutex)</p>
</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量本质上是一个非负数的整数计数器，它也被用来控制对公共资源的访问。当公共资源增加的时候，调用信号量增加函数sem_post()对其进行增加，当公共资源减少的时候，调用函数sem_wait()来减少信号量。其实，我们是可以把锁当作一个0-1信号量的。</p>
<p>在使用semaphore之前，需要先引入头文件semaphore.h</p>
<ul>
<li><p>初始化信号量： int sem_init(sem_t *sem, int pshared, unsigned int value);</p>
<ul>
<li>成功返回0，失败返回-1</li>
<li>sem：指向信号量结构的一个指针</li>
<li>pshared： 不是0的时候，该信号量在进程间共享，否则只能为当前进程的所有线程们共享</li>
<li>value：信号量的初始值</li>
</ul>
</li>
<li><p>信号量减1操作，当sem=0的时候该函数会堵塞 int sem_wait(sem_t *sem);</p>
<ul>
<li>成功返回0，失败返回-1</li>
<li>参数</li>
<li>sem：指向信号量的一个指针</li>
</ul>
</li>
<li><p>信号量加1操作 int sem_post(sem_t *sem);</p>
<ul>
<li>参数与返回同上</li>
</ul>
</li>
<li><p>销毁信号量 int sem_destroy(sem_t *sem);</p>
<ul>
<li>参数与返回同上</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">provide_data</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; MAXSIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">stack</span>[i] = i;</span><br><span class="line">        sem_post(&amp;sem); <span class="comment">//为信号量加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_data</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>((i = size++) &lt; MAXSIZE) &#123;</span><br><span class="line">        sem_wait(&amp;sem);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;乘法: %d X %d = %d\n&quot;</span>, <span class="built_in">stack</span>[i], <span class="built_in">stack</span>[i], <span class="built_in">stack</span>[i]*<span class="built_in">stack</span>[i]);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> provider, handler;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;sem, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//信号量初始化</span></span><br><span class="line">    pthread_create(&amp;provider, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)handle_data, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;handler, <span class="literal">NULL</span>, (<span class="keyword">void</span> *)provide_data, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(provider, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(handler, <span class="literal">NULL</span>);</span><br><span class="line">    sem_destroy(&amp;sem); <span class="comment">//销毁信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> M = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> *fileInput = <span class="string">&quot;input.txt&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> *fileOutput = <span class="string">&quot;output.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *pFile = fopen(fileInput, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fseek(pFile, <span class="number">2</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="number">20</span>, pFile) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            N = atoi(line);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fseek(pFile, ftell(pFile)+<span class="number">2</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="number">20</span>, pFile) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            M = atol(line);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOutput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *pFile = fopen(fileOutput, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">&quot;%ld&quot;</span>, sum);</span><br><span class="line">        fclose(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (count &lt;= M) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        sum += count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the thread result = %ld\n&quot;</span>, sum);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    </span><br><span class="line">    getInput();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N = %d\n&quot;</span>, N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;M = %ld\n&quot;</span>, M);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ret = pthread_create(&amp;thread[i], <span class="literal">NULL</span>, (<span class="keyword">void</span> *)threadSum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;create pthread-%d error!\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pthread_join(thread[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setOutput();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the final result = %ld\n&quot;</span>, sum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the tatol time = %ld\n&quot;</span>, clock()-start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>fork（）会产生一个和父进程完全相同的子进程，可以认为fork后，这两个相同的虚拟地址指向的是不同的物理地址。但实际上，Linux为了提高 fork 的效率，采用了 copy-on-write 技术（写时复制），fork后，这两个虚拟地址实际上指向相同的物理地址（内存页），只有任何一个进程试图修改这个虚拟地址里的内容前，两个虚拟地址才会指向不同的物理地址（新的物理地址的内容从原物理地址中复制得到）。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shm_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><ul>
<li>信号量（PV）</li>
<li>管程</li>
</ul>
<ol>
<li><p>#include &lt;semaphore.h&gt;</p>
</li>
<li><p>sem_init函数 </p>
<ul>
<li>函数作用：初始化信号量 </li>
<li>函数原型：int sem_init(sem_t *sem,int pshared, unsigned int value) </li>
<li>参数：sem：信号量指针 </li>
<li>Pshared：决定信号量能否在几个进程间共享，一般取0 </li>
<li>Value：信号量的初始值 </li>
</ul>
</li>
<li><p>信号的操作</p>
<ul>
<li>int sem_wait(sem_t *sem);    P操作   </li>
<li>int sem_try_wait(sem_t *sem);</li>
<li>int sempost(sem_t *sem);    V操作</li>
<li>int sem_getvalue(sem_t *sem);</li>
<li>int sem_destroy(sem_t *sem);    销毁信号</li>
</ul>
</li>
</ol>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERM S_IRUSR|S_IWUSR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> M = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> *fileInput = <span class="string">&quot;input.txt&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> *fileOutput = <span class="string">&quot;output.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">sem_t</span> S;</span><br><span class="line">&#125; Process;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *pFile = fopen(fileInput, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fseek(pFile, <span class="number">2</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="number">20</span>, pFile) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            N = atoi(line);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        fseek(pFile, ftell(pFile)+<span class="number">2</span>, SEEK_SET);</span><br><span class="line">        <span class="keyword">if</span> (fgets(line, <span class="number">20</span>, pFile) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            M = atol(line);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOutput</span><span class="params">(<span class="keyword">long</span> result)</span> </span>&#123;</span><br><span class="line">    FILE *pFile = fopen(fileOutput, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(pFile,<span class="string">&quot;%ld&quot;</span>, result);</span><br><span class="line">        fclose(pFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    </span><br><span class="line">    getInput();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N = %d\n&quot;</span>, N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;M = %ld\n&quot;</span>, M);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shm_id;</span><br><span class="line">    Process *pProcess;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((shm_id = shmget(IPC_PRIVATE, <span class="keyword">sizeof</span>(Process), PERM)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create Share Memory Error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pProcess = (Process *)shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    pProcess-&gt;sum = <span class="number">0</span>;</span><br><span class="line">    pProcess-&gt;count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;pProcess-&gt;S, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        pid =fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span> || pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fork!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pProcess-&gt;count &lt;= M) &#123;</span><br><span class="line">            sem_wait(&amp;pProcess-&gt;S);</span><br><span class="line">            pProcess-&gt;sum += pProcess-&gt;count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the process result = %ld\n&quot;</span>, pProcess-&gt;sum);</span><br><span class="line">            sem_post(&amp;pProcess-&gt;S);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line"></span><br><span class="line">        sem_destroy(&amp;pProcess-&gt;S);</span><br><span class="line">        setOutput(pProcess-&gt;sum);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the final result = %ld\n&quot;</span>, pProcess-&gt;sum);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the tatol time = %ld\n&quot;</span>, clock()-start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/26/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">shell学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-26 09:29:48" itemprop="dateCreated datePublished" datetime="2018-07-26T09:29:48+08:00">2018-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2018/07/26/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="shell学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/07/26/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/07/26/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -h --max-depth=1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> du -h -d 1</span></span><br></pre></td></tr></table></figure>

<h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h2><p>ulimit命令用来限制系统用户对shell资源的访问。</p>
<p>假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。</p>
<p>而实际应用的环境要比这种假设复杂的多，例如在一个嵌入式开发环境中，各方面的资源都是非常紧缺的，对于开启文件描述符的数量，分配堆栈的大小，CPU 时间，虚拟内存大小，等等，都有非常严格的要求。资源的合理限制和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。这时，ulimit可以起到很大的作用，它是一种简单并且有效的实现资源限制的方式。</p>
<p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p>
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。</p>
<ul>
<li><p>语法</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit option</span><br></pre></td></tr></table></figure>
</li>
<li><p>选项</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-a：显示目前资源限制的设定；</span><br><span class="line">-c &lt;core文件上限&gt;：设定core文件的最大值，单位为区块；</span><br><span class="line">-d &lt;数据节区大小&gt;：程序数据节区的最大值，单位为KB；</span><br><span class="line">-f &lt;文件大小&gt;：shell所能建立的最大文件，单位为区块；</span><br><span class="line">-H：设定资源的硬性限制，也就是管理员所设下的限制；</span><br><span class="line">-m &lt;内存大小&gt;：指定可使用内存的上限，单位为KB；</span><br><span class="line">-n &lt;文件数目&gt;：指定同一时间最多可开启的文件数；</span><br><span class="line">-p &lt;缓冲区大小&gt;：指定管道缓冲区的大小，单位512字节；</span><br><span class="line">-s &lt;堆叠大小&gt;：指定堆叠的上限，单位为KB；</span><br><span class="line">-S：设定资源的弹性限制；</span><br><span class="line">-t &lt;CPU时间&gt;：指定CPU使用时间的上限，单位为秒；</span><br><span class="line">-u &lt;程序数目&gt;：用户最多可开启的程序数目；</span><br><span class="line">-v &lt;虚拟内存大小&gt;：指定可使用的虚拟内存上限，单位为KB。</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0           #core文件的最大值为100 blocks。</span><br><span class="line">data seg size           (kbytes, -d) unlimited   #进程的数据段可以任意大。</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited   #文件可以任意大。</span><br><span class="line">pending signals                 (-i) 98304       #最多有98304个待处理的信号。</span><br><span class="line">max locked memory       (kbytes, -l) 32          #一个任务锁住的物理内存的最大值为32KB。</span><br><span class="line">max memory size         (kbytes, -m) unlimited   #一个任务的常驻物理内存的最大值。</span><br><span class="line">open files                      (-n) 1024        #一个任务最多可以同时打开1024的文件。</span><br><span class="line">pipe size            (512 bytes, -p) 8           #管道的最大空间为4096字节。</span><br><span class="line">POSIX message queues     (bytes, -q) 819200      #POSIX的消息队列的最大值为819200字节。</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 10240       #进程的栈的最大值为10240字节。</span><br><span class="line">cpu time               (seconds, -t) unlimited   #进程使用的CPU时间。</span><br><span class="line">max user processes              (-u) 98304       #当前用户同时打开的进程（包括线程）的最大个数为98304。</span><br><span class="line">virtual memory          (kbytes, -v) unlimited   #没有限制进程的最大地址空间。</span><br><span class="line">file locks                      (-x) unlimited   #所能锁住的文件的最大个数没有限制。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><h3 id="检查url有效性"><a href="#检查url有效性" class="headerlink" title="检查url有效性"></a>检查url有效性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlstatus=$(curl -s -m 5 -IL $url|grep 200)</span><br><span class="line">if [ &quot;$urlstatus&quot; != &quot;&quot; ];then</span><br><span class="line">    wget $url</span><br><span class="line">else</span><br><span class="line">    echo &quot;illegal url: $url&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="jq"><a href="#jq" class="headerlink" title="jq"></a>jq</h2><p>可以使用jq解析json。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Usage: jq [options] &lt;jq filter&gt; [file...] </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install jq</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s url | jq -r <span class="string">&#x27;.result.page_size&#x27;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$json</span>|jq -r <span class="string">&#x27;.result.data[0]&#x27;</span>        <span class="comment"># 数组</span></span></span><br></pre></td></tr></table></figure>

<p>实例：分页请求服务器，每页请求返回page_size条数据，下载每条数据中的视频/图片</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Begin to download...&quot;</span><br><span class="line">urlPattern=&quot;http://url?version=3&amp;page=&quot;</span><br><span class="line"></span><br><span class="line">for page in `seq 1 20`</span><br><span class="line">do</span><br><span class="line">	url=&quot;$urlPattern$page&quot;</span><br><span class="line">	echo &quot;fetch content: $url&quot;</span><br><span class="line"></span><br><span class="line">	urlstatus=$(curl -s -m 5 -IL $url|grep 200)</span><br><span class="line">	if [ &quot;$urlstatus&quot; != &quot;&quot; ];then</span><br><span class="line">		json=$(curl -s $url)</span><br><span class="line">		pageSize=`expr $(echo $json|jq -r &#x27;.result.page_size&#x27;) - 1`</span><br><span class="line">		echo &quot;the page size is $pageSize&quot;</span><br><span class="line">		for index in `seq 0 $pageSize`</span><br><span class="line">		do</span><br><span class="line">			item=$(echo $json|jq -r &quot;.result.data[$index]&quot;)</span><br><span class="line">			urlVideo=$(echo $item|jq -r &#x27;.url&#x27;)</span><br><span class="line">			urlImg=$(echo $item|jq -r &#x27;.url_img&#x27;)</span><br><span class="line">			echo &quot;download video: $urlVideo&quot;</span><br><span class="line">			wget $urlVideo&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">			echo &quot;download image: $urlImg&quot;</span><br><span class="line">			wget $urlImg&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">		done</span><br><span class="line">	else</span><br><span class="line">		echo &quot;illegal url: $url&quot;</span><br><span class="line">	fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置代理</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=ip:port</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消代理</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> http_proxy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> https_proxy=https://127.0.0.1:1080</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置socks代理</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=socks://127.0.0.1:1080</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=sock4://127.0.0.1:1080</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=sock5://127.0.0.1:1080</span></span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>定义变量时，变量名不加美元符号，变量名和等号之间不能有空格，已定义的变量，可以被重新定义，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;runoob.com&quot;</span><br></pre></td></tr></table></figure>

<p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></table></figure>

<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">myUrl=&quot;http://www.google.com&quot;</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure>

<h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>使用 unset 命令可以删除变量。语法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>

<h2 id="输出为变量"><a href="#输出为变量" class="headerlink" title="输出为变量"></a>输出为变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr=$(command)</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p>
<h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</li>
</ul>
<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting $greeting_1</span><br></pre></td></tr></table></figure>

<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>

<h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>

<h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>查找字符 “i 或 s” 的位置（输出index从1开始），如果i存在则输出i的位置，不存在则输出s的位置，若都不存在则输出0：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great company&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; is`  # 输出 8</span><br></pre></td></tr></table></figure>

<p>注意： 以上脚本中 ` 是反引号，而不是单引号 ‘，不要看错了哦。</p>
<h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a>Shell 数组</h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。</p>
<h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</p>
<p>数组名=(值1 值2 … 值n)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"></span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>还可以单独定义数组的各个分量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure>

<p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p>读取数组元素值的一般格式是：</p>
<p><code>$&#123;数组名[下标]&#125;</code></p>
<p>使用 @ 符号可以获取数组中的所有元素：</p>
<p><code>echo $&#123;array_name[@]&#125;</code></p>
<h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>以”#”开头的行就是注释，会被解释器忽略。sh里没有多行注释，只能每一行加一个#号。<br>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>
<p>多行注释还可以使用以下格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">:&lt;&lt;&#x27;</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">&#x27;</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<h1 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h1><p>可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<code>$n</code>。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……，<code>$0</code> 为执行的文件名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">参数处理</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$#</td>
<td align="center">传递到脚本的参数个数</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="center">以一个单字符串显示所有向脚本传递的参数。如”<code>$*</code>“用「”」括起来的情况、以”<code>$1 $2 … $n</code>“的形式输出所有参数。</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如”<code>$@</code>“用「”」括起来的情况、以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</td>
</tr>
<tr>
<td align="center">$$</td>
<td align="center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="center">$-</td>
<td align="center">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line"></span><br><span class="line">echo &quot;参数个数为：$#&quot;;</span><br><span class="line">echo &quot;传递的参数作为一个字符串显示：$*&quot;;</span><br><span class="line"></span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">第一个参数为：1</span><br><span class="line">参数个数为：3</span><br><span class="line">传递的参数作为一个字符串显示：1 2 3</span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两数之和为 : $val&quot;</span><br></pre></td></tr></table></figure>

<p>注意：表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2.</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-eq</td>
<td align="center">检测两个数是否相等，相等返回 true。</td>
<td align="center">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td align="center">-ne</td>
<td align="center">检测两个数是否不相等，不相等返回 true。</td>
<td align="center">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td align="center">-gt</td>
<td align="center">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td align="center">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td align="center">-lt</td>
<td align="center">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td align="center">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td align="center">-ge</td>
<td align="center">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td align="center">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td align="center">-le</td>
<td align="center">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td align="center">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
<td align="center">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td align="center">[ ! false ] 返回 true。</td>
</tr>
<tr>
<td align="center">-o</td>
<td align="center">或运算，有一个表达式为 true 则返回 true。</td>
<td align="center">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td align="center">-a</td>
<td align="center">与运算，两个表达式都为 true 才返回 true。</td>
<td align="center">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑的 AND</td>
<td align="center">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">逻辑的 OR</td>
<td align="center">[[ $a -lt 100 || $b -gt 100 ]] 返回 true</td>
</tr>
</tbody></table>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">检测两个字符串是否相等，相等返回 true。</td>
<td align="center">[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">检测两个字符串是否相等，不相等返回 true。</td>
<td align="center">[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td align="center">-z</td>
<td align="center">检测字符串长度是否为0，为0返回 true。</td>
<td align="center">[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="center">检测字符串长度是否为0，不为0返回 true。</td>
<td align="center">[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td align="center">str</td>
<td align="center">检测字符串是否为空，不为空返回 true。</td>
<td align="center">[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-r file</td>
<td align="center">检测文件是否可读，如果是，则返回 true。</td>
<td align="center">[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td align="center">-w file</td>
<td align="center">检测文件是否可写，如果是，则返回 true。</td>
<td align="center">[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td align="center">-x file</td>
<td align="center">检测文件是否可执行，如果是，则返回 true。</td>
<td align="center">[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td align="center">-s file</td>
<td align="center">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td align="center">[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td align="center">-e file</td>
<td align="center">检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td align="center">[ -e $file ] 返回 true。</td>
</tr>
<tr>
<td align="center">-d file</td>
<td align="center">检测文件是否是目录，如果是，则返回 true。</td>
<td align="center">[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td align="center">-f file</td>
<td align="center">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td align="center">[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td align="center">-b file</td>
<td align="center">检测文件是否是块设备文件，如果是，则返回 true。</td>
<td align="center">[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td align="center">-c file</td>
<td align="center">检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td align="center">[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td align="center">-g file</td>
<td align="center">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td align="center">[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td align="center">-k file</td>
<td align="center">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td align="center">[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td align="center">-p file</td>
<td align="center">检测文件是否是有名管道，如果是，则返回 true。</td>
<td align="center">[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td align="center">-u file</td>
<td align="center">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td align="center">[ -u $file ] 返回 false。</td>
</tr>
</tbody></table>
<h1 id="echo-printf和read"><a href="#echo-printf和read" class="headerlink" title="echo, printf和read"></a>echo, printf和read</h1><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><h3 id="显示普通字符串"><a href="#显示普通字符串" class="headerlink" title="显示普通字符串:"></a>显示普通字符串:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure>

<p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p>
<h3 id="显示转义字符"><a href="#显示转义字符" class="headerlink" title="显示转义字符"></a>显示转义字符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br><span class="line">&quot;It is a test&quot;</span><br></pre></td></tr></table></figure>

<p>同样，双引号也可以省略</p>
<h3 id="显示变量"><a href="#显示变量" class="headerlink" title="显示变量"></a>显示变量</h3><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br></pre></td></tr></table></figure>

<h3 id="显示换行"><a href="#显示换行" class="headerlink" title="显示换行"></a>显示换行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义</span><br><span class="line">echo &quot;It it a test&quot;</span><br></pre></td></tr></table></figure>

<h3 id="显示不换行"><a href="#显示不换行" class="headerlink" title="显示不换行"></a>显示不换行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure>

<h3 id="显示结果定向至文件"><a href="#显示结果定向至文件" class="headerlink" title="显示结果定向至文件"></a>显示结果定向至文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br></pre></td></tr></table></figure>

<h3 id="不转义或取变量"><a href="#不转义或取变量" class="headerlink" title="不转义或取变量"></a>不转义或取变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;$name\&quot;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="显示命令执行结果"><a href="#显示命令执行结果" class="headerlink" title="显示命令执行结果"></a>显示命令执行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br><span class="line"></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash">Thu Jul 24 10:08:46 CST 2014</span></span><br></pre></td></tr></table></figure>

<p>注意： 这里使用的是反引号 `, 而不是单引号 ‘。</p>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>printf  format-string  [arguments…]</p>
<p>参数说明：</p>
<p>format-string: 为格式控制字符串<br>arguments: 为参数列表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">执行脚本，输出结果如下所示：</span></span><br><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有引号也可以输出</span></span><br><span class="line">printf %s abcdef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span></span><br><span class="line">printf %s abc def</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span></span><br><span class="line">printf &quot;%s and %d \n&quot; </span><br></pre></td></tr></table></figure>

<p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p>
<p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;Enter you name:&quot;   #echo -n 让用户直接在后面输入 </span><br><span class="line">read name  #输入的多个文本将保存在一个变量中</span><br><span class="line">echo &quot;Hello $name, welcome to my program.&quot;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please enter your age: &quot; age  #在read命令行指定提示符</span><br><span class="line">days=$[ $age * 365 ]</span><br><span class="line">echo &quot;That makes you over $days days old!&quot;</span><br><span class="line"></span><br><span class="line">read -p &quot;Enter your name:&quot; first last   #指定多个变量</span><br><span class="line">echo &quot;Checking data for $last, $first&quot;</span><br><span class="line"></span><br><span class="line">if read -t 5 -p &quot;Please enter your name: &quot; name     #超时, 等待输入的秒数</span><br><span class="line">then</span><br><span class="line">    echo &quot;Hello $name, welcome to my script&quot;</span><br><span class="line">else</span><br><span class="line">    echo </span><br><span class="line">    echo &quot;Sorry, too slow!&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">read -s -p &quot;Enter your passwd: &quot; pass   #-s 参数使得read读入的字符隐藏</span><br><span class="line">echo </span><br><span class="line">echo &quot;Is your passwd readlly $pass?&quot;</span><br></pre></td></tr></table></figure>

<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if condition; then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></table></figure>

<p>in列表可以包含替换、字符串和文件名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果：</span></span><br><span class="line"></span><br><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line">The value is: 5</span><br><span class="line"></span><br><span class="line">for str in &#x27;This is a string&#x27;</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果：</span></span><br><span class="line"></span><br><span class="line">This is a string</span><br><span class="line"></span><br><span class="line">for i in `seq 1 4`</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $i&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果：</span></span><br><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line"></span><br><span class="line">for (( i = 1; i &lt; 5; i++ )); do</span><br><span class="line">	echo &quot;The value is: $i&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出结果：</span></span><br><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令。</p>
<p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;</span><br><span class="line">echo -n &#x27;输入你最喜欢的网站名: &#x27;</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo &quot;是的！$FILM 是一个好网站&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行脚本，输出类似下面：</span></span><br><span class="line"></span><br><span class="line">按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">输入你最喜欢的网站名:菜鸟教程</span><br><span class="line">是的！菜鸟教程 是一个好网站</span><br></pre></td></tr></table></figure>

<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"></span><br><span class="line">for (( ; ; ))</span><br></pre></td></tr></table></figure>

<h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><p>until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p>
<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    1)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    1)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    1)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li>
<li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">demoFun</span><br></pre></td></tr></table></figure>

<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure>

<p>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>$&#123;10&#125;</code>。当n&gt;=10时，需要使用<code>$&#123;n&#125;</code>来获取参数。另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th align="center">参数处理</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$#</td>
<td align="center">传递到脚本的参数个数</td>
</tr>
<tr>
<td align="center">$*</td>
<td align="center">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td align="center">$$</td>
<td align="center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="center">$!</td>
<td align="center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="center">$@</td>
<td align="center">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td align="center">$-</td>
<td align="center">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td align="center">$?</td>
<td align="center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<h1 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>大多数 UNIX 系统命令从终端接受输入并将所产生的输出发送回​​到终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下是终端。同样，一个命令通常将其输出写入到标准输出，默认情况下也是终端。</p>
<p>重定向命令列表如下：</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">command &gt; file</td>
<td align="center">将输出重定向到 file。</td>
</tr>
<tr>
<td align="center">command &lt; file</td>
<td align="center">将输入重定向到 file。</td>
</tr>
<tr>
<td align="center">command &gt;&gt; file</td>
<td align="center">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="center">n &gt; file</td>
<td align="center">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td align="center">n &gt;&gt; file</td>
<td align="center">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td align="center">n&gt;&amp;m</td>
<td align="center">把输出到文件符n的信息重定向到文件描述符m。</td>
</tr>
<tr>
<td align="center">n&lt;&amp;m</td>
<td align="center">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td align="center">&lt;&lt; tag</td>
<td align="center">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
<tr>
<td align="center">cmd &gt;&amp;n</td>
<td align="center">把输出送到文件描述符n</td>
</tr>
<tr>
<td align="center">cmd m&gt;&amp;n</td>
<td align="center">把输出 到文件符m的信息重定向到文件描述符n</td>
</tr>
<tr>
<td align="center">cmd &gt;&amp;-</td>
<td align="center">关闭标准输出</td>
</tr>
<tr>
<td align="center">cmd &lt;&amp;n</td>
<td align="center">输入来自文件描述符n</td>
</tr>
<tr>
<td align="center">cmd m&lt;&amp;n</td>
<td align="center">m来自文件描述符n</td>
</tr>
<tr>
<td align="center">cmd &lt;&amp;-</td>
<td align="center">关闭标准输入</td>
</tr>
<tr>
<td align="center">cmd &lt;&amp;n-</td>
<td align="center">移动输入文件描述符n而非复制它。（需要解释）</td>
</tr>
<tr>
<td align="center">cmd &gt;&amp;n-</td>
<td align="center">移动输出文件描述符 n而非复制它。（需要解释）</td>
</tr>
<tr>
<td align="center">cmd 2&gt;file</td>
<td align="center">把文件描述符2重定向到file，即把错误输出存到file中。</td>
</tr>
<tr>
<td align="center">cmd &gt; file 2&gt;&amp;1</td>
<td align="center">把标准错误重定向到标准输出，再重定向到file，即stderr和stdout都被输出到file中</td>
</tr>
<tr>
<td align="center">cmd &amp;&gt; file</td>
<td align="center">功能与上一个相同，更为简便的写法。</td>
</tr>
<tr>
<td align="center">cmd &gt;&amp; file</td>
<td align="center">功能仍与上一个相同。</td>
</tr>
<tr>
<td align="center">cmd &gt; f1 2&gt;f2</td>
<td align="center">把stdout重定向到f1，而把stderr重定向到f2</td>
</tr>
<tr>
<td align="center">tee files</td>
<td align="center">把stdout原样输出的同时，复制一份到files中。</td>
</tr>
<tr>
<td align="center">tee files</td>
<td align="center">把stderr和stdout都输出到files中，同时输出到屏幕。</td>
</tr>
</tbody></table>
<p>&gt;&amp;实际上复制了文件描述符，这使得ls &gt; dirlist 2&gt;&amp;1与ls 2&gt;&amp;1 &gt; dirlist的效果不一样。man bash的Redirection节中提及了这段内容。</p>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt; users</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat users</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt;&gt; users</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat users</span></span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br></pre></td></tr></table></figure>

<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入,这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; file1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &gt; test.txt                                                                                  liujiadong</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span></span><br><span class="line">liujiadong </span><br></pre></td></tr></table></figure>

<h2 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<ul>
<li>如果希望 stderr 重定向到 file，可以这样写：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> 2 &gt; file</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> 2 &gt;&gt; file</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; file 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt;&gt; file 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果希望对 stdin 和 stdout 都重定向，可以这样写：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &lt; file1 &gt;file2</span></span><br></pre></td></tr></table></figure>

<h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>

<p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">执行以上脚本，输出结果：</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">/dev/null 文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null, /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
</li>
<li><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure>

<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。Shell 文件包含的语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. filename   # 注意点号(.)和文件名中间有一空格</span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>

<ul>
<li>test1.sh 代码如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>test2.sh 代码如下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用 . 号来引用test1.sh 文件</span></span><br><span class="line">. ./test1.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用以下包含文件代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ./test1.sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;菜鸟教程官网地址：$url&quot;</span><br></pre></td></tr></table></figure>

<p>注：被包含的文件 test1.sh 不需要可执行权限。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Android学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-04 11:29:23" itemprop="dateCreated datePublished" datetime="2018-07-04T11:29:23+08:00">2018-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
            <span id="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Android学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android系统框架"><a href="#Android系统框架" class="headerlink" title="Android系统框架"></a>Android系统框架</h1><p><img src="android-frame.png" alt="android-frame"></p>
<p>从进程分层的角度来看，借用<a target="_blank" rel="noopener" href="http://gityuan.com/android/">Android 操作系统架构开篇</a>中的一张图如下：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机网络学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-29 15:17:19" itemprop="dateCreated datePublished" datetime="2018-06-29T15:17:19+08:00">2018-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:15:18" itemprop="dateModified" datetime="2021-05-14T14:15:18+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
            </span>

          
            <span id="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>由于OSI(Open System Interconnect)是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。</p>
<p>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。</p>
<p>简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能.OSI下3层的主要任务是数据通信，上3层的任务是数据处理。</p>
<p>Socket：是应用层与传输层之间的桥梁.</p>
<p><strong>协议</strong></p>
<table>
<thead>
<tr>
<th align="center">OSI七层网络模型</th>
<th align="center">TCP/IP四层概念模型</th>
<th align="center">对应网络协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层（Application）</td>
<td align="center">应用层</td>
<td align="center">HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
</tr>
<tr>
<td align="center">表示层（Presentation）</td>
<td align="center">应用层</td>
<td align="center">Telnet, Rlogin, SNMP, Gopher</td>
</tr>
<tr>
<td align="center">会话层（Session）</td>
<td align="center">应用层</td>
<td align="center">SMTP, DNS</td>
</tr>
<tr>
<td align="center">传输层（Transport）</td>
<td align="center">传输层</td>
<td align="center">TCP, UDP</td>
</tr>
<tr>
<td align="center">网络层（Network）</td>
<td align="center">网络层</td>
<td align="center">IP, ICMP, ARP, RARP, AKP, UUCP</td>
</tr>
<tr>
<td align="center">数据链路层（Data Link）</td>
<td align="center">数据链路层</td>
<td align="center">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td>
</tr>
<tr>
<td align="center">物理层（Physical）</td>
<td align="center">数据链路层</td>
<td align="center">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td>
</tr>
</tbody></table>
<p><strong>物理层</strong></p>
<ul>
<li><p>利用传输介质为数据链路层提供物理连接，实现比特流的传输（比特Bit）.</p>
</li>
<li><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的</p>
</li>
<li><p>把二进制转换成电流，把电流转换成二进制（单位是bit比特）</p>
</li>
</ul>
<p><strong>数据链路层</strong></p>
<ul>
<li>将比特组装成帧和点到点的传递（帧Frame）</li>
<li>通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路.</li>
<li>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法</li>
<li>数据链路层的具体工作是：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层</li>
<li>将二进制数据转换成标准帧格式（起始位、数据、地址、校验、结束位）</li>
<li>与数据链路层有关的设备：交换机，也就是大家常说的猫（为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路）</li>
<li>如果把电脑比如成客户，数据链路比喻成物流，那么快递小哥通过电脑MAC地址（MAC地址由网卡决定）找到客户地址</li>
</ul>
<p><strong>网络层</strong></p>
<ul>
<li><p>数据链路层的数据在这一层被转换为数据包(package).</p>
</li>
<li><p>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备</p>
</li>
<li><p>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</p>
</li>
<li><p>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</p>
</li>
<li><p>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</p>
</li>
<li><p>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测</p>
</li>
<li><p>网络层有关的设备：路由器（一个作用是连通不同的网络，另一个作用是选择信息传送的线路）</p>
</li>
<li><p>网络层主要有两个作用</p>
<p>  选择数据传输的最优路径，解决网络阻塞问题（网络阻塞的原因主要是CPU需要处理数据有一定延迟）</p>
<p>  将大的数据切割成小的数据包，根据不同时间段的不同最优路径进行传输（可以联想看片时候的断点续传）</p>
</li>
<li><p>互联网通过ip地址识别电脑.</p>
</li>
</ul>
<p><strong>传输层</strong></p>
<ul>
<li>传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用</li>
<li>该层的主要任务是：定义了一些传输数据的协议和端口号（如HTTP的端口80等），TCP,UDP。 主要是从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做报文段(Segment)</li>
<li>电脑通过通过端口号识别某一个应用程序,每一个应用程序都有很多的服务，每一个服务对应着一个端口号</li>
</ul>
<p><strong>会话层</strong></p>
<ul>
<li>建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>会话层是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理</li>
<li>通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）</li>
<li><font color="#990000">数据的传输是在会话层完成的，而不是传输层，传输层只是定义了数据传输的协议</font></li>
</ul>
<p><strong>表示层</strong></p>
<ul>
<li>对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>表示层对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等</li>
<li>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换</li>
<li>表示层的任务：数据格式转换（可以理解成iOS中将c语言的char字符转换成OC语言的NSString）</li>
</ul>
<p><strong>应用层</strong></p>
<ul>
<li>允许访问OSI环境的手段（应用协议数据单元APDU）</li>
<li>应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作</li>
<li>是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务</li>
</ul>
<h1 id="单工-半双工-全双工"><a href="#单工-半双工-全双工" class="headerlink" title="单工,半双工,全双工"></a>单工,半双工,全双工</h1><ul>
<li>单工：单工就是指A只能发信号，而B只能接收信号，通信是单向的。</li>
<li>半双工：指一个时间段内只有一个动作发生，举个简单例子，一天窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。早期的对讲机、以及早期集线器等设备都是实行半双工的产品。随着技术的不断进步，半双工会逐渐退出历史舞台。</li>
<li>全双工：指交换机在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的交换机都支持全双工。</li>
</ul>
<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p><strong>IP地址</strong></p>
<p>IP地址:&lt;网络号&gt;&lt;主机号&gt;.</p>
<ul>
<li>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</li>
<li>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</li>
<li>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</li>
</ul>
<p><strong>私有（保留）地址</strong></p>
<ul>
<li>A类：10.0.0.0——10.255.255.255</li>
<li>B类：172.16.0.0——172.31.255.255</li>
<li>C类：192.168.0.0——192.168.255.255</li>
</ul>
<p><strong>子网划分</strong></p>
<p>三级ip地址：&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;</p>
<h1 id="TCP-amp-UDP-传输层"><a href="#TCP-amp-UDP-传输层" class="headerlink" title="TCP&amp;UDP(传输层)"></a>TCP&amp;UDP(传输层)</h1><p><strong>TCP三次握手与四次挥手</strong></p>
<p>主要因为这是一次全双工的，双方都需要证明自己有发送和接收的能力。握手只需要三次是因为服务端的SYN和ACK可以一次发送给客户端。</p>
<p><img src="TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<p>为什么TCP客户端最后还要发一次确认呢？</p>
<p>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<p><img src="TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。</li>
<li>服务器收到连接释放报文，发出确认报文，服务端就进入了CLOSE-WAIT（关闭等待）状态。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认。此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。</li>
</ol>
<p>为什么客户端最后还要等待2MSL？</p>
<ol>
<li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li>
<li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li>
</ol>
<p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ol>
<li>当主机甲想要释放连接时会发FIN给主机B。</li>
<li>主机乙收到甲发送的FIN，表示收到了，就会发送ACK回复。</li>
<li>但这是乙可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到乙数据发送完了，才会发送FIN给主机A.</li>
<li>A收到B发来的FIN，知道B的数据也发送完了，回复ACK，A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。</li>
</ol>
<p><strong>TCP和UDP</strong></p>
<p><em>UDP</em></p>
<ul>
<li>面向无连接</li>
<li>有单播，多播，广播的功能：支持一对一，一对多，多对多，多对一的方式。</li>
<li>面向报文：发送方对应用程序的报文添加首部后就向下交付IP层，既不合并，也不拆分，因此应用程序必须选择合适大小的报文。</li>
<li>不可靠性：不需建立连接，不关心接收端是否接收到信息。适合实时性要求高的场景（比如电话会议）。</li>
<li>头部开销小，传输数据报文时是很高效的。</li>
</ul>
<p><em>TCP</em></p>
<ul>
<li>面向连接：三次握手四次挥手。</li>
<li>仅支持单播传输：点对点。</li>
<li>面向字节流</li>
<li>可靠传输：给每个包一个序列号，接收端按序接收，然后发送确认ACK，发送端决定是否重传。</li>
<li>拥塞控制</li>
</ul>
<p><strong>TCP流量控制</strong></p>
<p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口实现流量控制。</p>
<p>发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。</p>
<p><strong>TCP拥塞控制</strong></p>
<p>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p><em>慢开始和拥塞避免</em></p>
<ol>
<li>在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。</li>
<li>在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。</li>
<li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</li>
</ol>
<p><em>快重传和快恢复</em></p>
<ul>
<li>快重传：发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了，就应立即重传丢失的报文段而不必继续等待为该报文段设置的重传计时器的超时</li>
<li>快恢复：<ol>
<li>当发送端收到连续三个重复的 ACK 时，就重新设置慢开始门限 ssthresh。</li>
<li>与慢开始不同之处是 swnd 不是设置为 1，而是设置为 ssthresh + 3 * MSS。</li>
<li>若收到的重复的 ACK 为 n 个（n &gt; 3），则将 cwnd 设置为 ssthresh + n * MSS。</li>
<li>若发送窗口值还容许发送报文段，就按拥塞避免算法继续发送报文段。</li>
<li>若收到了确认新的报文段的 ACK，就将 swnd 缩小到 ssthresh。</li>
</ol>
</li>
</ul>
<h1 id="http-amp-https"><a href="#http-amp-https" class="headerlink" title="http&amp;https"></a>http&amp;https</h1><p><strong>Http码</strong></p>
<ul>
<li>1xx （临时响应）请求正在处理，可能需要请求者执行某些操作。</li>
<li>2xx （成功）表示成功处理了请求的状态代码。</li>
<li>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</li>
<li>4xx （客户端错误） 这些状态代码表示客户端请求可能出错，服务器无法处理。</li>
<li>5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</li>
</ul>
<p><strong>http和https的区别与联系</strong></p>
<p>HTTP协议传输的数据都是明文，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是通过 SSL 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http是无状态(每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更，也不依赖之前的状态)的；HTTPS协议是由SSL+HTTP协议构建的，http是无状态的，ssl/tls是有状态的。</li>
</ol>
<p><img src="HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg" alt="https"></p>
<p><strong>Http1.0, 1.1, 2.0</strong></p>
<ul>
<li>HTTP 1.1支持长连接，使用长连接的情况下，连接成功后客户端和服务器之间用于的TCP连接不会关闭，一段时间内如果客户端再次访问这个服务器，会继续使用这一条已经建立的连接(Connection:keep-alive)。HTTP 1.0规定浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立TCP连接，完成处理后立即断开TCP连接。</li>
<li>HTTP 1.0认为每台服务器都绑定一个唯一的IP地址，虚拟主机发展后一台物理服务器上可以存在多个虚拟主机，它们共享一个IP地址，因此添加了主机host参数。</li>
<li>HTTP 1.1在1.0的基础上加入了一些cache的新特性。HTTP 1.0使用Expires头标识缓存的有效期，其值是一个绝对时间，依赖客户端的本地时间。从HTTP 1.1 开始使用Cache-Control头表示缓存状态。</li>
<li>新增了24个状态响应码，如 410 表示服务器上的某个资源被永久性的删除。</li>
<li>http 1.1在请求头引入了range头，支持断点续传。</li>
</ul>
<p>HTTP 2.0:</p>
<ul>
<li>HTTP 1.x的解析基于文本，HTTP 2.0在应用层和传输层之间增加一个二进制分帧层，它把原来 HTTP 1.x的header和body用二进制重新封装了一层。</li>
<li>HTTP 2.0多路复用基于二进制分帧，在同一域名下所有访问都从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据帧id重新组装起来。</li>
<li>头部压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0要求客户端和服务器同时维护和更新一个包含之前见过的头字段的索引列表(cache)，之后传输的头信息会基于此表编码和解码。</li>
<li>服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
<p><strong>HTTP是不保存状态的协议，如何保存用户状态?</strong></p>
<p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，使用Session可以服务端记录用户的状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<ul>
<li>Cookie: 浏览器的一种数据存储方式。</li>
<li>Session: 会话。服务器使用Session把用户的信息临时保存在服务器上，用户离开网站后Session会被销毁。客户端得到这个Session Id后可以存储在Cookie里。这里有个缺陷，如果Web服务器有许多台，那么下次请求如果请求到了另一个服务器上的时候就验证不了Session了。</li>
<li>Token: 也用来做身份验证，但是服务器不需要存储Token信息，服务器会在用户登录成功后返回一个签名后的Token回来，下次请求带上，服务器再解密验证即可。</li>
</ul>
<h1 id="浏览器访问http网址"><a href="#浏览器访问http网址" class="headerlink" title="浏览器访问http网址"></a>浏览器访问http网址</h1><ol>
<li>客户端浏览器输入URL后，检查本地是否有DNS缓存，缓存的查找顺序为：浏览器缓存–&gt;系统缓存–&gt;路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器。</li>
<li>应用层客户端浏览器根据ip及相应的端口号，构造一个http请求，包括请求头和请求体，封装在TCP包里。</li>
<li>然后传输层TCP通过三次握手建立连接(SYN–&gt;ACK/SYN–&gt;ACK)，TCP进行分割数据包，输入到网络层。</li>
<li>网络层ip协议通过查找路由表决定通过哪个路径到达服务器，把数据包发送给服务器。</li>
<li>数据到达数据链路层，将数据发送给指定mac地址的服务器。</li>
</ol>
<h1 id="交换机、路由器、网关"><a href="#交换机、路由器、网关" class="headerlink" title="交换机、路由器、网关"></a>交换机、路由器、网关</h1><p><strong>交换机</strong></p>
<p>交换机工作于数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层和第七层，并因此而得名。</p>
<p><strong>路由器</strong></p>
<p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</p>
<p>路由器与交换器的差别，路由器是属于OSI第三层(网络层)的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p>
<p><strong>网关</strong></p>
<p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<p>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。</p>
<p>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。</p>
<p>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>
<p><strong>网桥</strong></p>
<p>简单的说网桥就是个硬件网络协议翻译器，假设你有2台电脑，一台兼容机安装windows，一台是Apple安装OS2，那么两台电脑之间是默认网络协议是不同的，兼容机可能只会说TCP/IP，苹果机只会说Apple talk，就好象两个外国人都不会说对方的语言，怎么办？找个翻译，网桥就是翻译。</p>
<p>在386、486时代网桥可能是一台安装了协议转换程序的电脑，如今交换机也包含这个功能。今天的操作系统之间为了互相交流，支持更多的协议，操作系统自己就可以是网桥，现在网桥这个概念已经淡出了。更多是所谓的桥接、转发、协议二次封装。</p>
<p>网桥也可以说相当一个端口少的二层交换机，再者网桥主要由软件实现，交换机主要由硬件实现！</p>
<p><strong>网络接口卡（网卡）</strong></p>
<ol>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。</li>
</ol>
<p><strong>路由表</strong></p>
<p>路由表是用来决定如何将一个数据包从一个子网传送到另一个子网的，换句话说就是用来决定从一个网卡接收到的包应该送到哪一个网卡上去。</p>
<p>路由表的每一行至少有目标网络号、子网掩码、到这个子网应该使用的网卡这三条信息。当路由器从一个网卡接收到一个包时，它扫描路由表的每一行，用里面的子网掩码与数据包中的目标IP地址做逻辑与运算（&amp;）找出目标网络号。如果得出的结果网络号与这一行的网络号相同，就将这条路由表六下来作为备用路由。如果已经有备用路由了，就载这两条路由里将网络号最长的留下来，另一条丢掉（这是用无分类编址CIDR的情况才是匹配网络号最长的，其他的情况是找到第一条匹配的行时就可以进行转发了）。如此接着扫描下一行直到结束。如果扫描结束仍没有找到任何路由，就用默认路由。确定路由后，直接将数据包送到对应的网卡上去。在具体的实现中，路由表可能包含更多的信息为选路由算法的细节所用。</p>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSH的英文全称为Secure Shell，是IETF（Internet Engineering Task Force）的Network Working Group所制定的一族协议，其目的是要在非安全网络上提供安全的远程登录和其他安全网络服务。用于在主机之间建立起安全连接, 并加密传输内容, 以达到安全的远程访问, 操作以及数据传输的目的。它只是一种协议，存在多种实现，既有商业实现，也有开源实现。比较常用的是OpenSSH，它是自由软件，应用非常广泛。</p>
<p>SSH协议目前有SSH1和SSH2两个主流版本，SSH2协议兼容SSH1，强烈建议使用SSH2版本。目前实现SSH1和SSH2协议的主要软件有OpenSSH 和SSH Communications Security Corporation　公司的SSH Communications 软件。前者是OpenBSD组织开发的一款免费的SSH软件，后者是商业软件，因此在linux、FreeBSD、OpenBSD 、NetBSD等免费类UNIX系统种，通常都使用OpenSSH作为SSH协议的实现软件。</p>
<p>SSH主要有两个特点: 1. 安全性 2. 传输速度快。与FTP、POP 和 Telnet 等传统网络服务使用明文传输数据、命令和口令不同，SSH可以对所有传输的数据进行加密，能够防止 DNS 欺骗和 IP 欺骗。</p>
<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>
<p>SSH支持两种认证方式：密码认证和密钥认证。</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>
<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>
<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p>
<h2 id="密码认证"><a href="#密码认证" class="headerlink" title="密码认证"></a>密码认证</h2><ol>
<li>客户端向服务端发起登录请求，服务端将自己的公钥返回给客户端</li>
<li>客户端输入登录口令，口令经服务端公钥加密后发送到服务端</li>
<li>服务端接收到加密口令后使用私钥解密，如果密码正确则登录成功</li>
</ol>
<p>第一次登录对方主机时，系统会出现下面的提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line">The authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p>
<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p>
<p>远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>
<h2 id="密钥认证"><a href="#密钥认证" class="headerlink" title="密钥认证"></a>密钥认证</h2><ol>
<li>客户端发起密钥连接请求，并上传身份信息</li>
<li>服务端收到请求后，在可信列表中查询客户端，若无此客户端则断开连接，否则发送一串随机问询码，该问询码使用此客户端公钥加密处理</li>
<li>客户端收到加密问询码后，使用私钥解密出问询码再用通信session对问询码加密并传送给服务端</li>
<li>服务端解密问询码并判定客户端身份安全与否，安全则建立连接</li>
</ol>
<p>登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<p>因此，密钥认证首要要将客户端的公钥放置在服务端的授权登录列表中。密钥认证一般不需要密码，但客户端可在生成密钥时指定密钥加密密码，这样在与服务端建立连接时需要输入加密密码来解密私钥，防止因私钥泄露带来的安全问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成密钥对</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将公钥传送到远程主机host</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-copy-id user@host</span></span><br></pre></td></tr></table></figure>

<p>以后再登录，就不需要输入密码了。</p>
<p>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>然后，重启远程主机的ssh服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service ssh restart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> debian系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/ssh restart</span></span><br></pre></td></tr></table></figure>

<h2 id="authorized-keys文件"><a href="#authorized-keys文件" class="headerlink" title="authorized_keys文件"></a>authorized_keys文件</h2><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>
<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host <span class="string">&#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>$ ssh user@host</code>表示登录远程主机；</li>
<li><code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>表示登录后在远程shell上执行的命令：</li>
<li><code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</li>
<li><code>cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</li>
</ol>
<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>
<h1 id="SSL、TLS、SSH-amp-HTTPS"><a href="#SSL、TLS、SSH-amp-HTTPS" class="headerlink" title="SSL、TLS、SSH&amp;HTTPS"></a>SSL、TLS、SSH&amp;HTTPS</h1><h2 id="SSL（Secure-Socket-Layer）"><a href="#SSL（Secure-Socket-Layer）" class="headerlink" title="SSL（Secure Socket Layer）"></a>SSL（Secure Socket Layer）</h2><ul>
<li>SSL是传输层之上，对Socket连接的加密协议。</li>
<li>SSL多用于Internet上，在浏览器和服务器之间的安全传输。</li>
<li>OpenSSL是SSL/TLS的开源实现。</li>
</ul>
<h2 id="TLS（Transport-Layer-Security）"><a href="#TLS（Transport-Layer-Security）" class="headerlink" title="TLS（Transport Layer Security）"></a>TLS（Transport Layer Security）</h2><ul>
<li>TLS也是传输层之上的加密协议。</li>
<li>TLS可用于任何两个应用程序之间的安全传输。</li>
<li>OpenSSL是SSL/TLS的开源实现。</li>
</ul>
<h2 id="SSH（Secure-Shell）"><a href="#SSH（Secure-Shell）" class="headerlink" title="SSH（Secure Shell）"></a>SSH（Secure Shell）</h2><ul>
<li>SSH是应用层的通信加密协议，往往用于远程登录的会话。</li>
<li>OpenSSH是SSH的开源实现。</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul>
<li>在传输层使用SSL/TLS加密的HTTP</li>
<li>与HTTP类似，HTTPS本身是应用层的协议。</li>
<li>同一台Web服务器，往往同时支持HTTP和HTTPS，这是分别通过80端口和443端口实现的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Nginx学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-16 11:30:31" itemprop="dateCreated datePublished" datetime="2018-06-16T11:30:31+08:00">2018-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/" itemprop="url" rel="index"><span itemprop="name">后台</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          
            <span id="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Nginx学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>安装gcc g++的依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install libtool</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装pcre依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装zlib依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装ssl依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openssl</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>安装nginx</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：这里可能会报错，提示“pcre.h No such file or directory”,具体详见：http://stackoverflow.com/questions/22555561/error-building-fatal-error-pcre-h-no-such-file-or-directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要安装 libpcre3-dev,命令为：sudo apt-get install libpcre3-dev</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta">#</span><span class="bash">启动nginx：</span></span><br><span class="line">sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过 -h查看帮助命令。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看nginx进程：</span></span><br><span class="line">ps -ef|grep nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">sudo ./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>配置</li>
</ol>
<p>在conf目录下新建一个ihasy.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">upstream ihasy  &#123;</span><br><span class="line">    server 127.0.0.1:9001; #Tornado</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Start www.ihasy.com ##</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.ihasy.com ihasy.com;</span><br><span class="line"></span><br><span class="line">    #root   html;</span><br><span class="line">    #index  index.html index.htm index.py index;</span><br><span class="line"></span><br><span class="line">    ## send request back to Tornado ##</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;ihasy;</span><br><span class="line"></span><br><span class="line">        #Proxy Settings</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout      90;</span><br><span class="line">        proxy_send_timeout         90;</span><br><span class="line">        proxy_read_timeout         90;</span><br><span class="line">        proxy_buffer_size          4k;</span><br><span class="line">        proxy_buffers              4 32k;</span><br><span class="line">        proxy_busy_buffers_size    64k;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">## End www.ihasy.com ##</span><br></pre></td></tr></table></figure>

<p>在nginx.conf中添加<code>include ihasy.conf</code>,保存，重启nginx,即可实现反向代理。</p>
<p>nginx.conf中默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">user  root;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><img src="正向代理和反向代理.png"/>

<p>正向代理:是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理的用途：</p>
<ul>
<li>访问原来无法访问的资源，如google</li>
<li>可以做缓存，加速访问资源</li>
<li>对客户端访问授权，上网进行认证</li>
<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>
</ul>
<p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>反向代理的作用：</p>
<ul>
<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>
<li>负载均衡，通过反向代理服务器来优化网站的负载</li>
</ul>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>Nginx之所以能同时处理大量的请求，原因在于它采用了十分巧妙的事件驱动机制。</p>
<p>作为一个Web服务器，要同时处理多个请求，不可避免地要面对这么一个问题，如何同时处理像磁盘和网络等等的I/O请求，即如何实现I/O复用。为了解决该问题，操作系统在很久之前就开始提供诸如“select”、“poll”等系统调用。Apache HTTP的多处理模块(MPM，multi-processing module)就会用到这些系统调用。但是，select/poll为了识别出哪些文件或者socket已经准备就绪，必须将所有已注册的文件描述符(fd)一个个地检查一遍。如果注册列表越长，那么每次的扫描所需的时间也越长。而Nginx的I/O复用机制使用的是“epoll”这个基于事件驱动的系统调用。因为epoll会在系统内核管理和监听这些文件描述符(fd)，并自动把就绪的加入到Ready队列当中。所以，程序只需在需要时往Ready队列中取出一个进行处理即可，而不用切换到内核态，然后一个个地检查，然后又切换回用户态。这样，无论需要注册监听的I/O有多少，都不会影响程序的运行效率。为了避免select/poll带来的线性增长的负担，Apache HTTP必须将这些IO分散到各个进程/线程中处理，这样势必会造成占用内存的增长。但是，Nginx可以通过利用“epoll”，保证可以使用一个进程/线程完成所有请求的处理，这样可以大大减少内存的占用，从而使应对上万并发请求成为可能。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>语法规则： location [=|<del>|</del>*|^~] /uri/ { … }</p>
<ul>
<li>= 开头表示精确匹配</li>
<li>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。一旦匹配成功，那么 Nginx 就停止去寻找其他的 Location 块进行匹配了(其他可能没有这个特性)</li>
<li>~ 开头表示区分大小写的正则匹配</li>
<li>~*  开头表示不区分大小写的正则匹配</li>
<li>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配 的正则</li>
<li>/ 通用匹配，任何请求都会匹配到。</li>
<li>多个location配置的情况下匹配顺序为：首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;  </span><br><span class="line">   #规则A  </span><br><span class="line">&#125;  </span><br><span class="line">location &#x3D; &#x2F;login &#123;  </span><br><span class="line">   #规则B  </span><br><span class="line">&#125;  </span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;  </span><br><span class="line">   #规则C  </span><br><span class="line">&#125;  </span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;  </span><br><span class="line">   #规则D  </span><br><span class="line">&#125;  </span><br><span class="line">location ~* \.png$ &#123;  </span><br><span class="line">   #规则E  </span><br><span class="line">&#125;  </span><br><span class="line">location !~ \.xhtml$ &#123;  </span><br><span class="line">   #规则F  </span><br><span class="line">&#125;  </span><br><span class="line">location !~* \.xhtml$ &#123;  </span><br><span class="line">   #规则G  </span><br><span class="line">&#125;  </span><br><span class="line">location &#x2F; &#123;  </span><br><span class="line">   #规则H  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>那么产生的效果如下：</p>
<ul>
<li>访问根目录/， 比如<a target="_blank" rel="noopener" href="http://localhost/">http://localhost/</a> 将匹配规则A</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/login">http://localhost/login</a> 将匹配规则B，<a target="_blank" rel="noopener" href="http://localhost/register">http://localhost/register</a> 则匹配规则H</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则C</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/a.gif">http://localhost/a.gif</a>, <a target="_blank" rel="noopener" href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a target="_blank" rel="noopener" href="http://localhost/static/c.png">http://localhost/static/c.png</a> 则优先匹配到 规则C</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/a.PNG">http://localhost/a.PNG</a> 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/a.xhtml">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a target="_blank" rel="noopener" href="http://localhost/a.XHTML%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99G%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E3%80%82%E8%A7%84%E5%88%99F%EF%BC%8C%E8%A7%84%E5%88%99G%E5%B1%9E%E4%BA%8E%E6%8E%92%E9%99%A4%E6%B3%95%EF%BC%8C%E7%AC%A6%E5%90%88%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%83%B3%E6%83%B3%E7%9C%8B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E3%80%82">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a></li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/category/id/1111">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</li>
<li>所以实际使用中，通常至少有三个匹配规则定义，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。  </span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页  </span><br><span class="line"># 第一个必选规则  </span><br><span class="line">location &#x3D; &#x2F; &#123;  </span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项  </span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用  </span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;  </span><br><span class="line">    root &#x2F;webroot&#x2F;static&#x2F;;  </span><br><span class="line">&#125;  </span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;  </span><br><span class="line">    root &#x2F;webroot&#x2F;res&#x2F;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器  </span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握  </span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了  </span><br><span class="line">location &#x2F; &#123;  </span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h2 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>负载均衡配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream linuxidc &#123;</span><br><span class="line">    server 10.0.6.108:7080;</span><br><span class="line">    server 10.0.0.85:8980;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    root  html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;linuxidc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="weight（权重）"><a href="#weight（权重）" class="headerlink" title="weight（权重）"></a>weight（权重）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream linuxidc &#123;</span><br><span class="line">    server 10.0.0.77 weight&#x3D;5;</span><br><span class="line">    server 10.0.0.88 weight&#x3D;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ip-hash（访问ip）"><a href="#ip-hash（访问ip）" class="headerlink" title="ip_hash（访问ip）"></a>ip_hash（访问ip）</h3><p>每一个请求按訪问ip的hash结果分配。这样每一个訪客固定訪问一个后端服务器，能够解决session的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favresin &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 10.0.0.10:8080;</span><br><span class="line">    server 10.0.0.11:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url-hash（第三方）"><a href="#url-hash（第三方）" class="headerlink" title="url_hash（第三方）"></a>url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，使每一个url定向到同一个后端服务器。后端服务器为缓存时比較有效。注意：在upstream中加入hash语句。server语句中不能写入weight等其他的參数，hash_method是使用的hash算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream resinserver &#123;</span><br><span class="line">    server 10.0.0.10:7777;</span><br><span class="line">    server 10.0.0.11:8888;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h3><p>按后端服务器的响应时间来分配请求。响应时间短的优先分配,与weight分配策略相似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favresin &#123;</span><br><span class="line">    server 10.0.0.10:8080;</span><br><span class="line">    server 10.0.0.11:8080;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>upstream还能够为每一个设备设置状态值，这些状态值的含义分别例如以下：</p>
<ul>
<li>down 表示单前的server临时不參与负载.</li>
<li>weight 默觉得1.weight越大，负载的权重就越大。</li>
<li>max_fails ：同意请求失败的次数默觉得1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</li>
<li>fail_timeout : max_fails次失败后。暂停的时间。</li>
<li>backup： 其他全部的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend&#123; #定义负载均衡设备的Ip及设备状态 </span><br><span class="line">      ip_hash; </span><br><span class="line">      server 10.0.0.11:9090 down;</span><br><span class="line">      server 10.0.0.11:8080 weight&#x3D;2;</span><br><span class="line">      server 10.0.0.11:6060;</span><br><span class="line">      server 10.0.0.11:7070 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="虚拟主机配置"><a href="#虚拟主机配置" class="headerlink" title="虚拟主机配置"></a>虚拟主机配置</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>通常情况下,为了使每个服务器可以供更多用户使用,可以将一个服务器分为很多虚拟的子服务器,每个子服务器是相互独立的.这些服务器是根据虚拟化技术分出来的,这样,一台服务器可以虚拟成很多台子服务器,叫做虚拟主机.nginx下，一个server标签就是一个虚拟主机。</p>
<p>配置方法:</p>
<ol>
<li>基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</li>
<li>基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</li>
<li>基于ip的虚拟主机，几乎不用。</li>
</ol>
<h2 id="基于域名"><a href="#基于域名" class="headerlink" title="基于域名"></a>基于域名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name www.yong.com;</span><br><span class="line">   index index.html;</span><br><span class="line">   root &#x2F;data&#x2F;www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name bbs.yong.com;</span><br><span class="line">   index index.html;</span><br><span class="line">   root &#x2F;data&#x2F;bbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于端口"><a href="#基于端口" class="headerlink" title="基于端口"></a>基于端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8001;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;bbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于ip地址"><a href="#基于ip地址" class="headerlink" title="基于ip地址"></a>基于ip地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 192.168.20.20:80;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 192.168.20.21:80;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;bbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>nginx实现代理上网，有三个关键点必须注意，其余的配置跟普通的nginx一样\</p>
<ol>
<li>增加dns解析resolver</li>
<li>增加无server_name名的server</li>
<li>proxy_pass指令</li>
<li>电脑配置配置文件中的地址和端口为代理地址和端口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br><span class="line">worker_processes 1;</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log debug;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8088;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;$http_host$request_uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理，外部机器通过网关访问网关后面服务器上的内容，网关起到了反向代理的功能，我们平时通过浏览器访问远程的web服务器大都是这样实现的。</p>
<p>nginx反向代理的指令不需要新增额外的模块，默认自带proxy_pass指令，只需要修改配置文件就可以实现反向代理。配置前的准备工作:后端run apache服务的ip和端口，确保可以通过<a href="http://ip:port能访问到自己的网站">http://ip:port能访问到自己的网站</a>.</p>
<p>添加配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">upstream apachephp  &#123;</span><br><span class="line">    server ip:8080; #Apache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.quancha.cn;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;quancha.access.log  main;</span><br><span class="line">    error_log  logs&#x2F;quancha.error.log;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    ## send request back to apache ##</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;apachephp;</span><br><span class="line"></span><br><span class="line">        #Proxy Settings</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout      90;</span><br><span class="line">        proxy_send_timeout         90;</span><br><span class="line">        proxy_read_timeout         90;</span><br><span class="line">        proxy_buffer_size          4k;</span><br><span class="line">        proxy_buffers              4 32k;</span><br><span class="line">        proxy_busy_buffers_size    64k;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="部署SpringBoot"><a href="#部署SpringBoot" class="headerlink" title="部署SpringBoot"></a>部署SpringBoot</h1><p>Nginx配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot的配置文件中配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">remote-ip-header:</span> <span class="string">x_forwarded_for</span></span><br><span class="line">    <span class="attr">protocol-header:</span> <span class="string">x-forwarded-proto</span></span><br><span class="line">    <span class="attr">port-header:</span> <span class="string">X-Forwarded-Port</span></span><br><span class="line">  <span class="attr">use-forward-headers:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="comment">#8080端口只能被本机访问</span></span><br></pre></td></tr></table></figure>

<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="映射本地文件夹"><a href="#映射本地文件夹" class="headerlink" title="映射本地文件夹"></a>映射本地文件夹</h2><p>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;hearing &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    root &#x2F;home&#x2F;hearing&#x2F;Downloads&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>nginx -s reload</code>重新载入配置，可以在<code>localhost:80/hearing/</code>访问到<code>/home/hearing/Downloads/hearing/</code>下的文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/" class="post-title-link" itemprop="url">夜的随笔-二</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-15 16:15:46" itemprop="dateCreated datePublished" datetime="2018-06-15T16:15:46+08:00">2018-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%97/" itemprop="url" rel="index"><span itemprop="name">文字</span></a>
                </span>
            </span>

          
            <span id="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/" class="post-meta-item leancloud_visitors" data-flag-title="夜的随笔-二" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <center>*文/苍耳*</center>

<p>走在昏黄的路灯下，一步一步地，走过去了，也未曾留下什么脚印。树影斑驳的小路上依旧残留着些许枯叶，无论什么季节，它们始终静静地躺在那里，等待着变腐烂，守候着诗人低吟。死如秋叶，也无人问津。</p>
<p>回到宿舍忽然很想重温火影，他完结的那天总有种怅然若失的感觉，那个傻乎乎的鸣人，总是有一种让人情不自禁地想要去亲近他的气质。相伴十余年，尚记得曾在小摊上找到一张有好几百集的盗版CD的时候，兴奋地可以看上一整天，如痴如醉，如梦难醒。</p>
<p>当然自然没看成，明天还要上课吧。躺在床上想听会歌，却循环到了久石让。刹那间便有种难以言明的伤感，所有曾迷恋过宫崎骏的动画和久石让的音乐的人大概都能理解这种感觉吧。当音乐响起，不禁有种恍若隔世的感觉，童年，少年，以及所谓的青春，都被衔接成一段段的旋律，每个音符，都藏着某些不为人知的往事。那曾是所有青春年少的日子里，与我朝夕相伴的挚友，在流金岁月里，如一杯清水，一曲平静。</p>
<p>如今渐渐少有写东西的时间，很长一段时间里都迷上了小说，大概是觉得自己的生活里缺少了许多的东西吧，说白了是贪心，看过了这么多的故事，我如一个傻子般沉浸在别人的幸福里，却从未想过，我自己的生活，究竟是什么。披着一层伪装，然后戴上一套面具，推开门，都是一天。</p>
<p>天涯海角的邂逅，陌生人之间亦可相谈甚欢，曾以为相逢即是缘，而今想来，世上哪会有如此多的缘分，许多，大抵都是相逢一笑，擦肩路人而已。</p>
<p>或许是从小孤独惯了，所以对许多东西都太过在意，结果自是相反的，在人生这条路上，都被我越拉越远。</p>
<p>成长的代价，便是越来越少的时间去做喜欢的事情，而且必须毫无怨言，因为活着已不仅是为了自己。如今也只有在夜深人静难以入眠的时候，或者是独自一人找个地方独饮的时候，久违地矫情一把，当一个破落诗人，举杯饮酒，附庸风雅，好好地犒劳一下自己心中潜藏已久的小情绪，清一下往事，倒一碗矫情，一饮而尽。</p>
<p>想起一个朋友，和两杯酒，许是人声鼎沸的小店，或者静若可闻的深夜，一碟小菜，久饮不散。杯中那倒影，荡漾着，击碎了流光。</p>
<p>一曲循环，也终有尽时。爱深了这些音乐，半随忧伤，半入流年。这一路走来，虽然不长，却也都有故事。一直不擅长说话，也讲不清故事，即便相识，也总是重复着相逢又陌路的遗憾，随着汹涌的浪潮，消失在时间海里。</p>
<p>但你的故事，我都听着。</p>
<p>一直都喜欢这句话:”不困于心，不乱于情。不畏将来，不念过往。”</p>
<p>如此，安好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">164</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
