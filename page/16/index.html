<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:type" content="website">
<meta property="og:title" content="苍耳的博客">
<meta property="og:url" content="http://yoursite.com/page/16/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="诗歌，宋词，后台，Android，Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Android学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-04 11:29:23" itemprop="dateCreated datePublished" datetime="2018-07-04T11:29:23+08:00">2018-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
            <span id="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Android学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Android系统框架"><a href="#Android系统框架" class="headerlink" title="Android系统框架"></a>Android系统框架</h1><p><img src="android-frame.png" alt="android-frame"></p>
<p>从进程分层的角度来看，借用<a target="_blank" rel="noopener" href="http://gityuan.com/android/">Android 操作系统架构开篇</a>中的一张图如下：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/07/04/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机网络学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-29 15:17:19" itemprop="dateCreated datePublished" datetime="2018-06-29T15:17:19+08:00">2018-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:15:18" itemprop="dateModified" datetime="2021-05-14T14:15:18+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
            </span>

          
            <span id="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>由于OSI(Open System Interconnect)是一个理想的模型，因此一般网络系统只涉及其中的几层，很少有系统能够具有所有的7层，并完全遵循它的规定。</p>
<p>在7层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面4层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第4层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上3层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。</p>
<p>简言之，下4层主要完成通信子网的功能，上3层主要完成资源子网的功能.OSI下3层的主要任务是数据通信，上3层的任务是数据处理。</p>
<p>Socket：是应用层与传输层之间的桥梁.</p>
<p><strong>协议</strong></p>
<table>
<thead>
<tr>
<th align="center">OSI七层网络模型</th>
<th align="center">TCP/IP四层概念模型</th>
<th align="center">对应网络协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层（Application）</td>
<td align="center">应用层</td>
<td align="center">HTTP、TFTP, FTP, NFS, WAIS、SMTP</td>
</tr>
<tr>
<td align="center">表示层（Presentation）</td>
<td align="center">应用层</td>
<td align="center">Telnet, Rlogin, SNMP, Gopher</td>
</tr>
<tr>
<td align="center">会话层（Session）</td>
<td align="center">应用层</td>
<td align="center">SMTP, DNS</td>
</tr>
<tr>
<td align="center">传输层（Transport）</td>
<td align="center">传输层</td>
<td align="center">TCP, UDP</td>
</tr>
<tr>
<td align="center">网络层（Network）</td>
<td align="center">网络层</td>
<td align="center">IP, ICMP, ARP, RARP, AKP, UUCP</td>
</tr>
<tr>
<td align="center">数据链路层（Data Link）</td>
<td align="center">数据链路层</td>
<td align="center">FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td>
</tr>
<tr>
<td align="center">物理层（Physical）</td>
<td align="center">数据链路层</td>
<td align="center">IEEE 802.1A, IEEE 802.2到IEEE 802.11</td>
</tr>
</tbody></table>
<p><strong>物理层</strong></p>
<ul>
<li><p>利用传输介质为数据链路层提供物理连接，实现比特流的传输（比特Bit）.</p>
</li>
<li><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的</p>
</li>
<li><p>把二进制转换成电流，把电流转换成二进制（单位是bit比特）</p>
</li>
</ul>
<p><strong>数据链路层</strong></p>
<ul>
<li>将比特组装成帧和点到点的传递（帧Frame）</li>
<li>通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路.</li>
<li>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法</li>
<li>数据链路层的具体工作是：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层</li>
<li>将二进制数据转换成标准帧格式（起始位、数据、地址、校验、结束位）</li>
<li>与数据链路层有关的设备：交换机，也就是大家常说的猫（为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路）</li>
<li>如果把电脑比如成客户，数据链路比喻成物流，那么快递小哥通过电脑MAC地址（MAC地址由网卡决定）找到客户地址</li>
</ul>
<p><strong>网络层</strong></p>
<ul>
<li><p>数据链路层的数据在这一层被转换为数据包(package).</p>
</li>
<li><p>其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备</p>
</li>
<li><p>寻址：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。</p>
</li>
<li><p>交换：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。</p>
</li>
<li><p>路由算法：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。</p>
</li>
<li><p>连接服务：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测</p>
</li>
<li><p>网络层有关的设备：路由器（一个作用是连通不同的网络，另一个作用是选择信息传送的线路）</p>
</li>
<li><p>网络层主要有两个作用</p>
<p>  选择数据传输的最优路径，解决网络阻塞问题（网络阻塞的原因主要是CPU需要处理数据有一定延迟）</p>
<p>  将大的数据切割成小的数据包，根据不同时间段的不同最优路径进行传输（可以联想看片时候的断点续传）</p>
</li>
<li><p>互联网通过ip地址识别电脑.</p>
</li>
</ul>
<p><strong>传输层</strong></p>
<ul>
<li>传输层是通信子网和资源子网的接口和桥梁，起到承上启下的作用</li>
<li>该层的主要任务是：定义了一些传输数据的协议和端口号（如HTTP的端口80等），TCP,UDP。 主要是从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做报文段(Segment)</li>
<li>电脑通过通过端口号识别某一个应用程序,每一个应用程序都有很多的服务，每一个服务对应着一个端口号</li>
</ul>
<p><strong>会话层</strong></p>
<ul>
<li>建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>会话层是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理</li>
<li>通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）</li>
<li><font color="#990000">数据的传输是在会话层完成的，而不是传输层，传输层只是定义了数据传输的协议</font></li>
</ul>
<p><strong>表示层</strong></p>
<ul>
<li>对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>表示层对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等</li>
<li>可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换</li>
<li>表示层的任务：数据格式转换（可以理解成iOS中将c语言的char字符转换成OC语言的NSString）</li>
</ul>
<p><strong>应用层</strong></p>
<ul>
<li>允许访问OSI环境的手段（应用协议数据单元APDU）</li>
<li>应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作</li>
<li>是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务</li>
</ul>
<h1 id="单工-半双工-全双工"><a href="#单工-半双工-全双工" class="headerlink" title="单工,半双工,全双工"></a>单工,半双工,全双工</h1><ul>
<li>单工：单工就是指A只能发信号，而B只能接收信号，通信是单向的。</li>
<li>半双工：指一个时间段内只有一个动作发生，举个简单例子，一天窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。早期的对讲机、以及早期集线器等设备都是实行半双工的产品。随着技术的不断进步，半双工会逐渐退出历史舞台。</li>
<li>全双工：指交换机在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的交换机都支持全双工。</li>
</ul>
<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p><strong>IP地址</strong></p>
<p>IP地址:&lt;网络号&gt;&lt;主机号&gt;.</p>
<ul>
<li>A类地址：以0开头，第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；</li>
<li>B类地址：以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</li>
<li>C类地址：以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</li>
</ul>
<p><strong>私有（保留）地址</strong></p>
<ul>
<li>A类：10.0.0.0——10.255.255.255</li>
<li>B类：172.16.0.0——172.31.255.255</li>
<li>C类：192.168.0.0——192.168.255.255</li>
</ul>
<p><strong>子网划分</strong></p>
<p>三级ip地址：&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;</p>
<h1 id="TCP-amp-UDP-传输层"><a href="#TCP-amp-UDP-传输层" class="headerlink" title="TCP&amp;UDP(传输层)"></a>TCP&amp;UDP(传输层)</h1><p><strong>TCP三次握手与四次挥手</strong></p>
<p>主要因为这是一次全双工的，双方都需要证明自己有发送和接收的能力。握手只需要三次是因为服务端的SYN和ACK可以一次发送给客户端。</p>
<p><img src="TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<p>为什么TCP客户端最后还要发一次确认呢？</p>
<p>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<p><img src="TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。</li>
<li>服务器收到连接释放报文，发出确认报文，服务端就进入了CLOSE-WAIT（关闭等待）状态。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认。此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。</li>
</ol>
<p>为什么客户端最后还要等待2MSL？</p>
<ol>
<li>保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</li>
<li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</li>
</ol>
<p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p>
<ol>
<li>当主机甲想要释放连接时会发FIN给主机B。</li>
<li>主机乙收到甲发送的FIN，表示收到了，就会发送ACK回复。</li>
<li>但这是乙可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到乙数据发送完了，才会发送FIN给主机A.</li>
<li>A收到B发来的FIN，知道B的数据也发送完了，回复ACK，A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。</li>
</ol>
<p><strong>TCP和UDP</strong></p>
<p><em>UDP</em></p>
<ul>
<li>面向无连接</li>
<li>有单播，多播，广播的功能：支持一对一，一对多，多对多，多对一的方式。</li>
<li>面向报文：发送方对应用程序的报文添加首部后就向下交付IP层，既不合并，也不拆分，因此应用程序必须选择合适大小的报文。</li>
<li>不可靠性：不需建立连接，不关心接收端是否接收到信息。适合实时性要求高的场景（比如电话会议）。</li>
<li>头部开销小，传输数据报文时是很高效的。</li>
</ul>
<p><em>TCP</em></p>
<ul>
<li>面向连接：三次握手四次挥手。</li>
<li>仅支持单播传输：点对点。</li>
<li>面向字节流</li>
<li>可靠传输：给每个包一个序列号，接收端按序接收，然后发送确认ACK，发送端决定是否重传。</li>
<li>拥塞控制</li>
</ul>
<p><strong>TCP流量控制</strong></p>
<p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口实现流量控制。</p>
<p>发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。</p>
<p><strong>TCP拥塞控制</strong></p>
<p>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p><em>慢开始和拥塞避免</em></p>
<ol>
<li>在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。</li>
<li>在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。</li>
<li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</li>
</ol>
<p><em>快重传和快恢复</em></p>
<ul>
<li>快重传：发送端只要一连收到三个重复的 ACK 即可断定有分组丢失了，就应立即重传丢失的报文段而不必继续等待为该报文段设置的重传计时器的超时</li>
<li>快恢复：<ol>
<li>当发送端收到连续三个重复的 ACK 时，就重新设置慢开始门限 ssthresh。</li>
<li>与慢开始不同之处是 swnd 不是设置为 1，而是设置为 ssthresh + 3 * MSS。</li>
<li>若收到的重复的 ACK 为 n 个（n &gt; 3），则将 cwnd 设置为 ssthresh + n * MSS。</li>
<li>若发送窗口值还容许发送报文段，就按拥塞避免算法继续发送报文段。</li>
<li>若收到了确认新的报文段的 ACK，就将 swnd 缩小到 ssthresh。</li>
</ol>
</li>
</ul>
<h1 id="http-amp-https"><a href="#http-amp-https" class="headerlink" title="http&amp;https"></a>http&amp;https</h1><p><strong>Http码</strong></p>
<ul>
<li>1xx （临时响应）请求正在处理，可能需要请求者执行某些操作。</li>
<li>2xx （成功）表示成功处理了请求的状态代码。</li>
<li>3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</li>
<li>4xx （客户端错误） 这些状态代码表示客户端请求可能出错，服务器无法处理。</li>
<li>5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</li>
</ul>
<p><strong>http和https的区别与联系</strong></p>
<p>HTTP协议传输的数据都是明文，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输，于是通过 SSL 协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http是无状态(每个请求都是完全独立的，每个请求包含了处理这个请求所需的完整的数据，发送请求不涉及到状态变更，也不依赖之前的状态)的；HTTPS协议是由SSL+HTTP协议构建的，http是无状态的，ssl/tls是有状态的。</li>
</ol>
<p><img src="HTTPS%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.jpg" alt="https"></p>
<p><strong>Http1.0, 1.1, 2.0</strong></p>
<ul>
<li>HTTP 1.1支持长连接，使用长连接的情况下，连接成功后客户端和服务器之间用于的TCP连接不会关闭，一段时间内如果客户端再次访问这个服务器，会继续使用这一条已经建立的连接(Connection:keep-alive)。HTTP 1.0规定浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立TCP连接，完成处理后立即断开TCP连接。</li>
<li>HTTP 1.0认为每台服务器都绑定一个唯一的IP地址，虚拟主机发展后一台物理服务器上可以存在多个虚拟主机，它们共享一个IP地址，因此添加了主机host参数。</li>
<li>HTTP 1.1在1.0的基础上加入了一些cache的新特性。HTTP 1.0使用Expires头标识缓存的有效期，其值是一个绝对时间，依赖客户端的本地时间。从HTTP 1.1 开始使用Cache-Control头表示缓存状态。</li>
<li>新增了24个状态响应码，如 410 表示服务器上的某个资源被永久性的删除。</li>
<li>http 1.1在请求头引入了range头，支持断点续传。</li>
</ul>
<p>HTTP 2.0:</p>
<ul>
<li>HTTP 1.x的解析基于文本，HTTP 2.0在应用层和传输层之间增加一个二进制分帧层，它把原来 HTTP 1.x的header和body用二进制重新封装了一层。</li>
<li>HTTP 2.0多路复用基于二进制分帧，在同一域名下所有访问都从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据帧id重新组装起来。</li>
<li>头部压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0要求客户端和服务器同时维护和更新一个包含之前见过的头字段的索引列表(cache)，之后传输的头信息会基于此表编码和解码。</li>
<li>服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
<p><strong>HTTP是不保存状态的协议，如何保存用户状态?</strong></p>
<p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，使用Session可以服务端记录用户的状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p>
<ul>
<li>Cookie: 浏览器的一种数据存储方式。</li>
<li>Session: 会话。服务器使用Session把用户的信息临时保存在服务器上，用户离开网站后Session会被销毁。客户端得到这个Session Id后可以存储在Cookie里。这里有个缺陷，如果Web服务器有许多台，那么下次请求如果请求到了另一个服务器上的时候就验证不了Session了。</li>
<li>Token: 也用来做身份验证，但是服务器不需要存储Token信息，服务器会在用户登录成功后返回一个签名后的Token回来，下次请求带上，服务器再解密验证即可。</li>
</ul>
<h1 id="浏览器访问http网址"><a href="#浏览器访问http网址" class="headerlink" title="浏览器访问http网址"></a>浏览器访问http网址</h1><ol>
<li>客户端浏览器输入URL后，检查本地是否有DNS缓存，缓存的查找顺序为：浏览器缓存–&gt;系统缓存–&gt;路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器。</li>
<li>应用层客户端浏览器根据ip及相应的端口号，构造一个http请求，包括请求头和请求体，封装在TCP包里。</li>
<li>然后传输层TCP通过三次握手建立连接(SYN–&gt;ACK/SYN–&gt;ACK)，TCP进行分割数据包，输入到网络层。</li>
<li>网络层ip协议通过查找路由表决定通过哪个路径到达服务器，把数据包发送给服务器。</li>
<li>数据到达数据链路层，将数据发送给指定mac地址的服务器。</li>
</ol>
<h1 id="交换机、路由器、网关"><a href="#交换机、路由器、网关" class="headerlink" title="交换机、路由器、网关"></a>交换机、路由器、网关</h1><p><strong>交换机</strong></p>
<p>交换机工作于数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>
<p>交换机被广泛应用于二层网络交换，俗称“二层交换机”。</p>
<p>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层和第七层，并因此而得名。</p>
<p><strong>路由器</strong></p>
<p>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host到host之间的传输路径），这个过程称为由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。</p>
<p>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</p>
<p>路由器与交换器的差别，路由器是属于OSI第三层(网络层)的产品，交换器是OSI第二层的产品(这里特指二层交换机)。</p>
<p><strong>网关</strong></p>
<p>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<p>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。</p>
<p>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。</p>
<p>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>
<p><strong>网桥</strong></p>
<p>简单的说网桥就是个硬件网络协议翻译器，假设你有2台电脑，一台兼容机安装windows，一台是Apple安装OS2，那么两台电脑之间是默认网络协议是不同的，兼容机可能只会说TCP/IP，苹果机只会说Apple talk，就好象两个外国人都不会说对方的语言，怎么办？找个翻译，网桥就是翻译。</p>
<p>在386、486时代网桥可能是一台安装了协议转换程序的电脑，如今交换机也包含这个功能。今天的操作系统之间为了互相交流，支持更多的协议，操作系统自己就可以是网桥，现在网桥这个概念已经淡出了。更多是所谓的桥接、转发、协议二次封装。</p>
<p>网桥也可以说相当一个端口少的二层交换机，再者网桥主要由软件实现，交换机主要由硬件实现！</p>
<p><strong>网络接口卡（网卡）</strong></p>
<ol>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。</li>
</ol>
<p><strong>路由表</strong></p>
<p>路由表是用来决定如何将一个数据包从一个子网传送到另一个子网的，换句话说就是用来决定从一个网卡接收到的包应该送到哪一个网卡上去。</p>
<p>路由表的每一行至少有目标网络号、子网掩码、到这个子网应该使用的网卡这三条信息。当路由器从一个网卡接收到一个包时，它扫描路由表的每一行，用里面的子网掩码与数据包中的目标IP地址做逻辑与运算（&amp;）找出目标网络号。如果得出的结果网络号与这一行的网络号相同，就将这条路由表六下来作为备用路由。如果已经有备用路由了，就载这两条路由里将网络号最长的留下来，另一条丢掉（这是用无分类编址CIDR的情况才是匹配网络号最长的，其他的情况是找到第一条匹配的行时就可以进行转发了）。如此接着扫描下一行直到结束。如果扫描结束仍没有找到任何路由，就用默认路由。确定路由后，直接将数据包送到对应的网卡上去。在具体的实现中，路由表可能包含更多的信息为选路由算法的细节所用。</p>
<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SSH的英文全称为Secure Shell，是IETF（Internet Engineering Task Force）的Network Working Group所制定的一族协议，其目的是要在非安全网络上提供安全的远程登录和其他安全网络服务。用于在主机之间建立起安全连接, 并加密传输内容, 以达到安全的远程访问, 操作以及数据传输的目的。它只是一种协议，存在多种实现，既有商业实现，也有开源实现。比较常用的是OpenSSH，它是自由软件，应用非常广泛。</p>
<p>SSH协议目前有SSH1和SSH2两个主流版本，SSH2协议兼容SSH1，强烈建议使用SSH2版本。目前实现SSH1和SSH2协议的主要软件有OpenSSH 和SSH Communications Security Corporation　公司的SSH Communications 软件。前者是OpenBSD组织开发的一款免费的SSH软件，后者是商业软件，因此在linux、FreeBSD、OpenBSD 、NetBSD等免费类UNIX系统种，通常都使用OpenSSH作为SSH协议的实现软件。</p>
<p>SSH主要有两个特点: 1. 安全性 2. 传输速度快。与FTP、POP 和 Telnet 等传统网络服务使用明文传输数据、命令和口令不同，SSH可以对所有传输的数据进行加密，能够防止 DNS 欺骗和 IP 欺骗。</p>
<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>
<p>SSH支持两种认证方式：密码认证和密钥认证。</p>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。</p>
<p>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p>
<p>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p>
<p>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p>
<h2 id="密码认证"><a href="#密码认证" class="headerlink" title="密码认证"></a>密码认证</h2><ol>
<li>客户端向服务端发起登录请求，服务端将自己的公钥返回给客户端</li>
<li>客户端输入登录口令，口令经服务端公钥加密后发送到服务端</li>
<li>服务端接收到加密口令后使用私钥解密，如果密码正确则登录成功</li>
</ol>
<p>第一次登录对方主机时，系统会出现下面的提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line">The authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？</p>
<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p>
<p>远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p>
<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>
<h2 id="密钥认证"><a href="#密钥认证" class="headerlink" title="密钥认证"></a>密钥认证</h2><ol>
<li>客户端发起密钥连接请求，并上传身份信息</li>
<li>服务端收到请求后，在可信列表中查询客户端，若无此客户端则断开连接，否则发送一串随机问询码，该问询码使用此客户端公钥加密处理</li>
<li>客户端收到加密问询码后，使用私钥解密出问询码再用通信session对问询码加密并传送给服务端</li>
<li>服务端解密问询码并判定客户端身份安全与否，安全则建立连接</li>
</ol>
<p>登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<p>因此，密钥认证首要要将客户端的公钥放置在服务端的授权登录列表中。密钥认证一般不需要密码，但客户端可在生成密钥时指定密钥加密密码，这样在与服务端建立连接时需要输入加密密码来解密私钥，防止因私钥泄露带来的安全问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成密钥对</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将公钥传送到远程主机host</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-copy-id user@host</span></span><br></pre></td></tr></table></figure>

<p>以后再登录，就不需要输入密码了。</p>
<p>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>然后，重启远程主机的ssh服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ubuntu系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service ssh restart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> debian系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/init.d/ssh restart</span></span><br></pre></td></tr></table></figure>

<h2 id="authorized-keys文件"><a href="#authorized-keys文件" class="headerlink" title="authorized_keys文件"></a>authorized_keys文件</h2><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>
<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host <span class="string">&#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27;</span> &lt; ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>$ ssh user@host</code>表示登录远程主机；</li>
<li><code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>表示登录后在远程shell上执行的命令：</li>
<li><code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；</li>
<li><code>cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件~/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。</li>
</ol>
<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>
<h1 id="SSL、TLS、SSH-amp-HTTPS"><a href="#SSL、TLS、SSH-amp-HTTPS" class="headerlink" title="SSL、TLS、SSH&amp;HTTPS"></a>SSL、TLS、SSH&amp;HTTPS</h1><h2 id="SSL（Secure-Socket-Layer）"><a href="#SSL（Secure-Socket-Layer）" class="headerlink" title="SSL（Secure Socket Layer）"></a>SSL（Secure Socket Layer）</h2><ul>
<li>SSL是传输层之上，对Socket连接的加密协议。</li>
<li>SSL多用于Internet上，在浏览器和服务器之间的安全传输。</li>
<li>OpenSSL是SSL/TLS的开源实现。</li>
</ul>
<h2 id="TLS（Transport-Layer-Security）"><a href="#TLS（Transport-Layer-Security）" class="headerlink" title="TLS（Transport Layer Security）"></a>TLS（Transport Layer Security）</h2><ul>
<li>TLS也是传输层之上的加密协议。</li>
<li>TLS可用于任何两个应用程序之间的安全传输。</li>
<li>OpenSSL是SSL/TLS的开源实现。</li>
</ul>
<h2 id="SSH（Secure-Shell）"><a href="#SSH（Secure-Shell）" class="headerlink" title="SSH（Secure Shell）"></a>SSH（Secure Shell）</h2><ul>
<li>SSH是应用层的通信加密协议，往往用于远程登录的会话。</li>
<li>OpenSSH是SSH的开源实现。</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul>
<li>在传输层使用SSL/TLS加密的HTTP</li>
<li>与HTTP类似，HTTPS本身是应用层的协议。</li>
<li>同一台Web服务器，往往同时支持HTTP和HTTPS，这是分别通过80端口和443端口实现的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Nginx学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-16 11:30:31" itemprop="dateCreated datePublished" datetime="2018-06-16T11:30:31+08:00">2018-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/" itemprop="url" rel="index"><span itemprop="name">后台</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          
            <span id="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Nginx学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/16/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li>安装gcc g++的依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential</span><br><span class="line">apt-get install libtool</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装pcre依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装zlib依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装ssl依赖库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openssl</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>安装nginx</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：这里可能会报错，提示“pcre.h No such file or directory”,具体详见：http://stackoverflow.com/questions/22555561/error-building-fatal-error-pcre-h-no-such-file-or-directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要安装 libpcre3-dev,命令为：sudo apt-get install libpcre3-dev</span></span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta">#</span><span class="bash">启动nginx：</span></span><br><span class="line">sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：-c 指定配置文件的路径，不加的话，nginx会自动加载默认路径的配置文件，可以通过 -h查看帮助命令。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看nginx进程：</span></span><br><span class="line">ps -ef|grep nginx</span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">sudo ./sbin/nginx -s reload</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>配置</li>
</ol>
<p>在conf目录下新建一个ihasy.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">upstream ihasy  &#123;</span><br><span class="line">    server 127.0.0.1:9001; #Tornado</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Start www.ihasy.com ##</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.ihasy.com ihasy.com;</span><br><span class="line"></span><br><span class="line">    #root   html;</span><br><span class="line">    #index  index.html index.htm index.py index;</span><br><span class="line"></span><br><span class="line">    ## send request back to Tornado ##</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;ihasy;</span><br><span class="line"></span><br><span class="line">        #Proxy Settings</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout      90;</span><br><span class="line">        proxy_send_timeout         90;</span><br><span class="line">        proxy_read_timeout         90;</span><br><span class="line">        proxy_buffer_size          4k;</span><br><span class="line">        proxy_buffers              4 32k;</span><br><span class="line">        proxy_busy_buffers_size    64k;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">## End www.ihasy.com ##</span><br></pre></td></tr></table></figure>

<p>在nginx.conf中添加<code>include ihasy.conf</code>,保存，重启nginx,即可实现反向代理。</p>
<p>nginx.conf中默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">user  root;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#39;s document root</span><br><span class="line">        # concurs with nginx&#39;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ &#x2F;\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location &#x2F; &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><img src="正向代理和反向代理.png"/>

<p>正向代理:是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>
<p>正向代理的用途：</p>
<ul>
<li>访问原来无法访问的资源，如google</li>
<li>可以做缓存，加速访问资源</li>
<li>对客户端访问授权，上网进行认证</li>
<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>
</ul>
<p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>反向代理的作用：</p>
<ul>
<li>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</li>
<li>负载均衡，通过反向代理服务器来优化网站的负载</li>
</ul>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>Nginx之所以能同时处理大量的请求，原因在于它采用了十分巧妙的事件驱动机制。</p>
<p>作为一个Web服务器，要同时处理多个请求，不可避免地要面对这么一个问题，如何同时处理像磁盘和网络等等的I/O请求，即如何实现I/O复用。为了解决该问题，操作系统在很久之前就开始提供诸如“select”、“poll”等系统调用。Apache HTTP的多处理模块(MPM，multi-processing module)就会用到这些系统调用。但是，select/poll为了识别出哪些文件或者socket已经准备就绪，必须将所有已注册的文件描述符(fd)一个个地检查一遍。如果注册列表越长，那么每次的扫描所需的时间也越长。而Nginx的I/O复用机制使用的是“epoll”这个基于事件驱动的系统调用。因为epoll会在系统内核管理和监听这些文件描述符(fd)，并自动把就绪的加入到Ready队列当中。所以，程序只需在需要时往Ready队列中取出一个进行处理即可，而不用切换到内核态，然后一个个地检查，然后又切换回用户态。这样，无论需要注册监听的I/O有多少，都不会影响程序的运行效率。为了避免select/poll带来的线性增长的负担，Apache HTTP必须将这些IO分散到各个进程/线程中处理，这样势必会造成占用内存的增长。但是，Nginx可以通过利用“epoll”，保证可以使用一个进程/线程完成所有请求的处理，这样可以大大减少内存的占用，从而使应对上万并发请求成为可能。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>语法规则： location [=|<del>|</del>*|^~] /uri/ { … }</p>
<ul>
<li>= 开头表示精确匹配</li>
<li>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。一旦匹配成功，那么 Nginx 就停止去寻找其他的 Location 块进行匹配了(其他可能没有这个特性)</li>
<li>~ 开头表示区分大小写的正则匹配</li>
<li>~*  开头表示不区分大小写的正则匹配</li>
<li>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配 的正则</li>
<li>/ 通用匹配，任何请求都会匹配到。</li>
<li>多个location配置的情况下匹配顺序为：首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;  </span><br><span class="line">   #规则A  </span><br><span class="line">&#125;  </span><br><span class="line">location &#x3D; &#x2F;login &#123;  </span><br><span class="line">   #规则B  </span><br><span class="line">&#125;  </span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;  </span><br><span class="line">   #规则C  </span><br><span class="line">&#125;  </span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;  </span><br><span class="line">   #规则D  </span><br><span class="line">&#125;  </span><br><span class="line">location ~* \.png$ &#123;  </span><br><span class="line">   #规则E  </span><br><span class="line">&#125;  </span><br><span class="line">location !~ \.xhtml$ &#123;  </span><br><span class="line">   #规则F  </span><br><span class="line">&#125;  </span><br><span class="line">location !~* \.xhtml$ &#123;  </span><br><span class="line">   #规则G  </span><br><span class="line">&#125;  </span><br><span class="line">location &#x2F; &#123;  </span><br><span class="line">   #规则H  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>那么产生的效果如下：</p>
<ul>
<li>访问根目录/， 比如<a target="_blank" rel="noopener" href="http://localhost/">http://localhost/</a> 将匹配规则A</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/login">http://localhost/login</a> 将匹配规则B，<a target="_blank" rel="noopener" href="http://localhost/register">http://localhost/register</a> 则匹配规则H</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/static/a.html">http://localhost/static/a.html</a> 将匹配规则C</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/a.gif">http://localhost/a.gif</a>, <a target="_blank" rel="noopener" href="http://localhost/b.jpg">http://localhost/b.jpg</a> 将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用，而 <a target="_blank" rel="noopener" href="http://localhost/static/c.png">http://localhost/static/c.png</a> 则优先匹配到 规则C</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/a.PNG">http://localhost/a.PNG</a> 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/a.xhtml">http://localhost/a.xhtml</a> 不会匹配规则F和规则G，<a target="_blank" rel="noopener" href="http://localhost/a.XHTML%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99G%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E3%80%82%E8%A7%84%E5%88%99F%EF%BC%8C%E8%A7%84%E5%88%99G%E5%B1%9E%E4%BA%8E%E6%8E%92%E9%99%A4%E6%B3%95%EF%BC%8C%E7%AC%A6%E5%90%88%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%83%B3%E6%83%B3%E7%9C%8B%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%93%AA%E9%87%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E3%80%82">http://localhost/a.XHTML不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</a></li>
<li>访问 <a target="_blank" rel="noopener" href="http://localhost/category/id/1111">http://localhost/category/id/1111</a> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</li>
<li>所以实际使用中，通常至少有三个匹配规则定义，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。  </span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页  </span><br><span class="line"># 第一个必选规则  </span><br><span class="line">location &#x3D; &#x2F; &#123;  </span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项  </span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用  </span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;  </span><br><span class="line">    root &#x2F;webroot&#x2F;static&#x2F;;  </span><br><span class="line">&#125;  </span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;  </span><br><span class="line">    root &#x2F;webroot&#x2F;res&#x2F;;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器  </span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握  </span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了  </span><br><span class="line">location &#x2F; &#123;  </span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h2 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>负载均衡配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream linuxidc &#123;</span><br><span class="line">    server 10.0.6.108:7080;</span><br><span class="line">    server 10.0.0.85:8980;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    root  html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;linuxidc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="weight（权重）"><a href="#weight（权重）" class="headerlink" title="weight（权重）"></a>weight（权重）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream linuxidc &#123;</span><br><span class="line">    server 10.0.0.77 weight&#x3D;5;</span><br><span class="line">    server 10.0.0.88 weight&#x3D;10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ip-hash（访问ip）"><a href="#ip-hash（访问ip）" class="headerlink" title="ip_hash（访问ip）"></a>ip_hash（访问ip）</h3><p>每一个请求按訪问ip的hash结果分配。这样每一个訪客固定訪问一个后端服务器，能够解决session的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favresin &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 10.0.0.10:8080;</span><br><span class="line">    server 10.0.0.11:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="url-hash（第三方）"><a href="#url-hash（第三方）" class="headerlink" title="url_hash（第三方）"></a>url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，使每一个url定向到同一个后端服务器。后端服务器为缓存时比較有效。注意：在upstream中加入hash语句。server语句中不能写入weight等其他的參数，hash_method是使用的hash算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream resinserver &#123;</span><br><span class="line">    server 10.0.0.10:7777;</span><br><span class="line">    server 10.0.0.11:8888;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h3><p>按后端服务器的响应时间来分配请求。响应时间短的优先分配,与weight分配策略相似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favresin &#123;</span><br><span class="line">    server 10.0.0.10:8080;</span><br><span class="line">    server 10.0.0.11:8080;</span><br><span class="line">    fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>upstream还能够为每一个设备设置状态值，这些状态值的含义分别例如以下：</p>
<ul>
<li>down 表示单前的server临时不參与负载.</li>
<li>weight 默觉得1.weight越大，负载的权重就越大。</li>
<li>max_fails ：同意请求失败的次数默觉得1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</li>
<li>fail_timeout : max_fails次失败后。暂停的时间。</li>
<li>backup： 其他全部的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend&#123; #定义负载均衡设备的Ip及设备状态 </span><br><span class="line">      ip_hash; </span><br><span class="line">      server 10.0.0.11:9090 down;</span><br><span class="line">      server 10.0.0.11:8080 weight&#x3D;2;</span><br><span class="line">      server 10.0.0.11:6060;</span><br><span class="line">      server 10.0.0.11:7070 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="虚拟主机配置"><a href="#虚拟主机配置" class="headerlink" title="虚拟主机配置"></a>虚拟主机配置</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>通常情况下,为了使每个服务器可以供更多用户使用,可以将一个服务器分为很多虚拟的子服务器,每个子服务器是相互独立的.这些服务器是根据虚拟化技术分出来的,这样,一台服务器可以虚拟成很多台子服务器,叫做虚拟主机.nginx下，一个server标签就是一个虚拟主机。</p>
<p>配置方法:</p>
<ol>
<li>基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</li>
<li>基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</li>
<li>基于ip的虚拟主机，几乎不用。</li>
</ol>
<h2 id="基于域名"><a href="#基于域名" class="headerlink" title="基于域名"></a>基于域名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name www.yong.com;</span><br><span class="line">   index index.html;</span><br><span class="line">   root &#x2F;data&#x2F;www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name bbs.yong.com;</span><br><span class="line">   index index.html;</span><br><span class="line">   root &#x2F;data&#x2F;bbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于端口"><a href="#基于端口" class="headerlink" title="基于端口"></a>基于端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8000;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8001;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;bbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于ip地址"><a href="#基于ip地址" class="headerlink" title="基于ip地址"></a>基于ip地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 192.168.20.20:80;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 192.168.20.21:80;</span><br><span class="line">    server_name www.yong.com;</span><br><span class="line">    root &#x2F;data&#x2F;bbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>nginx实现代理上网，有三个关键点必须注意，其余的配置跟普通的nginx一样\</p>
<ol>
<li>增加dns解析resolver</li>
<li>增加无server_name名的server</li>
<li>proxy_pass指令</li>
<li>电脑配置配置文件中的地址和端口为代理地址和端口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user www;</span><br><span class="line">worker_processes 1;</span><br><span class="line">error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log debug;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8088;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;$http_host$request_uri;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理，外部机器通过网关访问网关后面服务器上的内容，网关起到了反向代理的功能，我们平时通过浏览器访问远程的web服务器大都是这样实现的。</p>
<p>nginx反向代理的指令不需要新增额外的模块，默认自带proxy_pass指令，只需要修改配置文件就可以实现反向代理。配置前的准备工作:后端run apache服务的ip和端口，确保可以通过<a href="http://ip:port能访问到自己的网站">http://ip:port能访问到自己的网站</a>.</p>
<p>添加配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">upstream apachephp  &#123;</span><br><span class="line">    server ip:8080; #Apache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.quancha.cn;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;quancha.access.log  main;</span><br><span class="line">    error_log  logs&#x2F;quancha.error.log;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm index.php;</span><br><span class="line"></span><br><span class="line">    ## send request back to apache ##</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass  http:&#x2F;&#x2F;apachephp;</span><br><span class="line"></span><br><span class="line">        #Proxy Settings</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        proxy_connect_timeout      90;</span><br><span class="line">        proxy_send_timeout         90;</span><br><span class="line">        proxy_read_timeout         90;</span><br><span class="line">        proxy_buffer_size          4k;</span><br><span class="line">        proxy_buffers              4 32k;</span><br><span class="line">        proxy_busy_buffers_size    64k;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="部署SpringBoot"><a href="#部署SpringBoot" class="headerlink" title="部署SpringBoot"></a>部署SpringBoot</h1><p>Nginx配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;localhost:8080;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot的配置文件中配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">remote-ip-header:</span> <span class="string">x_forwarded_for</span></span><br><span class="line">    <span class="attr">protocol-header:</span> <span class="string">x-forwarded-proto</span></span><br><span class="line">    <span class="attr">port-header:</span> <span class="string">X-Forwarded-Port</span></span><br><span class="line">  <span class="attr">use-forward-headers:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="comment">#8080端口只能被本机访问</span></span><br></pre></td></tr></table></figure>

<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><h2 id="映射本地文件夹"><a href="#映射本地文件夹" class="headerlink" title="映射本地文件夹"></a>映射本地文件夹</h2><p>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;hearing &#123;</span><br><span class="line">    autoindex on;</span><br><span class="line">    root &#x2F;home&#x2F;hearing&#x2F;Downloads&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>nginx -s reload</code>重新载入配置，可以在<code>localhost:80/hearing/</code>访问到<code>/home/hearing/Downloads/hearing/</code>下的文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/" class="post-title-link" itemprop="url">夜的随笔-二</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-15 16:15:46" itemprop="dateCreated datePublished" datetime="2018-06-15T16:15:46+08:00">2018-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%96%87%E5%AD%97/" itemprop="url" rel="index"><span itemprop="name">文字</span></a>
                </span>
            </span>

          
            <span id="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/" class="post-meta-item leancloud_visitors" data-flag-title="夜的随笔-二" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/15/%E5%A4%9C%E7%9A%84%E9%9A%8F%E7%AC%94-%E4%BA%8C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <center>*文/苍耳*</center>

<p>走在昏黄的路灯下，一步一步地，走过去了，也未曾留下什么脚印。树影斑驳的小路上依旧残留着些许枯叶，无论什么季节，它们始终静静地躺在那里，等待着变腐烂，守候着诗人低吟。死如秋叶，也无人问津。</p>
<p>回到宿舍忽然很想重温火影，他完结的那天总有种怅然若失的感觉，那个傻乎乎的鸣人，总是有一种让人情不自禁地想要去亲近他的气质。相伴十余年，尚记得曾在小摊上找到一张有好几百集的盗版CD的时候，兴奋地可以看上一整天，如痴如醉，如梦难醒。</p>
<p>当然自然没看成，明天还要上课吧。躺在床上想听会歌，却循环到了久石让。刹那间便有种难以言明的伤感，所有曾迷恋过宫崎骏的动画和久石让的音乐的人大概都能理解这种感觉吧。当音乐响起，不禁有种恍若隔世的感觉，童年，少年，以及所谓的青春，都被衔接成一段段的旋律，每个音符，都藏着某些不为人知的往事。那曾是所有青春年少的日子里，与我朝夕相伴的挚友，在流金岁月里，如一杯清水，一曲平静。</p>
<p>如今渐渐少有写东西的时间，很长一段时间里都迷上了小说，大概是觉得自己的生活里缺少了许多的东西吧，说白了是贪心，看过了这么多的故事，我如一个傻子般沉浸在别人的幸福里，却从未想过，我自己的生活，究竟是什么。披着一层伪装，然后戴上一套面具，推开门，都是一天。</p>
<p>天涯海角的邂逅，陌生人之间亦可相谈甚欢，曾以为相逢即是缘，而今想来，世上哪会有如此多的缘分，许多，大抵都是相逢一笑，擦肩路人而已。</p>
<p>或许是从小孤独惯了，所以对许多东西都太过在意，结果自是相反的，在人生这条路上，都被我越拉越远。</p>
<p>成长的代价，便是越来越少的时间去做喜欢的事情，而且必须毫无怨言，因为活着已不仅是为了自己。如今也只有在夜深人静难以入眠的时候，或者是独自一人找个地方独饮的时候，久违地矫情一把，当一个破落诗人，举杯饮酒，附庸风雅，好好地犒劳一下自己心中潜藏已久的小情绪，清一下往事，倒一碗矫情，一饮而尽。</p>
<p>想起一个朋友，和两杯酒，许是人声鼎沸的小店，或者静若可闻的深夜，一碟小菜，久饮不散。杯中那倒影，荡漾着，击碎了流光。</p>
<p>一曲循环，也终有尽时。爱深了这些音乐，半随忧伤，半入流年。这一路走来，虽然不长，却也都有故事。一直不擅长说话，也讲不清故事，即便相识，也总是重复着相逢又陌路的遗憾，随着汹涌的浪潮，消失在时间海里。</p>
<p>但你的故事，我都听着。</p>
<p>一直都喜欢这句话:”不困于心，不乱于情。不畏将来，不念过往。”</p>
<p>如此，安好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/15/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/15/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">后台开发理论笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-15 16:12:32" itemprop="dateCreated datePublished" datetime="2018-06-15T16:12:32+08:00">2018-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%90%8E%E5%8F%B0/" itemprop="url" rel="index"><span itemprop="name">后台</span></a>
                </span>
            </span>

          
            <span id="/2018/06/15/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="后台开发理论笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/15/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/15/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><font color="#990000">内容来源于网上</font></p>
<h1 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步/异步,阻塞/非阻塞"></a>同步/异步,阻塞/非阻塞</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>同步/异步主要针对C端.</p>
<ul>
<li><p>同步</p>
<p>  所谓同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。同步，就是我客户端（c端调用者）调用一个功能，该功能没有结束前，我（c端调用者）死等结果。</p>
</li>
<li><p>异步</p>
<p>  异步的概念和同步相对。当c端一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。就是我（c端调用者）调用一个功能，不需要知道该功能结果，该功能有结果后通知我（c端调用者）即回调通知。</p>
</li>
</ul>
<p>阻塞/非阻塞主要针对S端.</p>
<ul>
<li><p>阻塞</p>
<p>  阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有接收完数据或者没有得到结果之前，我不会返回。</p>
</li>
<li><p>非阻塞</p>
<p>  非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，通过select通知调用者.</p>
</li>
</ul>
<p>同步异步是作用在程序外部的，线程/进程是一直激活是否完成后才返回；阻塞和非阻塞是作用在IO网络函数内部的，外部的线程/进程进入睡眠或马上返回尽管得不到结果.</p>
<p>Node.js中的描述:</p>
<p>线程在执行中如果遇到磁盘读写或网络通信（统称为I/O 操作），通常要耗费较长的时间，这时操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为<strong>阻塞</strong>。当I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种I/O 模式就是通常的同步式I/O（Synchronous I/O）或阻塞式I/O （Blocking I/O）。  </p>
<p>相应地，异步式I/O （Asynchronous I/O）或非阻塞式I/O （Non-blocking I/O）则针对所有I/O 操作不采用阻塞的策略。当线程遇到I/O 操作时，不会以阻塞的方式等待I/O 操作的完成或数据的返回，而只是将I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成I/O 操作时，以事件的形式通知执行I/O 操作的线程，线程会在特定时候处理这个事件。为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。</p>
<p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，<span style="color:#ff0000;">这个线程所使用的CPU 核心利用率永远是100%</span>，I/O 以事件的方式通知。<span style="color:#ff0000;"></p>
<p>在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让CPU 资源不被阻塞中的线程浪费。</span>而在非阻塞模式下，线程不会被I/O 阻塞，永远在利用CPU。多线程带来的好处仅仅是在多核CPU 的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么Node.js 使用了单线程、非阻塞的事件编程模式。  </p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><ol>
<li><p>阻塞I/O（blocking I/O）</p>
</li>
<li><p>非阻塞I/O （nonblocking I/O）</p>
</li>
<li><p>I/O复用(select 和poll) （I/O multiplexing）</p>
</li>
<li><p>信号驱动I/O （signal driven I/O (SIGIO)）</p>
</li>
<li><p>异步I/O （asynchronous I/O (the POSIX aio_functions)）</p>
<p> 前四种都是同步，只有最后一种才是异步IO。</p>
</li>
</ol>
<h3 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h3><p>简介：进程会一直阻塞，直到数据拷贝完成</p>
<p>应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。如果数据没有准备好，一直等待.数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。</p>
<p>当使用socket()函数和WSASocket()函数创建套接字时，默认的套接字都是阻塞的。这意味着当调用Windows Sockets API不能立即完成时，线程处于等待状态，直到操作完成。</p>
<img src="后台开发理论笔记/阻塞IO.png"/>

<p>将可能阻塞套接字的Windows Sockets API调用分为以下四种:</p>
<ol>
<li>输入操作： recv()、recvfrom()、WSARecv()和WSARecvfrom()函数。以阻塞套接字为参数调用该函数接收数据。如果此时套接字缓冲区内没有数据可读，则调用线程在数据到来前一直睡眠。</li>
<li>输出操作： send()、sendto()、WSASend()和WSASendto()函数。以阻塞套接字为参数调用该函数发送数据。如果套接字缓冲区没有可用空间，线程会一直睡眠，直到有空间。</li>
<li>接受连接：accept()和WSAAcept()函数。以阻塞套接字为参数调用该函数，等待接受对方的连接请求。如果此时没有连接请求，线程就会进入睡眠状态。</li>
<li>外出连接：connect()和WSAConnect()函数。对于TCP连接，客户端以阻塞套接字为参数，调用该函数向服务器发起连接。该函数在收到服务器的应答前，不会返回。这意味着TCP连接总会等待至少到服务器的一次往返时间。</li>
</ol>
<p>使用阻塞模式的套接字，开发网络程序比较简单，容易实现。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下，使用阻塞模式来开发网络程序比较合适。</p>
<p>应对多客户机的网络应用，最简单的解决方式是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。</p>
<p>具体使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远大于线程，所以，如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的 CPU 资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。通常，使用 pthread_create () 创建新线程，fork() 创建新进程。</p>
<p>多线程/进程服务器同时为多个客户机提供应答服务。模型如下：</p>
<img src="后台开发理论笔记/阻塞IO-多线程.png"/>

<p>主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。</p>
<p>如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。</p>
<p>由此可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如apache，mysql数据库等。</p>
<p>但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用 IO 接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。</p>
<h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p>简介：非阻塞IO通过进程反复调用IO函数（多次系统调用，并马上返回）；在数据拷贝的过程中，进程是阻塞的；</p>
<p>我们把一个SOCKET接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。这样我们的I/O操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续测试，直到数据准备好为止。在这个不断测试的过程中，会大量的占用CPU的时间。</p>
<p>把SOCKET设置为非阻塞模式，即通知系统内核：在调用Windows Sockets API时，不要让线程睡眠，而应该让函数立即返回。在返回时，该函数返回一个错误代码。图所示，一个非阻塞模式套接字多次调用recv()函数的过程。前三次调用recv()函数时，内核数据还没有准备好。因此，该函数立即返回WSAEWOULDBLOCK错误代码。第四次调用recv()函数时，数据已经准备好，被复制到应用程序的缓冲区中，recv()函数返回成功指示，应用程序开始处理数据。</p>
<img src="后台开发理论笔记/非阻塞IO.png"/>

<h3 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h3><p>简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；</p>
<p>I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<img src="后台开发理论笔记/IO复用.png"/>

<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>简介：两次调用，两次返回；</p>
<p>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p>
<img src="后台开发理论笔记/信号驱动IO.png"/>

<h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>简介：数据拷贝的时候进程无需阻塞。</p>
<p>当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作</p>
<img src="后台开发理论笔记/异步IO.png"/>


<h3 id="5种IO模型的比较"><a href="#5种IO模型的比较" class="headerlink" title="5种IO模型的比较"></a>5种IO模型的比较</h3><img src="后台开发理论笔记/IO模型比较.png"/>

<h2 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h2><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<ol>
<li><p>单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p>
</li>
<li><p>对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p>
<p> 当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p>
</li>
<li><p>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p>
</li>
</ol>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</p>
<ol>
<li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。</li>
<li>poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</li>
</ol>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知</p>
<p>epoll的优点：</p>
<ol>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>
<li>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善.</li>
</ol>
<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition tolerance</li>
</ul>
<p>CAP定理: CAP三个指标不可能同时做到.</p>
<h2 id="Partition-tolerance"><a href="#Partition-tolerance" class="headerlink" title="Partition tolerance"></a>Partition tolerance</h2><p>Partition tolerance 中文叫做”分区容错”。大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p>G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p>
<h2 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h2><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。</p>
<p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。接下来，用户的读操作就会得到 v1。这就叫一致性。问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。这样的话，用户向 G2 发起读操作，也能得到 v1。</p>
<h2 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h2><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p>
<p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p>
<h2 id="C和A的矛盾"><a href="#C和A的矛盾" class="headerlink" title="C和A的矛盾"></a>C和A的矛盾</h2><p>一致性和可用性因为可能通信失败（即出现分区容错）所以会产生矛盾。</p>
<ul>
<li>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性。</li>
<li>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</li>
</ul>
<p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>
<h1 id="高性能并发"><a href="#高性能并发" class="headerlink" title="高性能并发"></a>高性能并发</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>业务数据库:数据水平分割(分区分表分库)、读写分离</li>
<li>业务应用:逻辑代码优化(算法优化)、公共数据缓存</li>
<li>应用服务器:反向静态代理、配置优化、负载均衡(apache分发，多tomcat实例),集群,分布式,微服务.</li>
<li>系统环境:JVM调优</li>
<li>页面优化:减少页面连接数、页面尺寸瘦身</li>
</ul>
<p>通用措施：</p>
<ol>
<li>动态资源和静态资源分离；</li>
<li>CDN；</li>
<li>负载均衡；</li>
<li>分布式缓存；</li>
<li>数据库读写分离或数据切分（垂直或水平）；</li>
<li>服务分布式部署。</li>
</ol>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。</p>
<p>动静分离的一种做法是将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求全部请求nginx服务器，达到动静分离的目标。</p>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域.</p>
<p>域名：</p>
<ul>
<li>主域名不同 <a target="_blank" rel="noopener" href="http://www.baidu.com/index.html">http://www.baidu.com/index.html</a> –&gt;<a target="_blank" rel="noopener" href="http://www.sina.com/test.js">http://www.sina.com/test.js</a> </li>
<li>子域名不同 <a target="_blank" rel="noopener" href="http://www.666.baidu.com/index.html">http://www.666.baidu.com/index.html</a> –&gt;<a target="_blank" rel="noopener" href="http://www.555.baidu.com/test.js">http://www.555.baidu.com/test.js</a> </li>
<li>域名和域名ip <a target="_blank" rel="noopener" href="http://www.baidu.com/index.html">http://www.baidu.com/index.html</a> –&gt;<a target="_blank" rel="noopener" href="http://180.149.132.47/test.js">http://180.149.132.47/test.js</a> </li>
</ul>
<p>端口：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.baidu.com:8080/index.html%E2%80%93&gt;">http://www.baidu.com:8080/index.html–&gt;</a> <a target="_blank" rel="noopener" href="http://www.baidu.com:8081/test.js">http://www.baidu.com:8081/test.js</a> </li>
</ul>
<p>协议：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.baidu.com:8080/index.html%E2%80%93&gt;">http://www.baidu.com:8080/index.html–&gt;</a> <a target="_blank" rel="noopener" href="https://www.baidu.com:8080/test.js">https://www.baidu.com:8080/test.js</a> </li>
</ul>
<p>备注：</p>
<ul>
<li>端口和协议的不同，只能通过后台来解决 </li>
<li>localhost和127.0.0.1虽然都指向本机，但也属于跨域</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">JVM学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-11 10:35:17" itemprop="dateCreated datePublished" datetime="2018-06-11T10:35:17+08:00">2018-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2018/06/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="JVM学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；</p>
<p>Java虚拟机管理的内存包括几个运行时数据内存：方法区、堆、虚拟机栈、本地方法栈、程序计数器，其中<font color="#FF0000">方法区和堆是由线程共享的数据区</font>，其他几个是线程隔离的数据区。</p>
<img src="内存模型.png"/>

<p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存，他可以看做是当前线程所执行的行号指示器。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码的指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器则为空。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域。</p>
<ul>
<li><p><font color="#990000">线程私有的内存</font>：</p>
<p>  由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，在任何一个确定的时间，一个处理器(对多核处理器来说是一个内核)只会执行一条线程中的指令。因此为了为了线程切换能够恢复到正确的执行位置上，每条线程都有一个独立的线程计数器，各条线程之间计数器互不影响，独立存储，我们叫这类内存区域线程私有的内存</p>
</li>
</ul>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p><font color="#990000">虚拟机栈描述的是Java方法执行的内存模型</font>：每个方法在执行的同时都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>栈内存就是虚拟机栈，或者说是虚拟机栈中局部变量表的部分。</p>
<p><font color="#990000">局部变量表存放了编辑期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（refrence）类型和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用两个局部变量空间，其余的数据类型只占用1个。</font></p>
<p>Java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机扩展时无法申请到足够的内存，就会跑出OutOfMemoryError异常。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈发挥的作用是非常类似的，他们的区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<font color="#990000">本地方法栈则为虚拟机使用到的Native方法服务</font></p>
<p>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryErroy异常</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>堆是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动的时候创建，此内存区域的<font color="#990000">唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存(基本数据类型除外)</font>。所有的对象实例和数组都在堆上分配。</p>
<p>Java堆是垃圾收集器管理的主要区域。Java堆细分为新生代和老年代</p>
<p>不管怎样，划分的目的都是为了更好的回收内存，或者更快地分配内存</p>
<p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有完成实例分配，并且堆也无法在扩展时将会抛出OutOfMemoryError异常。</p>
<p>Native堆的回收不收 java gc 的影响，一般需要手工进行回收。如果大量的使用非Java堆，则丢失了 Java 自动垃圾回收的特点。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区,方法区它用于<font color="#990000">储存已被虚拟机加载的类信息、用final修饰的常量、用static修饰的静态变量、String对象(常量池)和方法等数据</font>。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！</p>
<p>除了Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。它有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryErroy异常。</p>
<p><strong>运行时常量池：</strong></p>
<p>它是方法区的一部分。Class文件中除了有关的版本、字段、方法、接口等描述信息外、还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放.</p>
<p>Java语言并不要求常量一定只有编辑期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法.</p>
<p>当常量池无法再申请到内存时会抛出OutOfMemoryError异常.</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>当程序运行时，首先通过类装载器加载字节码文件，经过解析后装入方法区！在方法区中存了类的各种信息，包括类静态变量、常量及方法。对于同一个方法的调用，同一个类的不同实例调用的都是存在方法区的同一个方法。类变量的生命周期从程序开始运行时创建，到程序终止运行时结束！ </li>
<li>当程序中new一个对象时，这个对象存在堆中，对象的变量存在栈中，指向堆中的引用！对象的成员变量都存在堆中，当对象被回收时，对象的成员变量随之消失！ </li>
<li>当方法调用时，JVM会在栈中分配一个栈桢，存储方法的局部变量。当方法调用结束时，局部变量消失！</li>
</ol>
<ul>
<li>类变量：属于类的属性信息，与类的实例无关，多个实例共用同一个类变量，存在与方法区中。类变量用static修饰，包括静态变量和常量。静态变量有默认初始值，常量必须声明同时初始化。</li>
<li>成员变量：属于实例的变量，只与实例有关，写在类下面，方法外，非static修饰。成员变量会随着成员的创建而生存，随着成员的回收而销毁。</li>
<li>局部变量：声明在方法中，没有默认初始值，随着方法的调用而创建，存储于栈中，随着方法调用的结束而销毁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// a 和1 都在堆里</span></span><br><span class="line">    Student s = <span class="keyword">new</span> Student();<span class="comment">// s 和new d的Student()都在 堆里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;<span class="comment">//b 和 1 栈里面</span></span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();<span class="comment">// s2 在栈里， new的 Student() 在堆里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="hotspot虚拟机对象"><a href="#hotspot虚拟机对象" class="headerlink" title="hotspot虚拟机对象"></a>hotspot虚拟机对象</h1><p>HotSpot VM是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>1.检查</p>
<p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
<p>2.分配内存</p>
<p>接下来将为新生对象分配内存，为对象分配内存空间的任务等同于把一块确定的大小的内存从Java堆中划分出来。</p>
<p>假设Java堆中内存是绝对规整的，所有用过的内存放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做<font color="#990000">“指针碰撞”</font></p>
<p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<font color="#990000">“空闲列表”</font>。</p>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>在分配内存的时候会出现并发的问题，比如在给A对象分配内存的时候，指针还没有来得及修改，对象B又同时使用了原来的指针进行了内存的分片。</p>
<p>有两个解决方案：</p>
<ul>
<li>对分配的内存进行同步处理：CAS配上失败重试的方式保证更新操作的原子性</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行,即每个线程在java堆中分配一块小内存，称为本地缓冲区，那个线程需要分配内存，就需要在本地缓冲区上进行，只有当缓冲区用完并分配新的缓冲区的时候，才需要同步锁定，</li>
</ul>
<p>3.Init</p>
<p>执行new指令之后会接着执行Init方法，进行初始化，这样一个对象才算产生出来</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中储存的布局可以分为3块区域：对象头、实例数据和对齐填充</p>
<p>对象头包括两部分：</p>
<p>1.markword </p>
<p>第一部分markword,用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。</p>
<p>2.klass </p>
<p>对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.</p>
<p>3.数组长度（只有数组对象有） </p>
<p>如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.</p>
<p>实例数据：</p>
<p>是对象正常储存的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。</p>
<p>对齐填充:</p>
<p>不是必然存在的，仅仅是起到占位符的作用。对象的大小必须是8字节的整数倍，而对象头刚好是8字节的整数倍(1倍或者2倍)，当实例数据没有对齐的时候，就需要通过对齐填充来补全</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><ul>
<li><p>使用句柄访问</p>
<p>  Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址</p>
<p>  优势：reference中存储的是稳点的句柄地址,在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改</p>
</li>
</ul>
<img src="句柄访问.png" width="560"/>

<ul>
<li><p>使用直接指针访问</p>
<p>  Java堆对象的布局就必须考虑如何访问类型数据的相关信息,而refreence中存储的直接就是对象的地址</p>
<p>  优势：速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本</p>
</li>
</ul>
<img src="直接指针.png" width="560"/>

<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了，而方法区和堆是线程共享的，不会随线程死亡而消失</p>
<p>栈中的栈帧随着方法的进入和退出就有条不紊的执行者出栈和入栈的操作，每一个栈分配多少个内存基本都是在类结构确定下来的时候就已经确定了，这几个区域内存分配和回收都具有确定性</p>
<p>而堆和方法区则不同，一个接口的实现是多种多样的，多个实现类需要的内存可能不一样，一个方法中多个分支需要的内存也不一样，我们只能在程序运行的期间知道需要创建那些对象，分配多少内存，这部分的内存分配和回收都是动态的。</p>
<h2 id="判断对象存活"><a href="#判断对象存活" class="headerlink" title="判断对象存活"></a>判断对象存活</h2><ol>
<li><p>引用计数器法</p>
<p> 给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p> 这样的代码会产生如下引用情形：objA指向objB，而objB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。</p>
</li>
<li><p>可达性分析算法</p>
<p> 通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象是不可用的</p>
</li>
</ol>
<ul>
<li><p>Java语言中GC Roots的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈JNI（Native方法）引用的对象</li>
</ol>
</li>
</ul>
<h2 id="GC时机和finalize方法"><a href="#GC时机和finalize方法" class="headerlink" title="GC时机和finalize方法"></a>GC时机和finalize方法</h2><p>下列情况会出发对象的回收：</p>
<ol>
<li>对象没有引用</li>
<li>作用域发生未捕获异常</li>
<li>程序在作用域正常执行完毕</li>
<li>程序执行了System.exit（）</li>
<li>程序发生意外终止（被杀进程等）</li>
</ol>
<p>不可达的对象并不会马上就会被直接回收，而是至少要经过两次标记的过程。</p>
<ul>
<li>第一次标记：当可达性分析确认该对象没有引用链与GC Roots相连，则对其进行第一次标记和筛选，筛选的条件是重写了finalize()方法并没有执行过，对于重写了且并没有执行finalize()方法的对象这将其放置在一个F-Queue队列中，并在稍后由一个由虚拟机自动建立的低优先级的Finalizer线程去执行它。此处执行只保证执行该方法，但是不保证等待该方法执行结束，之所以这样子设计是为了系统的稳定性和健壮性考虑，以免该方法执行时间较长或者死循环导致系统崩溃。</li>
<li>第二次标记：在此之后，系统会对对象进行第二次标记，如果在第一次标记之后的对象在执行finalize()方法时没有被引用到一个新的变量，这该对象将被回收掉。finalize方法只能被执行一次，并且一般不推荐也不建议重写Object的该方法，如果需要关闭外部资源，比如数据库，I/O等完全可在finally块中完成。</li>
</ul>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：<strong>废弃常量和无用的类</strong></p>
<ul>
<li><p>废弃常量：</p>
<p>  假如一个字符串abc已经进入了常量池中，如果当前系统没有任何一个String对象abc，也就是没有任何Stirng对象引用常量池的abc常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池</p>
</li>
<li><p>无用的类：</p>
<p>  1.该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例</p>
<p>  2.加载该类的ClassLoader已经被回收</p>
<p>  3.该类对用的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</p>
</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>就是在程序代码之中普遍存在的，类似Object obj = new Object() 这类的引用， obj对象是对后面new Object的一个强引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strongReference</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Object referent = <span class="keyword">new</span> Object();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 通过赋值创建 StrongReference  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    Object strongReference = referent;  </span><br><span class="line"></span><br><span class="line">    assertSame(referent, strongReference);  </span><br><span class="line"></span><br><span class="line">    referent = <span class="keyword">null</span>;  </span><br><span class="line">    System.gc();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * StrongReference 在 GC 后不会被回收 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    assertNotNull(strongReference);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SoftReference"><a href="#SoftReference" class="headerlink" title="SoftReference"></a>SoftReference</h3><p>SoftReference 与 WeakReference 的特性基本一致， 最大的区别在于 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">softReference</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Object referent = <span class="keyword">new</span> Object();  </span><br><span class="line">    SoftReference&lt;Object&gt; softRerference = <span class="keyword">new</span> SoftReference&lt;Object&gt;(referent);  </span><br><span class="line"></span><br><span class="line">    assertNotNull(softRerference.get());  </span><br><span class="line"></span><br><span class="line">    referent = <span class="keyword">null</span>; </span><br><span class="line">    System.gc();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    *  soft references 只有在 jvm OutOfMemory 之前才会被回收, 所以它非常适合缓存应用 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    assertNotNull(softRerference.get());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WeakReference-amp-WeakHashMap"><a href="#WeakReference-amp-WeakHashMap" class="headerlink" title="WeakReference &amp; WeakHashMap"></a>WeakReference &amp; WeakHashMap</h3><h4 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h4><p>用来描述非必须对象的，但是它的强度比软引用更弱一些，被引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够都会回收掉只被弱引用关联的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakReference</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Object referent = <span class="keyword">new</span> Object();  </span><br><span class="line">    WeakReference&lt;Object&gt; weakRerference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent);  </span><br><span class="line"></span><br><span class="line">    assertSame(referent, weakRerference.get());  </span><br><span class="line"></span><br><span class="line">    referent = <span class="keyword">null</span>;  </span><br><span class="line">    System.gc();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    assertNull(weakRerference.get());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器。</p>
<p><strong>注意：当使用WeakReference来解决匿名内部类内存泄漏的问题时，可能会出现weakRerference.get()返回为null的问题，如下验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个回调接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Callback&gt; mWeakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeakReference&lt;Callback&gt; <span class="title">getWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWeakReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;finalize&quot;</span>);</span><br><span class="line">                <span class="keyword">super</span>.finalize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeakClass weakClass = <span class="keyword">new</span> WeakClass();</span><br><span class="line">        weakClass.run();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(weakClass.getWeakReference().get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --&gt;output</span></span><br><span class="line">finalize</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>这里因为run方法内部的变量会被垃圾回收，如果将它移到类成员变量级别，类成员变量级的强引用在类销毁的时候才会失效。在这之前的整个过程，由于强引用的存在，实例不会被回收，弱应用 WeakReference 也将一直有数据，故最容易的解决方案就是指定一个类成员变量强引用它。即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Callback&gt; mWeakReference;</span><br><span class="line">    <span class="keyword">private</span> Callback mCallback = <span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finalize&quot;</span>);</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeakReference&lt;Callback&gt; <span class="title">getWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWeakReference;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mWeakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(mCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><p>WeakHashMap 使用 WeakReference 作为 key， 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakHashMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    Map&lt;Object, Object&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;Object, Object&gt;();  </span><br><span class="line">    Object key = <span class="keyword">new</span> Object();  </span><br><span class="line">    Object value = <span class="keyword">new</span> Object();  </span><br><span class="line">    weakHashMap.put(key, value);  </span><br><span class="line"></span><br><span class="line">    assertTrue(weakHashMap.containsValue(value));  </span><br><span class="line"></span><br><span class="line">    key = <span class="keyword">null</span>;  </span><br><span class="line">    System.gc();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 等待无效 entries 进入 ReferenceQueue 以便下一次调用 getTable 时被清理 </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 一旦没有指向 key 的强引用, WeakHashMap 在 GC 后将自动删除相关的 entry </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    assertFalse(weakHashMap.containsValue(value));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhantomReference"><a href="#PhantomReference" class="headerlink" title="PhantomReference"></a>PhantomReference</h3><p>Phantom Reference(幽灵引用) 与 WeakReference 和 SoftReference 有很大的不同,因为它的 get() 方法永远返回 null, 这也正是它名字的由来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">phantomReferenceAlwaysNull</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Object referent = <span class="keyword">new</span> Object();  </span><br><span class="line">    PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(referent, <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;());  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * phantom reference 的 get 方法永远返回 null  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    assertNull(phantomReference.get());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意构造 PhantomReference 时的第二个参数 ReferenceQueue(事实上 WeakReference &amp; SoftReference 也可以有这个参数)，PhantomReference 唯一的用处就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中，用于检测对象是否已经从内存中删除。</p>
<h3 id="Reference-amp-ReferenceQueue"><a href="#Reference-amp-ReferenceQueue" class="headerlink" title="Reference&amp;ReferenceQueue"></a>Reference&amp;ReferenceQueue</h3><p>Reference 是上面引用的父类，看一下 Reference 的四个状态：</p>
<p><img src="Reference%E7%8A%B6%E6%80%81.jpg" alt="Reference状态"></p>
<p>Reference 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于带 ReferenceQueue 的Reference，GC 会把要回收对象的 Reference 放到 ReferenceQueue 中，后续该 Reference 需要开发者自行处理(poll等)。WeakHashMap 就是利用 ReferenceQueue 来清除 key 已经没有强引用的 Entry 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">referenceQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    Object referent = <span class="keyword">new</span> Object();       </span><br><span class="line">    ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;Object&gt;();  </span><br><span class="line">    WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;Object&gt;(referent, referenceQueue);  </span><br><span class="line"></span><br><span class="line">    assertFalse(weakReference.isEnqueued());  </span><br><span class="line">    Reference&lt;? extends Object&gt; polled = referenceQueue.poll();  </span><br><span class="line">    assertNull(polled);  </span><br><span class="line"></span><br><span class="line">    referent = <span class="keyword">null</span>;  </span><br><span class="line">    System.gc();  </span><br><span class="line"></span><br><span class="line">    assertTrue(weakReference.isEnqueued());  </span><br><span class="line">    Reference&lt;? extends Object&gt; removed = referenceQueue.remove();  </span><br><span class="line">    assertNotNull(removed);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add         增加一个元索                      如果队列已满，则抛出一个IIIegaISlabEepeplian异常</span><br><span class="line">remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">element  返回队列头部的元素              如果队列为空，则抛出一个NoSuchElementException异常</span><br><span class="line">offer       添加一个元素并返回<span class="keyword">true</span>        如果队列已满，则返回<span class="keyword">false</span></span><br><span class="line">poll         移除并返问队列头部的元素     如果队列为空，则返回<span class="keyword">null</span></span><br><span class="line">peek       返回队列头部的元素              如果队列为空，则返回<span class="keyword">null</span></span><br><span class="line">put         添加一个元素                       如果队列满，则阻塞</span><br><span class="line">take        移除并返回队列头部的元素 </span><br></pre></td></tr></table></figure>

<h3 id="PhantomReference-vs-WeakReference"><a href="#PhantomReference-vs-WeakReference" class="headerlink" title="PhantomReference vs WeakReference"></a>PhantomReference vs WeakReference</h3><p>PhantomReference 有两个好处：</p>
<p>其一， 它可以让我们准确地知道对象何时被从内存中删除， 这个特性可以被用于一些特殊的需求中(例如 Distributed GC， XWork 和 google-guice 中也使用 PhantomReference 做了一些清理性工作).</p>
<p>其二， 它可以避免 finalization 带来的一些根本性问题, 上文提到 PhantomReference 的唯一作用就是跟踪 referent 何时被 enqueue 到 ReferenceQueue 中, 但是 WeakReference 也有对应的功能, 两者的区别到底在哪呢 ? </p>
<p>这就要说到 Object 的 finalize 方法, 此方法将在 gc 执行前被调用, 如果某个对象重载了 finalize 方法并故意在方法内创建本身的强引用, 这将导致这一轮的 GC 无法回收这个对象并有可能引起任意次 GC， 最后的结果就是明明 JVM 内有很多 Garbage 却 OutOfMemory， 使用 PhantomReference 就可以避免这个问题， 因为 PhantomReference 是在 finalize 方法执行后回收的，也就意味着此时已经不可能拿到原来的引用, 也就不会出现上述问题, 当然这是一个很极端的例子, 一般不会出现.</p>
<h2 id="垃圾回收的比例"><a href="#垃圾回收的比例" class="headerlink" title="垃圾回收的比例"></a>垃圾回收的比例</h2><img src="垃圾回收.png" width="560"/>

<p>我们知道，方法区主要存放类与类之间关系的数据，而这部分数据被加载到内存之后，基本上是不会发生变更的，</p>
<p>Java堆中的数据基本上是朝生夕死的，我们用完之后要马上回收的，而Java栈和本地方法栈中的数据，因为有后进先出的原则，当我取下面的数据之前，必须要把栈顶的元素出栈，因此回收率可认为是100%；而程序计数器我们前面也已经提到，主要用户记录线程执行的行号等一些信息，这块区域也是被认为是唯一一块不会内存溢出的区域。在SunHostSpot的虚拟机中，对于程序计数器是不回收的，而方法区的数据因为回收率非常小，而成本又比较高，一般认为是“性价比”非常差的，所以Sun自己的虚拟机HotSpot中是不回收的！但是在现在高性能分布式J2EE的系统中，我们大量用到了反射、动态代理、CGLIB、JSP和OSGI等，这些类频繁的调用自定义类加载器，都需要动态的加载和卸载了，以保证永久带不会溢出，他们通过自定义的类加载器进行了各项操作，因此在实际的应用开发中，类也是被经常加载和卸载的，方法区也是会被回收的！但是方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收！</p>
<p>1、所有实例被回收</p>
<p>2、加载该类的ClassLoader被回收</p>
<p>3、Class对象无法通过任何途径访问(包括反射)</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记—清除算法"><a href="#标记—清除算法" class="headerlink" title="标记—清除算法"></a>标记—清除算法</h3><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>不足:一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可.</p>
<p>不足之处：将内存缩小为了原来的一半</p>
<p>实际中我们并不需要按照1:1比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor</p>
<p>当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代</p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>根据对象存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清除或者标记整理算法来进行回收。</p>
<h2 id="新生代、老年代、MinorGC、MajorGC、Full-GC"><a href="#新生代、老年代、MinorGC、MajorGC、Full-GC" class="headerlink" title="新生代、老年代、MinorGC、MajorGC、Full GC"></a>新生代、老年代、MinorGC、MajorGC、Full GC</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1.</p>
<ul>
<li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</li>
<li>ServivorTo：保留了一次MinorGC过程中的幸存者。</li>
<li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。</li>
</ul>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。</p>
<p>不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p>
<p>MajorGC采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。</p>
<p>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p>
<h3 id="元空间-MetaSpace"><a href="#元空间-MetaSpace" class="headerlink" title="元空间(MetaSpace)"></a>元空间(MetaSpace)</h3><p>方法区和永久带：一个是标准一个是实现。</p>
<p>元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<ul>
<li>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</li>
<li>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</li>
<li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</li>
<li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</li>
</ul>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><ul>
<li>对象优先在Eden分配</li>
<li>大对象直接进入老年代<br>  所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制.</li>
<li>长期存活的对象将进入老年代</li>
<li>动态对象年龄判定<br>  为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代，如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入到老年代，无须等到MaxTenuringThreshold中要求的年龄</li>
<li>空间分配担保<br>  在发生Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor DC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的：如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</li>
</ul>
<h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><ol>
<li><p>-XX:NewSize和-XX:MaxNewSize</p>
<p> 用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p>
</li>
<li><p>-XX:SurvivorRatio</p>
<p> 用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p>
</li>
<li><p>-XX:+PrintTenuringDistribution</p>
<p> 这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p>
</li>
<li><p>-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p>
<p> 用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p>
</li>
</ol>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>从可达性分析来说，逐个寻找分析GC Root是一个很耗时间的过程。另外，对于GC停顿，意思是说这项分析工作必须在一个能确保一致性的快照中进行：这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<p>由于目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>安全点（SafePoint）：即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。<br>安全点的选定原则：是否具有让程序长时间执行的特征，例如方法调用、循环跳转、异常跳转等。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>使用Safepoint在实际上不一定能完美解决如何进去GC的问题，Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，当程序“不执行”的时候，即没有分配CPU时间的时候，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这个收集器是一个单线程的收集器，但它的单线程的意义不仅仅说明它会只使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>它是虚拟机运行在Client模式下的默认新生代收集器，它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>Serial收集器的多线程版本，除了使用了多线程进行收集之外（并行），其余行为和Serial收集器一样。</p>
<ul>
<li>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li>
<li>并发：指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上</li>
</ul>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>收集器是一个新生代收集器，它是使用复制算法的收集器，又是并行的多线程收集器，它关注的是吞吐量。</p>
<p>吞吐量：就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p>
<p>MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p>GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间。</p>
<p>Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>是Serial收集器的老年代版本,是一个单线程收集器，使用标记整理算法</p>
<h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old是Paraller Seavenge收集器的老年代版本，使用多线程和标记整理算法</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是基于“标记—清除”算法实现的，它的运作过程分为4个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ol>
<p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<ul>
<li>优点：并发收集、低停顿</li>
<li>缺点：<ol>
<li>CMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4，</li>
<li>CMS收集器无法处理浮动垃圾，可能出现Failure失败而导致一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li>CMS是基于标记清除算法实现的</li>
</ol>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><ol>
<li>并行与并发：利用多CPU缩短STOP-The-World停顿的时间</li>
<li>分代收集</li>
<li>空间整合：不会产生内存碎片</li>
<li>可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ol>
<p>运作方式：初始标记，并发标记（并发），最终标记，筛选回收</p>
<h1 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>JVM启动参数共分为三类：</p>
<ol>
<li>标准参数（-），所有的JVM实现都必须实现这些参数的功能，而且向后兼容。例如：-verbose:class（输出jvm载入类的相关信息，当jvm报告说找不到类或者类冲突时可此进行诊断）；-verbose:gc（输出每次GC的相关情况）；-verbose:jni（输出native方法调用的相关情况，一般用于诊断jni调用错误信息）。</li>
<li>非标准参数（-X），默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容。例如：-Xms512m；-Xmx512m；-Xmn200m；-Xss128k；-Xloggc:file（与-verbose:gc功能类似，只是将每次GC事件的相关情况记录到一个文件中，文件的位置最好在本地，以避免网络的潜在问题。若与verbose命令同时出现在命令行中，则以-Xloggc为准）。</li>
<li>非Stable参数（-XX），此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用。例如：-XX:PermSize=64m；-XX:MaxPermSize=512m。</li>
</ol>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ul>
<li>-Xms：JVM启动时申请的初始Heap值，默认为操作系统物理内存的1/64但小于1G。默认当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过-XX:MaxHeapFreeRation=来指定这个比列。Server端JVM最好将-Xms和-Xmx设为相同值，避免每次垃圾回收完成后JVM重新分配内存；开发测试机JVM可以保留默认值。(例如：-Xms4g)</li>
<li>-Xmx：JVM可申请的最大Heap值，默认值为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列。最佳设值应该视物理内存大小及计算机内其他内存开销而定。(例如：-Xmx4g)</li>
<li>-Xmn：Java Heap Young区大小。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小(相对于HotSpot 类型的虚拟机来说)。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。(例如：-Xmn2g)；程序新创建的对象都是从年轻代分配内存，年轻代由Eden Space和两块相同大小的SurvivorSpace(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定年轻代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。</li>
<li>-Xss：Java每个线程的Stack大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。(例如：-Xss1024K)</li>
<li>-XX:PermSize：持久代（方法区）的初始内存大小。（例如：-XX:PermSize=64m）</li>
<li>-XX:MaxPermSize：持久代（方法区）的最大内存大小。（例如：-XX:MaxPermSize=512m）</li>
<li>-XX:+UseSerialGC：串行（SerialGC）是jvm的默认GC方式，一般适用于小型应用和单处理器，算法比较简单，GC效率也较高，但可能会给应用带来停顿。</li>
<li>-XX:+UseParallelGC：并行（ParallelGC）是指多个线程并行执行GC，一般适用于多处理器系统中，可以提高GC的效率，但算法复杂，系统消耗较大。（配合使用：-XX:ParallelGCThreads=8，并行收集器的线程数，此值最好配置与处理器数目相等）</li>
<li>-XX:+UseParNewGC：设置年轻代为并行收集，JKD5.0以上，JVM会根据系统配置自行设置，所以无需设置此值。</li>
<li>-XX:+UseParallelOldGC：设置年老代为并行收集，JKD6.0出现的参数选项。</li>
<li>-XX:+UseConcMarkSweepGC：并发（ConcMarkSweepGC）是指GC运行时，对应用程序运行几乎没有影响（也会造成停顿，不过很小而已），GC和app两者的线程在并发执行，这样可以最大限度不影响app的运行。</li>
<li>-XX:+UseCMSCompactAtFullCollection：在Full GC的时候，对老年代进行压缩整理。因为CMS是不会移动内存的，因此非常容易产生内存碎片。因此增加这个参数就可以在FullGC后对内存进行压缩整理，消除内存碎片。当然这个操作也有一定缺点，就是会增加CPU开销与GC时间，所以可以通过-XX:CMSFullGCsBeforeCompaction=3 这个参数来控制多少次Full GC以后进行一次碎片整理。</li>
<li>-XX:+CMSInitiatingOccupancyFraction=80：代表老年代使用空间达到80%后，就进行Full GC。CMS收集器在进行垃圾收集时，和应用程序一起工作，所以，不能等到老年代几乎完全被填满了再进行收集，这样会影响并发的应用线程的空间使用，从而再次触发不必要的Full GC。</li>
<li>-XX:+MaxTenuringThreshold=10：垃圾的最大年龄，代表对象在Survivor区经过10次复制以后才进入老年代。如果设置为0，则年轻代对象不经过Survivor区，直接进入老年代。</li>
</ul>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><ul>
<li>JVM Process Status Tool</li>
<li>命令格式：<code>jps [options] [hostid]</code></li>
</ul>
<p>jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。jps的其他常用选项见下表。</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-q</td>
<td align="center">只输出LVMID，省略主类名称</td>
</tr>
<tr>
<td align="center">-m</td>
<td align="center">输出虚拟机进程启动时传递给主类main函数的参数</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">输出主类的全名，如果进程执行的时jar包，输出jar包路径</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody></table>
<h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><ul>
<li>JVM Statistics Monitoring Tool</li>
<li>用于监视虚拟机各种运行状态信息的命令行工具</li>
<li>可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</li>
<li>命令格式：<code>jstat [option vmid[interval[s|ms][count]]]</code></li>
</ul>
<p>如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol：][//]lvmid[@hostname[：port]/servername]</span><br></pre></td></tr></table></figure>

<p>参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat-gc 2764 250 20</span><br></pre></td></tr></table></figure>

<img src="jstat.png"/>

<h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><ul>
<li>Configuration Info for Java</li>
<li>实时地查看和调整虚拟机各项参数</li>
<li>命令格式：<code>jinfo [option] pid</code></li>
<li>jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，使用jinfo的-flag选项可以查看未被显式指定的参数的系统默认值</li>
<li>使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来</li>
<li>使用<code>-flag[+|-]name</code>或者<code>-flag name=value</code>修改一部分运行期可写的虚拟机参数值。</li>
</ul>
<h2 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h2><ul>
<li>Memory Map for Java</li>
<li>用于生成堆转储快照（一般称为heapdump或dump文件）</li>
<li>命令格式：<code>jmap [option] vmid</code></li>
</ul>
<img src="jmap.png"/>

<h2 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h2><ul>
<li>JVM Heap Analysis Tool</li>
<li>与jmap搭配使用，分析jmap生成的堆转储快照</li>
<li>一般都不会去直接使用jhat命令来分析dump文件</li>
</ul>
<h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><ul>
<li>Stack Trace for Java</li>
<li>生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）（当前虚拟机内每一条线程正在执行的方法堆栈的集合）</li>
<li>定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因</li>
<li>命令格式：<code>jstack [option] vmid</code></li>
<li>在JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈</li>
</ul>
<img src="jstack.png"/>

<h2 id="HSDIS：JIT生成代码反汇编"><a href="#HSDIS：JIT生成代码反汇编" class="headerlink" title="HSDIS：JIT生成代码反汇编"></a>HSDIS：JIT生成代码反汇编</h2><ul>
<li>Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，让HotSpot的-XX：+PrintAssembly指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还生成了大量非常有价值的注释</li>
</ul>
<h2 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h2><ul>
<li>Java Monitoring and Management Console</li>
</ul>
<h2 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h2><ul>
<li>All-in-One Java Troubleshooting Tool</li>
<li>visualVM基于NetBeans平台开发，因此具有插件扩展的功能特性。</li>
<li>生成、浏览堆转储快照</li>
<li>分析程序性能</li>
<li>BTrace动态日志跟踪：在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存<br>在的调试代码。</li>
</ul>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p><strong>无关性的基石</strong></p>
<p>实现语言和平台无关性的基础是JVM虚拟机和字节码存储格式。</p>
<ul>
<li>平台无关性：一次编写，在任意系统上运行</li>
<li>语言无关性：JVM不与包括Java在内的任何语言绑定，只与“Class文件”这种特定的二进制文件格式所关联</li>
</ul>
<p><strong>Class类文件结构</strong></p>
<p>Class文件是一组以8位字节为基础单位的二进制流，当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。Class文件由无符号数和表构成：</p>
<ul>
<li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</li>
</ul>
<p><img src="class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="class文件结构"></p>
<p>可以使用<code>javap -v/verbose classfile</code>查看字节码信息。</p>
<p><strong>Magic Number和文件版本</strong></p>
<p>每个Class文件的头4个字节称为Magic Number，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，其值为0xCAFEBABE。紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。如下为一个Class文件的部分二进制值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cafe babe 0000 0034 0044 0a00 1400 2503</span><br></pre></td></tr></table></figure>

<p><strong>常量池</strong></p>
<p>紧接着主次版本号之后的是常量池入口，它是在Class文件中第一个出现的表类型数据项目。由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的，如常量池容量为0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。</p>
<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<p><img src="%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%86%85%E5%AE%B9.png" alt="常量池内容"></p>
<p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类加载时解析、翻译到具体的内存地址之中。</p>
<p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。</p>
<p><strong>访问标志</strong></p>
<p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。具体的标志位以及标志的含义如下表：</p>
<p><img src="%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.jpg" alt="访问标志"></p>
<p><strong>类索引、父类索引与接口索引集合</strong></p>
<p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p>
<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<p>对于接口索引集合，入口的第一项——u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p>
<p><strong>字段表集合</strong></p>
<p>字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<p><strong>方法表集合</strong></p>
<p>方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索<br>引（descriptor_index）、属性表集合（attributes）几项，这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p>
<p><strong>属性表集合</strong></p>
<p>属性表集合不要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</p>
<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>JVM主要在程序第一次运行时主动使用类的时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p><img src="%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<p>类加载的具体时机可交给虚拟机的具体实现来自由把握，可以通过 ClassLoader 的 findLoadedClass 方法来判断类是否被加载(Hotspot 虚拟机)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method m = ClassLoader.class.getDeclaredMethod(&quot;findLoadedClass&quot;, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        Object test1 = m.invoke(cl, <span class="string">&quot;Main$Test&quot;</span>);</span><br><span class="line">        System.out.println(test1 != <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(Test.s); <span class="comment">// 1</span></span><br><span class="line">        Object test2 = m.invoke(cl, <span class="string">&quot;Main$Test&quot;</span>);</span><br><span class="line">        System.out.println(test2 != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s = <span class="string">&quot;hearing&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Test instance = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>1</code> 处代码为 <code>Test.s</code> 时，输出 <code>false hearing false</code>，没触发类的加载。</li>
<li>当 <code>1</code> 处代码为 <code>Test.instance</code> 时，输出 <code>false constructor static Main$Test@4e25154f true</code>，触发了类的加载(包括初始化)。</li>
<li>当 <code>1</code> 处代码为 <code>Test.class.getName()</code> 时，输出 <code>false Main$Test true</code>，触发了类的加载(不初始化)。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ol>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>加载.class文件的方式：</p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>Java语言本身是相对安全的语言（依然是相对于C/C++来说），使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。在字节码语言层面上，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ol>
<p><font color="#990000">验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</font></p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类的静态变量分配内存，并将其初始化为默认值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ol>
<li>这时候进行内存分配的<font color="#990000">仅包括类变量（static）</font>，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>这里所设置的初始值通常情况下是<font color="#990000">数据类型默认的零值（如0、0L、null、false等）</font>，而不是被在Java代码中被显式地赋予的值（初始化阶段）。</li>
<li>如果类字段的字段属性表中存在 ConstantValue 属性，即<font color="#990000">同时被final和static修饰(基本类型和String)，那么在准备阶段变量value就会被初始化为ConstantValue属性所指定的值</font>。</li>
</ol>
<p>假设上面的类变量value被定义为：<code>public static final int value=3</code>。</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。调用这种类型的常量，不会触发所在类的初始化。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<ul>
<li>符号引用就是一组符号来描述目标，可以是任何字面量。</li>
<li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<p>虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。</p>
<p>初始化，<font color="#990000">为类的静态变量赋予正确的初始值</font>，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>声明类变量时指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ul>
<p>JVM初始化步骤</p>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量(非ConstantValue)，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类(main)，直接使用 java.exe命令来运行某个主类</li>
</ul>
<p>对于初始化阶段，虚拟机规范规定了在特定情况下才必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始），除此之外，所有引用类的方式都不会触发初始化，称为被动引用。如下实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">    System.out.println(SubClass.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行之后，只会输出“SuperClass init”，而不会输出“SubClass init”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
<p>当通过<code>SuperClass[] superClasses = new SuperClass[10];</code>调用时，SuperClass依旧不会初始化，因为这段代码里面触发了另外一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
<p>当访问某个类的 ConstantValue 时，不会触发初始化过程。</p>
<p>此外，类变量的初始化和static代码块的执行是按照代码中声明的先后顺序开始的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;count1 = &quot;</span> + singleTon.count1);</span><br><span class="line">        System.out.println(<span class="string">&quot;count2 = &quot;</span> + singleTon.count2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面会输出: <code>static constructor count1 = 1 count2 = 1</code>, 当把 singleTon 的赋值放在最前面时，会输出: <code>constructor static count1 = 1 count2 = 0</code>。</p>
<h3 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h3><p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h2><p>static类型变量赋值分两种，在类构造其中赋值，或使用ConstantValue属性赋值。</p>
<p>在实际的程序中，<font color="#990000">只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String，因为从常量池中只能引用到基本类型和String类型的字面量</font>。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p>
<p>final、static、static final修饰的字段赋值的区别:</p>
<ul>
<li>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。</li>
<li>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。</li>
<li>static final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。可以理解为在编译期即把结果放入了常量池中。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><img src="类加载器.png" width="420"/>

<p>这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。 </p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li>启动类加载器： BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</li>
<li>扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<ol>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ol>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<ol>
<li>当 AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</li>
<li>如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载；若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。</li>
</ol>
<p>双亲委派优势：</p>
<ul>
<li>避免重复加载：Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</li>
<li>避免 Java 核心类篡改：当通过网络传递一个名为java.lang.Integer的类时，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</li>
</ul>
<p><img src="ClassLoader.png" alt="ClassLoader"></p>
<h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ul>
<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li>双亲委派，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2><p>类加载有三种方式：</p>
<ol>
<li>命令行启动应用时候由JVM初始化加载</li>
<li>通过Class.forName()方法动态加载</li>
<li>通过ClassLoader.loadClass()方法动态加载</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = HelloWorld.class.getClassLoader();</span><br><span class="line">System.out.println( loader ); <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">loader.loadClass(<span class="string">&quot;Test2&quot;</span>); <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line"><span class="comment">//Class.forName(&quot;Test2&quot;); </span></span><br><span class="line"><span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line"><span class="comment">//Class.forName(&quot;Test2&quot;, false, loader);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;静态初始化块执行了！&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别切换加载方式，会有不同的输出结果。</p>
<ul>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p>
<img src="自定义ClassLoader1.png"/>
<img src="自定义ClassLoader2.png"/>

<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p>
<ol>
<li>这里传递的文件名需要是类的全限定性名称，即 com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。</li>
<li>最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li>
<li>这类Test 类本身可以被 AppClassLoader类加载，因此我们不能把 com/paddx/test/classloading/Test.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由 AppClassLoader加载，而不会通过我们自定义类加载器来加载.</li>
</ol>
<h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p>
<ol>
<li>编译器优化的重排序。在单线程环境下不能改变程序运行的结果.</li>
<li>指令级并行的重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<h2 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h2><p>Java遵循as-if-serial语义，即单线程执行程序时，即使发生重排序，程序的执行结果不能被改变。</p>
<h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before的前后两个操作不会被重排序且后者对前者内存可见。</p>
<p>举个例子来说明一下。线程Ⅰ执行了操作A：x=3，线程Ⅱ执行了操作Ｂ：y=x。如果操作Ａhappen-before操作B，线程Ⅱ执行操作B会写入y的值为3。假设线程Ⅲ在操作A和B之间执行了操作C: x=5，并且操作C和操作B之前并没有happen-before关系。这时线程Ⅱ执行操作B后x是3还是5都有可能，这是因为happen-before关系保证一定能够观测到前一个操作施加的内存影响，只有时间上的先后关系而并没有happen-before关系可能但并不保证能观测前一个操作施加的内存影响。</p>
<ul>
<li>程序次序规则：线程中每个动作A都happens-before于该线程中的每一个动作B。那么在程序中，所有的动作B都能出现在A之后。</li>
<li>监视器锁法则：对一个监视器的解锁happens-before于每个后续对同一监视器锁的加锁</li>
<li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作</li>
<li>线程启动法则：在一个线程中，对于Thread.start的调用会happens-before于每个启动线程的动作。</li>
<li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结。</li>
<li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li>
<li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li>
<li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li>
</ul>
<ol>
<li>同一个线程中，书写在前面的操作happen-before书写在后面的操作。这条规则是说，在单线程中操作间happen-before关系完全是由源代码的顺序决定的，这里的前提“在同一个线程中”是很重要的，这条规则也称为单线程规则。这个规则多少说得有些简单了，考虑到控制结构和循环结构，书写在后面的操作可能happen-before书写在前面的操作，不过我想读者应该明白我的意思。</li>
<li>对锁的unlock操作happen-before后续的对同一个锁的lock操作。这里的“后续”指的是时间上的先后关系，unlock操作发生在退出同步块之后，lock操作发生在进入同步块之前。这是条最关键性的规则，线程安全性主要依赖于这条规则。但是仅仅是这条规则仍然不起任何作用，它必须和下面这条规则联合起来使用才显得意义重大。这里关键条件是必须对“同一个锁”的lock和unlock。</li>
<li>如果操作A happen-before操作B，操作B happen-before操作C，那么操作A happen-before操作C。这条规则也称为传递规则。</li>
</ol>
<h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><ul>
<li>原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。Java内存模型是通过在变量修改后将新值同步会主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性。<ul>
<li>valatile特殊规则保障新值可以立即同步到主内存中。</li>
<li>Synchronized是在对一个变量执行unlock之前，必须把变量同步回主内存中（执行store、write操作）。</li>
<li>final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看见final字段的值。</li>
</ul>
</li>
<li>可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Java学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-10 15:11:36" itemprop="dateCreated datePublished" datetime="2018-06-10T15:11:36+08:00">2018-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-21 14:20:27" itemprop="dateModified" datetime="2021-05-21T14:20:27+08:00">2021-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2018/06/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Java学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><strong>final</strong></p>
<ul>
<li>final类不能被继承，没有子类，final类中的方法默认是final的</li>
<li>final方法不能被子类的方法覆盖，但可以被继承</li>
<li>final成员变量表示常量，只能被赋值一次，赋值后不能再被改变</li>
<li>final不能用于修饰构造方法</li>
<li>private不能被子类方法覆盖，private类型的方法默认是final类型的</li>
<li>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。</li>
<li>final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。</li>
<li>final变量可在构造器里面再赋值</li>
</ul>
<p><strong>static</strong></p>
<p>静态内部类:</p>
<ul>
<li>不能声明普通外层类或者包为静态的。</li>
<li>只有将某个内部类修饰为静态类，然后才能够在这个类中定义静态的成员变量与成员方法。这是静态内部类都有的一个特性。</li>
<li>不能够从静态内部类的对象中访问外部类的非静态成员(包括成员变量与成员方法)。</li>
<li>在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。</li>
<li>静态内部类可以被继承.</li>
</ul>
<p>静态方法和属性:</p>
<ul>
<li>静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为”隐藏”。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在”隐藏”的这种情况.</li>
<li>多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。</li>
<li>静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态。</li>
</ul>
<p>加载顺序:</p>
<ul>
<li>static用来修饰成员变量和成员方法，也可以形成静态static代码块。</li>
<li>被static修饰的成员变量和成员方法独立于该类的任何对象,只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</li>
</ul>
<p><strong>static final</strong></p>
<ul>
<li>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。</li>
<li>对于方法，表示不可覆盖，并且可以通过类名直接访问。</li>
<li>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象。</li>
</ul>
<p><strong>ConstantValue属性</strong></p>
<p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的.</p>
<p>static类型变量赋值分两种，在类构造其中赋值，或使用ConstantValue属性赋值。</p>
<p>在实际的程序中，<font color="#990000">只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String,因为从常量池中只能引用到基本类型和String类型的字面量</font>。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p>
<p>final、static、static final修饰的字段赋值的区别:</p>
<ul>
<li>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。</li>
<li>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。</li>
<li>static final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。可以理解为在编译期即把结果放入了常量池中。</li>
</ul>
<p><strong>构造函数</strong></p>
<ul>
<li>在子类构造对象时，发现，访问子类构造函数时，父类构造函数也运行了。原因是：在子类的构造函数中第一行有一个默认的隐式语句。 super();</li>
<li>如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中哪个构造函数。</li>
</ul>
<p><strong>移位运算符</strong></p>
<p><em>左移运算符<code>&lt;&lt;</code>:</em></p>
<p>丢弃左边指定位数，右边补0，符号位可能发生变化。</p>
<ul>
<li>对于 int 类型，左移位数大于等于32位操作时，会先对 32 求余后再进行左移操作。对于 long 类型，则会对 64 求余后再进行移位操作。</li>
<li>由于 double 和 float 在二进制中的表现比较特殊，因此不能来进行移位操作。</li>
<li>其它几种整形 byte, short 移位前会先转换为int类型(32位)再进行移位。</li>
</ul>
<p><em>右移运算符<code>&gt;&gt;</code>:</em></p>
<p>丢弃右边指定位数，左边补上符号位，符号位不会发生变化。</p>
<ul>
<li>对于 int 类型，右移位数大于等于32位操作时，会先对 32 求余后再进行右移操作。对于 long 类型，则会对 64 求余后再进行移位操作。</li>
<li>由于 double 和 float 在二进制中的表现比较特殊，因此不能来进行移位操作。</li>
<li>其它几种整形 byte, short 移位前会先转换为int类型(32位)再进行移位。</li>
</ul>
<p><em>无符号右移<code>&gt;&gt;&gt;</code>:</em></p>
<p>丢弃右边指定位数，左边补上0。也就是说，对于正数移位来说等同于<code>&gt;&gt;</code>，负数通过此移位运算符能移位成正数。</p>
<p><strong>原码、反码与补码</strong></p>
<ul>
<li>原码：符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。</li>
<li>反码：正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。</li>
<li>补码：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1(即在反码的基础上+1)。</li>
</ul>
<h1 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(Test1.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test1() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1 construct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    main</span><br><span class="line">    <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        System.out.println(Test1.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer a = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test1() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1 construct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    main</span><br><span class="line">    Test1</span><br><span class="line">    <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>代码块执行顺序: 静态代码块-&gt;构造代码块-&gt;构造方法-&gt;局部(方法)代码块</p>
<p>构造代码块每次执行构造方法之前都会执行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test construct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1 static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Test1() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test1 construct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">    Test1 <span class="keyword">static</span></span><br><span class="line">    Test <span class="keyword">static</span></span><br><span class="line">    Test1</span><br><span class="line">    Test1 construct</span><br><span class="line">    Test</span><br><span class="line">    Test construct</span><br></pre></td></tr></table></figure>

<h1 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h1><p><strong>异常体系</strong></p>
<p>Java中异常的体系是树形结构，所有异常的超类是Throwale，它有俩个子类：Error和Exception，分别表示错误和异常，其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常，这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。</p>
<ol>
<li>Error与Exception <ul>
<li>Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常，程序中应当尽可能去处理这些异常。</li>
</ul>
</li>
<li>运行时异常和非运行时异常 <ul>
<li>运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，程序中可以选择捕获处理，也可以不处理。</li>
<li>非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过，如IOException、SQLException等以及用户自定义的Exception异常。</li>
</ul>
</li>
</ol>
<p><strong>异常处理</strong></p>
<ul>
<li>在try中return后，依旧会执行finally。</li>
<li>finally语句在return语句执行之后return返回之前执行的。</li>
<li>finally块中的return语句会覆盖try块中的return返回。</li>
<li>如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变(具体区分值和引用)。</li>
<li>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。</li>
<li>在Java中如果不发生异常的话，try/catch不会造成任何性能损失。在 Java 类编译后，正常流程与异常处理部分是分开的，类会跟随一张异常表，每一个try-catch都会在这个表里添加行记录。当执行抛出了异常时，首先去异常表中查找是否可以被catch，如果可以则跳到异常处理的起始位置开始处理，如果没有则原地return，并且copy异常的引用给父调用方，接着看父调用的异常表，以此类推。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a &quot;</span> + test1());</span><br><span class="line">        System.out.println(<span class="string">&quot;b &quot;</span> + v);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;e &quot;</span> + test2().get(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;f &quot;</span> + map.get(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            v = <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;c &quot;</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;test&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;test&quot;</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;d &quot;</span> + map.get(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output:</span><br><span class="line">c <span class="number">2</span></span><br><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">d <span class="number">3</span></span><br><span class="line">e <span class="number">3</span></span><br><span class="line">f <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><p>Java为每种基本数据类型都提供了对应的包装器类型.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>Java Integer源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Java中int和Integer使用==比较将Integer拆箱成int后比较大小（jdk版本不小于1.5）,Integer和Integer之间==比较，是对象之间的比较，看两个引用是否指向同一个内存地址.但是一个字节的整数-128到127之间的整数将被缓存至IntegerCache,所有一个字节大小的Integer都存储于IntegerCache中，new创建的除外.</li>
<li>直接定义 Integer a = 1 通过 Integer.valueOf设置。</li>
<li>field.set(obj, int)通过反射设置value时也走了 Integer.valueOf 方法。</li>
<li>field.set(obj, new Integer(int)) 设置的是Integer类型，就不会再拆箱后再装箱。</li>
</ul>
<p><strong>实例一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line">System.out.println(i01==i02);   <span class="comment">// true</span></span><br><span class="line">System.out.println(i01==i03);   <span class="comment">// true</span></span><br><span class="line">System.out.println(i01==i04);   <span class="comment">// false</span></span><br><span class="line">System.out.println(i02==i02);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>实例二</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">1</span>;</span><br><span class="line">    Integer c = <span class="number">2</span>;</span><br><span class="line">    System.out.println(a==b);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(a==c);   <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(a, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a==b);   <span class="comment">// true</span></span><br><span class="line">    System.out.println(a==c);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(a.intValue()==c.intValue()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>基本用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    A,B,C,D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建enum时，编译器会自动为我们生成一个继承自java.lang.Enum&lt;E&gt;的类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Type A;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Type B;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的例子，我们可以把Type看作一个类，而把A，B，C，D看作类的Type的实例。当然，这个构建实例的过程不是我们做的，一个enum的构造方法限制是private的，也就是不允许我们调用。</p>
<p>可以在创建枚举的时候指定值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    A(<span class="string">&quot;test1&quot;</span>), B(<span class="string">&quot;test2&quot;</span>), C(<span class="string">&quot;test3&quot;</span>), D(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面说到，我们可以把Type看作一个类，而把A，B。。。看作Type的一个实例。同样，在enum中，我们可以定义类和实例的变量以及方法。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    A,B,C,D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原有的基础上，添加了类方法和实例方法。我们把Type看做一个类，那么enum中静态的域和方法，都可以视作类方法。和我们调用普通的静态方法一样，这里调用类方法也是通过  Type.getValue()即可调用，访问类属性也是通过Type.value即可访问。</p>
<p>下面的是实例方法，也就是每个实例才能调用的方法。那么实例是什么呢？没错，就是A，B，C，D。所以我们调用实例方法，也就通过 Type.A.getType()来调用就可以了。<br>最后，对于某个实例而言，还可以实现自己的实例方法。再看下下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    A&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;I will not tell you&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,B,C,D;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还可以添加抽象方法在enum中，强制ABCD都实现各自的处理逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Type</span></span>&#123;</span><br><span class="line">    A&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,B &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,C &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;C&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,D &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;D&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p>lambda表达式也称为闭包。语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<p>lambda表达式有如下特点：</p>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      Java8Tester tester = <span class="keyword">new</span> Java8Tester();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 类型声明</span></span><br><span class="line">      MathOperation addition = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用类型声明</span></span><br><span class="line">      MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">      MathOperation multiplication = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123; <span class="keyword">return</span> a * b; &#125;;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">      MathOperation division = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a / b;</span><br><span class="line">        </span><br><span class="line">      System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">      System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 不用括号</span></span><br><span class="line">      GreetingService greetService1 = message -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 用括号</span></span><br><span class="line">      GreetingService greetService2 = (message) -&gt;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">      greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">      greetService2.sayMessage(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">MathOperation</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, MathOperation mathOperation)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li><p>泛型，即<code>参数化类型</code>。顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数。</p>
</li>
<li><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。</p>
</li>
<li><p>泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。</p>
</li>
<li><p>泛型只在编译阶段有效</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">// key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">// 泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">// 泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的实参类型需与泛型的类型参数类型相同，即Integer，String等。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment">* 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment">* 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 传入泛型实参时：</span></span><br><span class="line"><span class="comment">* 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment">* 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment">* 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment">* 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然在方法中使用了泛型，但是这并不是一个泛型方法</span></span><br><span class="line">    <span class="comment">// 这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型</span></span><br><span class="line">    <span class="comment">// 所以在这个方法中才可以继续使用T这个泛型。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;t is &quot;</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printMsg(<span class="string">&quot;111&quot;</span>, <span class="number">222</span>, <span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;2323.4&quot;</span>, <span class="number">55.55</span>);</span><br></pre></td></tr></table></figure>

<h2 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>泛型是在 JDK 1.5 里引入的，如果不做泛型擦除，那么 JVM 需要对应使得能正确的的读取和校验泛型信息；另外为了兼容老程序，需为原本不支持泛型的 API 平行添加一套泛型 API。</p>
<h2 id="逆变与协变-泛型通配符"><a href="#逆变与协变-泛型通配符" class="headerlink" title="逆变与协变(泛型通配符)"></a>逆变与协变(泛型通配符)</h2><p>定义：如果A、B表示类型，<code>f()</code>表示一个类型的构造函数，<code>Type1≤Type2</code>表示Type1是Type2的子类型，<code>Type1≥Type2</code>表示Type1是Type2的超类型；</p>
<ul>
<li><code>f()</code>是逆变（contravariant）的：当<code>A≤B</code>时有<code>f(B)≤f(A)</code>成立；</li>
<li><code>f()</code>是协变（covariant）的，当<code>A≤B</code>时有<code>f(A)≤f(B)</code>成立；</li>
<li><code>f()</code>是不变（invariant）的，当<code>A≤B</code>时上述两个式子均不成立，即<code>f(A)</code>与<code>f(B)</code>相互之间没有继承关系。</li>
</ul>
<p>对于任意两个不同的类型 Type1 和 Type2，不论它们之间具有什么关系，给定泛型类 <code>G&lt;T&gt;</code>，<code>G&lt;Type1&gt;</code> 和 <code>G&lt;Type2&gt;</code> 都是没有关系的，即 Java 中泛型是不变的，而数组是协变的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译报错</span></span><br><span class="line">    ArrayList&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以正常通过编译，正常使用</span></span><br><span class="line">    Number[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在java泛型中引入了<code>?</code>符号来支持协变和逆变：</p>
<ul>
<li><code>? extends T</code>(上边界通配符)实现协变关系，表示<code>?</code>是继承自<code>T</code>的任意子类型。也表示一种约束关系，只能提供数据，不能接收数据。</li>
<li><code>? super T</code>(下边界通配符)实现逆变关系，表示<code>?</code>是<code>T</code>的任意父类型。也表示一种约束关系，只能接收数据，不能提供数据。</li>
<li><code>?</code>的默认实现是<code>? extends Object</code>，表示<code>?</code>是继承自Object的任意类型。</li>
<li>PECS 法则：「Producer-Extends, Consumer-Super」。</li>
</ul>
<p>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">List&lt;? <span class="keyword">super</span> Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collections类中的copy方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h2><p>Java不能直接创建泛型数组，一般都使用List替代。比如说<code>HashMap&lt;Integer&gt; map = new HashMap&lt;Integer&gt;[]</code>会编译失败，因为Java在编译器的类型擦除，上面的元素会变成Object类型，编译器在编译时会尽可能的发现可能出错的地方，因此会编译失败。</p>
<p>可以通过这种方式创建泛型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] genericArray = (List&lt;Integer&gt;[]) <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<h1 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Type是Java语言中所有类型的公共父接口，Type的直接子类只有一个，也就是Class，代表着类型中的原始类型以及基本类型。接下来会解析Type的四个子接口。</p>
<p>在jdk1.5之前Java中只有原始类型而没有泛型类型，而在JDK 1.5之后引入泛型，但是这种泛型仅仅存在于编译阶段，当在JVM运行的过程中，与泛型相关的信息将会被擦除，如<code>List&lt;Person&gt;</code>与<code>List&lt;String&gt;</code>都将会在运行时被擦除成为List这个类型。而类型擦除机制存在的原因正是因为如果在运行时存在泛型，那么将要修改JVM指令集，这是非常致命的。</p>
<p>此外，原始类型会生成字节码文件对象，而泛型类型相关的类型并不会生成与其相对应的字节码文件(因为泛型类型将会被擦除)，因此，无法将泛型相关的新类型与Class相统一。因此，为了程序的扩展性以及为了开发需要去反射操作这些类型，就引入了Type这个类型，并且新增了ParameterizedType, TypeVariable, GenericArrayType, WildcardType四个表示泛型相关的类型，再加上Class，这样就可以用Type类型的参数来接受以上五种类型的实参或者返回值类型就是Type类型的参数。统一了与泛型有关的类型和原始类型Class。而且这样一来，我们也可以通过反射获取泛型类型参数。</p>
<h2 id="ParameterizedType"><a href="#ParameterizedType" class="headerlink" title="ParameterizedType"></a>ParameterizedType</h2><p>参数化类型即我们通常所说的泛型类型，它的三个重要方法：</p>
<ul>
<li><code>Type getRawType()</code>：该方法的作用是返回当前的ParameterizedType的类型，如List返回的是List的Type，即返回当前参数化类型本身的Type。</li>
<li><code>Type getOwnerType()</code>：返回ParameterizedType类型所在的类的Type，如<code>Map.Entry&lt;String, Object&gt;</code>这个参数化类型返回的是Map的类型。</li>
<li><code>Type[] getActualTypeArguments()</code>：该方法返回参数化类型<code>&lt;&gt;</code>中的实际参数类型，如<code>Map&lt;String, Person&gt; map</code>这个ParameterizedType返回的是String类，Person类的全限定类名的Type Array。该方法只返回最外层的<code>&lt;&gt;</code>中的类型，无论该<code>&lt;&gt;</code>内有多少个<code>&lt;&gt;</code>。</li>
</ul>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Object&gt; mMap;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mList;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; mCls;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Field[] fields = Main.class.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            Type type = field.getGenericType();</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                System.out.println(field.getName() + <span class="string">&quot;: &quot;</span> + ((ParameterizedType) type).getActualTypeArguments()[<span class="number">0</span>].getTypeName() + <span class="string">&quot;, &quot;</span> + ((ParameterizedType) type).getRawType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">mMap: java.lang.String, <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">HashMap</span></span></span><br><span class="line">mList: java.lang.String, interface java.util.List</span><br><span class="line">mCls: ?, <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span></span></span><br></pre></td></tr></table></figure>

<h2 id="TypeVariable"><a href="#TypeVariable" class="headerlink" title="TypeVariable"></a>TypeVariable</h2><p>类型变量，范型信息在编译时会被转换为一个特定的类型, 而TypeVariable就是用来反映在JVM编译该泛型前的信息(通俗的来说，TypeVariable就是我们常用的T，K这种泛型变量)。</p>
<ul>
<li><code>Type[] getBounds()</code>：返回当前类型的上边界，如果没有指定上边界，则默认为Object。</li>
<li><code>String getName()</code>：返回当前类型的类名。</li>
<li><code>D getGenericDeclaration()</code>：返回当前类型所在的类的Type。</li>
</ul>
<p>实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>&lt;<span class="title">K</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K mK;</span><br><span class="line">    <span class="keyword">private</span> T mT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TypeVariable[] variables = Main.class.getTypeParameters();</span><br><span class="line">        <span class="keyword">for</span> (TypeVariable variable : variables) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = variable.getBounds().length - <span class="number">1</span>;</span><br><span class="line">            System.out.println(variable.getName() + <span class="string">&quot;: &quot;</span> + variable.getBounds()[index] + <span class="string">&quot;, &quot;</span> + variable.getGenericDeclaration());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">K: <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>, <span class="title">class</span> <span class="title">Main</span></span></span><br><span class="line">T: class java.lang.Object, class Main</span><br></pre></td></tr></table></figure>

<h2 id="GenericArrayType"><a href="#GenericArrayType" class="headerlink" title="GenericArrayType"></a>GenericArrayType</h2><p>泛型数组类型，组成数组的元素中有泛型则实现了该接口，它的组成元素是ParameterizedType或TypeVariable类型。(通俗来说，就是由参数类型组成的数组。如果仅仅是参数化类型，则不能称为泛型数组，而是参数化类型)。**<code>注意：无论从左向右有几个[]并列，这个方法仅仅脱去最右边的[]之后剩下的内容就作为这个方法的返回值。</code>**</p>
<ul>
<li><code>Type getGenericComponentType()</code>：返回组成泛型数组的实际参数化类型，如List[]则返回List。</li>
</ul>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 泛型数组类型</span></span><br><span class="line">    <span class="keyword">private</span> T[] mTs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt;[] mLists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是泛型数组类型</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mList;</span><br><span class="line">    <span class="keyword">private</span> T mT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Field[] fields = Main.class.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 输出当前变量是否为GenericArrayType类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Field &quot;</span> + field.getName() + <span class="string">&quot; is &quot;</span> + (field.getGenericType() <span class="keyword">instanceof</span> GenericArrayType));</span><br><span class="line">            <span class="keyword">if</span> (field.getGenericType() <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                <span class="comment">// 如果是GenericArrayType，则输出当前泛型类型</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Field &quot;</span> + field.getName() + <span class="string">&quot; is &quot;</span> + (((GenericArrayType) field.getGenericType()).getGenericComponentType()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">Field mTs is <span class="keyword">true</span></span><br><span class="line">Field mTs is T</span><br><span class="line">Field mLists is <span class="keyword">true</span></span><br><span class="line">Field mLists is java.util.List&lt;java.lang.String&gt;</span><br><span class="line">Field mList is <span class="keyword">false</span></span><br><span class="line">Field mT is <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="WildcardType"><a href="#WildcardType" class="headerlink" title="WildcardType"></a>WildcardType</h2><p>通配符表达式，或泛型表达式，它虽然是Type的一个子接口，但并不是Java类型中的一种，表示的仅仅是类似 <code>&lt;?&gt;, &lt;? Extends Number&gt;</code> 这样的表达式。</p>
<ul>
<li><code>Type[] getLowerBounds()</code>：得到下边界的Type数组。</li>
<li><code>Type[] getUpperBounds()</code>：得到上边界的Type数组。</li>
</ul>
<p>注：如果没有指定上边界，则默认为Object，如果没有指定下边界，则默认为String。</p>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; mList0;</span><br><span class="line">    <span class="keyword">private</span> List&lt;?&gt; mList1;</span><br><span class="line">    <span class="keyword">private</span> List&lt;? extends List&gt; mList2;</span><br><span class="line">    <span class="keyword">private</span> List&lt;? <span class="keyword">super</span> List&gt; mList3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Field[] fields = Main.class.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            Type type = field.getGenericType();</span><br><span class="line">            <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                Type[] arguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type argument : arguments) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (argument <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Field: &quot;</span> + field.getName() + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + ((WildcardType) argument).getUpperBounds() + <span class="string">&quot;, &quot;</span> + ((WildcardType) argument).getLowerBounds());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-&gt;output</span><br><span class="line">Field: mList1, [Ljava.lang.reflect.Type;@<span class="number">15d</span>b9742, [Ljava.lang.reflect.Type;@<span class="number">6d</span>06d69c</span><br><span class="line">Field: mList2, [Ljava.lang.reflect.Type;@<span class="number">7852e922</span>, [Ljava.lang.reflect.Type;@<span class="number">4e25154f</span></span><br><span class="line">Field: mList3, [Ljava.lang.reflect.Type;@<span class="number">70d</span>ea4e, [Ljava.lang.reflect.Type;@<span class="number">5</span>c647e05</span><br></pre></td></tr></table></figure>

<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><ul>
<li>port范围从0到65535，其中0到1023被系统保留。</li>
<li>Java提供的网络功能有四大类：<ul>
<li>InetAddress：标识网络上的硬件资源</li>
<li>URL：统一资源定位符</li>
<li>Sockets：使用TCP协议</li>
<li>Datagram：使用UDP协议</li>
</ul>
</li>
</ul>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><p>无构造方法。</p>
<pre><code>InetAddress address = InetAddress.getLocalHost();
System.out.println(address.getHostAddress());//222.20.25.251
System.out.println(address.getHostName());//admin-PC
InetAddress address1 = InetAddress.getByName(&quot;222.20.25.251&quot;);
System.out.println(address1.getHostName());//admin-PC</code></pre>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>通过URL的openStream()方法打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream（字节输入流）。</p>
<pre><code>try &#123;
    URL url = new URL(&quot;http://www.baidu.com&quot;);
    InputStream inputStream = url.openStream();
    //将字节型输入流转换为字符型输入流
    InputStreamReader reader = new InputStreamReader(inputStream, &quot;utf-8&quot;);
    //将字符输入流添入缓冲
    BufferedReader bufferedReader = new BufferedReader(reader);
    String data = bufferedReader.readLine();
    while (data != null)&#123;
        System.out.println(data);
        data = bufferedReader.readLine();
    &#125;
    inputStream.close();
    reader.close();
    bufferedReader.close();
&#125; catch (MalformedURLException e) &#123;
    e.printStackTrace();
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125;</code></pre>
<h2 id="Socket实现TCP编程"><a href="#Socket实现TCP编程" class="headerlink" title="Socket实现TCP编程"></a>Socket实现TCP编程</h2><p>服务端：</p>
<pre><code>//1、创建一个服务端Socket
ServerSocket serverSocket = new ServerSocket(8888);
//2、调用accept方法等待连接
System.out.println(&quot;服务器等待客户端连接。。。&quot;);
Socket socket = serverSocket.accept();
//3、获取输入流
InputStream is = socket.getInputStream();
InputStreamReader reader = new InputStreamReader(is, &quot;utf-8&quot;);
BufferedReader bufferedReader = new BufferedReader(reader);
String info = null;
while ((info = bufferedReader.readLine()) != null)&#123;
    System.out.println(&quot;服务器接收到来自客户端的：&quot; + info);
&#125;
//4、关闭输入流
socket.shutdownInput();

OutputStream os = socket.getOutputStream();

PrintWriter writer = new PrintWriter(os);
writer.write(&quot;欢迎&quot;);
writer.flush();

//5、关闭资源
writer.close();
os.close();
bufferedReader.close();
reader.close();
is.close();
socket.close();
serverSocket.close();</code></pre>
<p>客户端：</p>
<pre><code>//1、创建客户端Socket，指定服务器IP和端口
Socket socket = new Socket(&quot;localhost&quot;, 8888);
//2、获取输出流
OutputStream os = socket.getOutputStream();
PrintWriter writer = new PrintWriter(os);//打印流
writer.write(&quot;用户名：刘家东----密码：123456&quot;);
writer.flush();
socket.shutdownOutput();
//3、获得输入流
InputStream is = socket.getInputStream();
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(is));
String info = null;
while ((info = bufferedReader.readLine()) != null)&#123;
    System.out.println(&quot;响应信息：&quot; + info);
&#125;
//4、关闭资源
bufferedReader.close();
is.close();
writer.close();
os.close();
socket.close();</code></pre>
<h2 id="Socket实现UDP编程"><a href="#Socket实现UDP编程" class="headerlink" title="Socket实现UDP编程"></a>Socket实现UDP编程</h2><p>DatagramPacket：表示数据报包</p>
<p>DatagramSocket：进行端到端通信的类</p>
<p>服务端：</p>
<ol>
<li>创建DatagramSocket，指定端口号。</li>
<li>创建DatagramPacket，用于接收信息。</li>
<li>接收客户端发送的数据信息</li>
<li>读取数据</li>
</ol>
<p>客户端：</p>
<ol>
<li>定义发送信息</li>
<li>创建DatagramPacket，包含要发送的信息</li>
<li>创建DatagramSocket</li>
<li>发送数据</li>
</ol>
<p>服务端：</p>
<pre><code>public static void main(String[] args) throws IOException &#123;
    //1、创建DatagramSocket，指定端口号。
    DatagramSocket socket = new DatagramSocket(8800);
    //2、创建DatagramPacket，用于接收信息
    byte[] data = new byte[1024];
    DatagramPacket packet = new DatagramPacket(data, data.length);
    //3、接收客户端发送的数据信息，此方法在接收到数据前会一直堵塞
    System.out.println(&quot;服务器已经启动。。。&quot;);
    socket.receive(packet);
    //4、读取数据
    String info = new String(data, 0, packet.getLength());
    System.out.println(&quot;服务端接收到客户端的信息：&quot; + info);

    //响应
    //1、定义发送信息，服务器的地址、端口号、数据
    InetAddress address = packet.getAddress();
    int port = packet.getPort();
    byte[] response = &quot;欢迎你！&quot;.getBytes();
    //2、创建DatagramPacket，包含要发送的信息
    DatagramPacket packet1 = new DatagramPacket(response, response.length, address, port);
    //3、创建DatagramSocket
    socket.send(packet1);
    //4、关闭资源
    socket.close();
&#125;</code></pre>
<p>客户端：</p>
<pre><code>public static void main(String[] args) throws IOException &#123;
    //1、定义发送信息，服务器的地址、端口号、数据
    InetAddress address = InetAddress.getByName(&quot;localhost&quot;);
    int port = 8800;
    byte[] data = &quot;用户名：admin；密码：123456&quot;.getBytes();
    //2、创建DatagramPacket，包含要发送的信息
    DatagramPacket packet = new DatagramPacket(data, data.length, address, port);
    //3、创建DatagramSocket
    DatagramSocket socket = new DatagramSocket();
    socket.send(packet);

    //接收响应
    //1、创建DatagramPacket，用于接收信息
    byte[] resp = new byte[1024];
    DatagramPacket packet1 = new DatagramPacket(resp, resp.length);
    //2、接收响应
    socket.receive(packet1);
    //3、读取数据
    String reply = new String(resp, 0, packet1.getLength());
    System.out.println(&quot;响应：&quot; + reply);
    //4、关闭资源
    socket.close();
&#125;</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于同一个socket，如果关闭了输出流，则与该输出流关联的socket也会被关闭，所以一般不用关闭流，直接关闭socket即可。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>有且只有一个抽象方法的接口被称为函数式接口，函数式接口适用于函数式编程的场景，Lambda就是Java中函数式编程的体现，可以使用Lambda表达式创建一个函数式接口的对象，一定要确保接口中有且只有一个抽象方法，这样Lambda才能顺利的进行推导。</p>
<p>Java 8中专门为函数式接口引入了一个新的注解 – <code>@FunctionalInterface</code>，该注解可用于一个接口的定义上，不是必须的，其作用只是让编译器检查该接口是否满足函数式接口规范。</p>
<h1 id="接口增强"><a href="#接口增强" class="headerlink" title="接口增强"></a>接口增强</h1><p><strong>默认方法</strong></p>
<p>Java 8引入了新的语言特性——默认方法（Default Methods），默认方法是在接口中的方法签名前加上了default关键字的实现方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InterfaceA foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ClassA().foo(); <span class="comment">// 打印：“InterfaceA foo”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态方法</strong></p>
<p>在Java8中接口里可以声明静态方法，并且可以实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String something)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am Do :&quot;</span> + something);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">10</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">23</span>).map(n -&gt; n * <span class="number">2</span>).filter(n-&gt;n&gt;<span class="number">10</span>).toArray();</span><br></pre></td></tr></table></figure>

<h1 id="Optional-API"><a href="#Optional-API" class="headerlink" title="Optional API"></a>Optional API</h1><p>在 Java 8 引入Optional特性的基础上，Java 9 又为 Optional 类增加了三种方法：or()、ifPresentOrElse() 和 stream()。该类可用于解决空指针问题，从本质上来说，该类属于包含可选值的封装类（wrapper class），因此它既可以包含对象也可以仅仅为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user1不能传空</span></span><br><span class="line">User result = Optional.of(user1).get();</span><br><span class="line"><span class="comment">// user2可以为空</span></span><br><span class="line">result = Optional.ofNullable(user2).orElse(user1);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-05 18:38:27" itemprop="dateCreated datePublished" datetime="2018-06-05T18:38:27+08:00">2018-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-31 18:24:57" itemprop="dateModified" datetime="2021-05-31T18:24:57+08:00">2021-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          
            <span id="/2018/06/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="C++学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/05/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><pre><code>class Dog &#123;
public:
    string &amp;getM_strName() &#123;
    return m_strName;

    void setM_strName(string &amp;m_strName) &#123;
    Dog::m_strName = m_strName;
    &#125;

    int getM_iAge() &#123;
    return m_iAge;
    &#125;

    void setM_iAge(int m_iAge) &#123;
    Dog::m_iAge = m_iAge;
    &#125;

private:
    string m_strName;
    int m_iAge;
&#125;;//注意：此处有分号</code></pre>
<h1 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h1><pre><code>//从栈中获取对象
Dog dog;
Dog dogs[20];
//从堆中获取对象
Dog *p = new Dog();
Dog *q = new Dog[20];
// todo
//从栈中获取对象不需要手动释放内存，从堆中获取则需要手动释放
delete p;
delete []q;
p = NULL;
q = NULL;</code></pre>
<h1 id="实例的访问"><a href="#实例的访问" class="headerlink" title="实例的访问"></a>实例的访问</h1><pre><code>//对象成员的访问
dog.age = 0;
dog.hello();

p-&gt;age = 0;
p-&gt;hello();
delete(p);
p = NULL;</code></pre>
<img src="内存分区.png" width="300"/>

<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul>
<li>编译时将函数体代码和实参替代函数调用语句（结构简单的函数）。</li>
<li>普通函数：</li>
</ul>
<img src="普通函数调用.png" width="300"/>

<ul>
<li><p>内联函数关键字：inline</p>
<pre><code>  inline int max(int x, int y);</code></pre>
</li>
<li><p>递归函数无法使用内联</p>
</li>
<li><p>逻辑简单，调用频繁的函数建议内联</p>
</li>
</ul>
<h1 id="类外定义"><a href="#类外定义" class="headerlink" title="类外定义"></a>类外定义</h1><ul>
<li>同文件类外定义</li>
</ul>
<img src="同文件类外定义.png" width="300"/>

<ul>
<li>分文件类外定义（推荐）</li>
</ul>
<img src="分文件类外定义.png" width="500"/>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul>
<li><p>Cat.h</p>
<pre><code>  #ifndef DEMO1_CAT_H
  #define DEMO1_CAT_H

  #include &lt;iostream&gt;
  using namespace std;

  class Cat &#123;
  public:
      Cat();
      Cat(string name = &quot;hearing&quot;);

  private:
      string name;
      int age;
  &#125;;</code></pre>
</li>
</ul>
<pre><code>​    
    #endif //DEMO1_CAT_H</code></pre>
<ul>
<li><p>Cat.cpp</p>
<pre><code>  #include &quot;Cat.h&quot;

  Cat::Cat() &#123;
      cout &lt;&lt; &quot;Cat()&quot; &lt;&lt; endl;
  &#125;

  Cat::Cat(string name) &#123;
      Cat::name = name;
  &#125;</code></pre>
</li>
</ul>
<h2 id="delete和default"><a href="#delete和default" class="headerlink" title="delete和default"></a>delete和default</h2><pre><code>/*
C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。
这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。
如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。
*/

// C++11 标准引入了一个新特性：&quot;=default&quot;函数。程序员只需在函数声明后加上“=default;”，就可将该函数声明为 &quot;=default&quot;函数，编译器将为显式声明的 &quot;=default&quot;函数自动生成函数体。
class X &#123; 
public: 
    X() = default; //该函数比用户自己定义的默认构造函数获得更高的代码效率
    X(int i) &#123; 
        a = i; 
    &#125;

private: 
    int a; 
&#125;; 

X obj;

// &quot;=default&quot;函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数。
class X1 &#123;
public:
    int f() = default;      // err , 函数 f() 非类 X 的特殊成员函数
    X1(int, int) = default;  // err , 构造函数 X1(int, int) 非 X 的特殊成员函数
    X1(int = 1) = default;   // err , 默认构造函数 X1(int=1) 含有默认参数
&#125;;

// &quot;=default&quot;函数既可以在类体里（inline）定义，也可以在类体外（out-of-line）定义。
class X2 &#123;
public:
    X2() = default; //Inline defaulted 默认构造函数
    X2(const X&amp;);
    X2&amp; operator = (const X&amp;);
    ~X2() = default;  //Inline defaulted 析构函数
&#125;;

X2::X2(const X&amp;) = default;  //Out-of-line defaulted 拷贝构造函数
X2&amp; X2::operator= (const X2&amp;) = default;   //Out-of-line defaulted  拷贝赋值操作符

// 为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性：&quot;=delete&quot;函数。程序员只需在函数声明后上“=delete;”，就可将该函数禁用。
class X3 &#123;
public:
    X3();
    X3(const X3&amp;) = delete;  // 声明拷贝构造函数为 deleted 函数
    X3&amp; operator = (const X3 &amp;) = delete; // 声明拷贝赋值操作符为 deleted 函数
&#125;;

// &quot;=delete&quot;函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换
class X4 &#123;
public:
    X4(double) &#123;

    &#125;

    X4(int) = delete;
&#125;;

// &quot;=delete&quot;函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象
class X5 &#123;
public:
    void *operator new(size_t) = delete;
    void *operator new[](size_t) = delete;
&#125;;

void mytest() &#123;
    X4 obj1;
    X4 obj2=obj1;   // 错误，拷贝构造函数被禁用

    X4 obj3;
    obj3=obj1;     // 错误，拷贝赋值操作符被禁用

    X5 *pa = new X5;      // 错误，new 操作符被禁用
    X5 *pb = new X5[10];  // 错误，new[] 操作符被禁用

    return;
&#125;</code></pre>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><ul>
<li>此关键字只能对用户自己定义的对象起作用，不对默认构造函数起作用</li>
<li>此关键字只能够修饰构造函数。而且构造函数的参数只能有一个。</li>
<li>按默认规定，只用传一个参数的构造函数也定义了一个隐式转换。比如说使用string s = “hearing”;的过程中实际上隐式调用了string s(“hearing”);</li>
<li>使用explicit声明后,则表明构造函数只能显式调用.</li>
</ul>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><ul>
<li><p>先于构造函数执行</p>
</li>
<li><p>只能用于构造函数</p>
</li>
<li><p>可以同时初始化多个数据成员</p>
<pre><code>  #ifndef DEMO1_CAT_H
  #define DEMO1_CAT_H

  #include &lt;iostream&gt;
  using namespace std;

  class Cat &#123;
  public:
      Cat(string name):name(name),age(21)&#123;&#125;

  private:
      string name;
      int age;
  &#125;;

  #endif //DEMO1_CAT_H</code></pre>
</li>
<li><p>必要性</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;const类型的变量不能重复赋值，故此时不能通过构造函数初始化。</p>
<pre><code>    #include &lt;iostream&gt;
    using namespace std;

    class Cat &#123;
    public:
        Cat():name(&quot;hearing&quot;),age(21)&#123;&#125;

    private:
        const string name;
        int age;
    &#125;;</code></pre>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>&nbsp;&nbsp;如果没有自定义的拷贝构造函数，系统则会自动生成一个默认的。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><pre><code>    #include &lt;iostream&gt;
    #include &lt;cstring&gt;
    using namespace std;
    class Array&#123;
    public :
        Array()&#123;
            cout&lt;&lt;&quot;Array()&quot;&lt;&lt;endl;
        &#125;
        Array(const Array &amp;arr)&#123; /// 拷贝构造函数
            m_iCount = arr.m_iCount;
            cout&lt;&lt;&quot;Array &amp;&quot;&lt;&lt;endl;
        &#125;

        virtual ~Array()&#123;
            cout&lt;&lt;&quot;~Array()&quot;&lt;&lt;endl;
        &#125;
        void setCount(int _count)&#123;
            m_iCount = _count;
        &#125;
        int getCount()&#123;
            return m_iCount;
        &#125;
    private :
        int m_iCount;
    &#125;;
    int main()&#123;
        Array arr1;
        arr1.setCount(5);
        Array arr2(arr1);///浅拷贝
        cout&lt;&lt;&quot;arr2 m_iCount &quot;&lt;&lt;arr2.getCount()&lt;&lt;endl;
        return 0;
    &#125;</code></pre>
<p>&nbsp;&nbsp;再看一份代码</p>
<pre><code>    #include &lt;iostream&gt;
    #include &lt;cstring&gt;
    using namespace std;
    class Array&#123;
    public :
        Array(int _count)&#123;
            m_iCount = _count;
            m_pArr = new int[m_iCount];
            cout&lt;&lt;&quot;Array()&quot;&lt;&lt;endl;
        &#125;
        Array(const Array &amp;arr)&#123; /// 拷贝构造函数
            m_iCount = arr.m_iCount;
            m_pArr = arr.m_pArr; ///两个指针指向同一块内存
            cout&lt;&lt;&quot;Array &amp;&quot;&lt;&lt;endl;
        &#125;

        virtual ~Array()&#123;
            delete []m_pArr;
            m_pArr = NULL;
            cout&lt;&lt;&quot;~Array()&quot;&lt;&lt;endl;
        &#125;
        void setCount(int _count)&#123;
            m_iCount = _count;
        &#125;
        int getCount()&#123;
            return m_iCount;
        &#125;
        void printAddr()&#123;
            cout&lt;&lt;&quot;m_pArr : &quot;&lt;&lt;m_pArr&lt;&lt;endl;
        &#125;
    private :
        int m_iCount;
        int *m_pArr;
    &#125;;
    int main()&#123;
        Array arr1(5);
        Array arr2(arr1);
        arr1.printAddr();
        arr2.printAddr();
        return 0;
    &#125;</code></pre>
<p>&nbsp;&nbsp;我们在类中添加一个数据成员int型的指针m_pArr，实例化一个对象arr1并给数据成员m_iCount赋值为5，与此同时系统也需要给另一个数据成员m_pArr在堆区分配内存空间 ；接着实例化一个对象arr2并将arr1的值复制给arr2，系统调用拷贝构造函数。将arr1.m_iCount赋值给arr2.m_iCount，将arr1.m_pArr赋值给arr2.m_iArr。因为在拷贝构造函数中，系统并没有在堆区分配一个内存空间给arr2的数据成员m_iArr。所以这里两个对象的数据成员m_iArr显然都指向了同一块内存空间。当我们在调用析构函数，释放内存空间的时候，两个对象指向的那块内存空间就会被释放两次，这样程序会奔溃，导致出错。 </p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre><code>    Array(const Array &amp;arr)&#123; /// 拷贝构造函数
        m_iCount = arr.m_iCount;
        m_pArr = new int[m_iCount];
        for(int i=0;i&lt;m_iCount;i++) m_pArr[i]=arr.m_pArr[i];
            cout&lt;&lt;&quot;Array &amp;&quot;&lt;&lt;endl;
    &#125;</code></pre>
<p>&nbsp;&nbsp;在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p>
<p>&nbsp;&nbsp;深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul>
<li><p>~类名()</p>
</li>
<li><p>没有参数</p>
</li>
<li><p>不能重载</p>
</li>
<li><p>当类中函数对象成员时，构造函数执行顺序：先执行成员对象的构造函数，再执行类的构造函数，析构函数则相反（例如造车）。</p>
</li>
</ul>
<h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）</p>
<p>&nbsp;&nbsp;而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址（int &amp;a的形式）。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
<p>&nbsp;&nbsp;引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。</p>
<p>&nbsp;&nbsp;程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<p>&nbsp;&nbsp;简单一点可以这么想，如果不用引用的话，被传递的参数本身是不能被修改的，即使你传递的是指针，也只能修改指针指向的内容，不能修改指针本身。如果要修改当前被传递的参数的话，要么再加一级指针，要么用引用。</p>
<ul>
<li>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</li>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</li>
<li>引用没有const，指针有const，const的指针不可变；（具体指没有int&amp; const a这种形式，而const int&amp; a是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</li>
<li>引用是类型安全的，而指针不是 (引用比指针多了类型检查）。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>1、引用</p>
<pre><code>    Point pt1(10,10);
    Point &amp;pt2=pt1;</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;定义了pt2为pt1的引用。通过这样的定义，pt1和pt2表示同一对象。<br>需要特别强调的是引用并不产生对象的副本，仅仅是对象的同义词。因此，当下面的语句执行后：</p>
<pre><code>    pt1.offset（2，2）；</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;pt1和pt2都具有（12，12）的值。引用必须在定义时马上被初始化，因为它必须是某个东西的同义词。你不能先定义一个引用后才初始化它。例如下面语句是非法的：</p>
<pre><code>    Point &amp;pt3；
    pt3=pt1；</code></pre>
<ul>
<li><p>传递参数使用引用</p>
</li>
<li><p>返回值使用引用</p>
<p>这里有一函数，它拥有两个引用参数并返回一个双精度数的引用：</p>
<pre><code>  double &amp;max(double &amp;d1,double &amp;d2) &#123;
      return d1&gt;d2?d1:d2;
  &#125;</code></pre>
<p>  由于max()函数返回一个对双精度数的引用，那么我们就可以用max() 来对其中较大的双精度数加1：</p>
<pre><code>  max(x,y)+=1.0;</code></pre>
</li>
</ul>
<h2 id="对象指针和对象引用"><a href="#对象指针和对象引用" class="headerlink" title="对象指针和对象引用"></a>对象指针和对象引用</h2><ul>
<li><p>指向数据成员的指针格式如下：</p>
<p>  &lt;类型说明符&gt;&lt;类名&gt;::*&lt;指针名&gt;</p>
</li>
<li><p>指向成员函数的指针格式如下：</p>
<p>  &lt;类型说明符&gt;(&lt;类名&gt;::*&lt;指针名&gt;)(&lt;参数表&gt;)</p>
</li>
<li><p>实例</p>
<pre><code>  class A &#123;  
      public:  
          A(int i) &#123; a=i; &#125;  
          int fun(int b) &#123; return a*c+b; &#125;  
          int c;  
      private:  
          int a;  
      &#125;; 

      void main() &#123;  
          A x(8);    //定义类A的一个对象x  
          int A::*pc; //定义一个指向类数据成员的指针pc  
          pc=&amp;A::c;    //给指针pc赋值  
          x.*pc=3;    //用指针方式给类成员c赋值为3  
          int (A::*pfun)(int);  //定义一个指向类成员函数的指针pfun  
          pfun=A::fun;      //给指针pfun赋值  
          A *p=&amp;x;    //定义一个对象指针p，并赋初值为x  
          cout&lt;&lt;(p-&gt;*pfun)(5)&lt;&lt;endl;    //用对象指针调用指向类成员函数指针pfun指向的函数  
  &#125;  </code></pre>
</li>
</ul>
<ol>
<li><p>对象指针作函数的参数</p>
<pre><code> class M &#123;  
 public:  
     M() &#123; x=y=0; &#125;  
     M(int i, int j) &#123; x=i; y=j; &#125;  
     void copy(M *m);  
     void setxy(int i, int j) &#123; x=i; y=j; &#125;  
     void print() &#123; cout&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;endl; &#125;  
 private:  
     int x, y;  
 &#125;;

 void M::copy(M *m) &#123;  
     x=m-&gt;x;  
     y=m-&gt;y;  
 &#125;

 void fun(M m1, M *m2);  

 void main() &#123;  
     M p(5, 7), q;  
     q.copy(&amp;p);  
     fun(p, &amp;q);  
     p.print();  
     q.print();  
 &#125;  
 void fun(M m1, M *m2) &#123;  
     m1.setxy(12, 15);  
     m2-&gt;setxy(22,25);  
 &#125;  </code></pre>
</li>
</ol>
<p>The output is：</p>
<pre><code>    5,7
    22,25</code></pre>
<ol start="2">
<li><p>对象引用作函数参数（更推荐）</p>
<pre><code> class M &#123;  
 public:  
     M() &#123; x=y=0; &#125;  
     M(int i, int j) &#123; x=i; y=j; &#125;  
     void copy(M &amp;m);  
     void setxy(int i, int j) &#123; x=i; y=j; &#125;  
     void print() &#123;cout&lt;&lt;x&lt;&lt;&quot;,&quot;&lt;&lt;y&lt;&lt;endl; &#125;  
 private:  
     int x, y;  
 &#125;;  

 void M::copy(M &amp;m) &#123;  
     x=m.x;  
     x=m.y;  
 &#125; 

 void fun(M m1, M &amp;m2);  

 void main() &#123;  
     M p(5, 7), q;  
     q.copy(p);  
     fun(p, q);  
     p.print();  
     q.print();  
 &#125;

 void fun(M m1, M &amp;m2) &#123;  
     m1.setxy(12, 15);  
     m2.setxy(22, 25);  
 &#125;  </code></pre>
<p> The output is same as the above。</p>
</li>
<li><p>this指针</p>
<p> 它是一个指向正在被该成员函数操作的对象,也就是要操作该成员函数的对象。</p>
</li>
</ol>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const是常量，是“只读”而“不可写”的。这个说法毋庸置疑的正确，然而不够具体，因为语法上可能会出现问题.</p>
<h2 id="常对象成员和常成员函数"><a href="#常对象成员和常成员函数" class="headerlink" title="常对象成员和常成员函数"></a>常对象成员和常成员函数</h2><ul>
<li><p>const修饰的常成员变量和常对象成员的初始化需要通过初始化列表实现。 </p>
</li>
<li><p>const修饰的成员函数，放在成员函数声明之后，const修饰的实际上就是this指针。</p>
</li>
<li><p>常成员函数不能修改成员变量的值，</p>
</li>
<li><p>常成员函数只能调用常成员函数，不能调用普通成员函数。</p>
</li>
<li><p>普通成员函数可以调用常成员函数。</p>
<pre><code>  class Time&#123;
      public:
          void show() const;
  &#125;;

  void Time::show() const &#123;
      ...
  &#125;</code></pre>
</li>
</ul>
<p>相当于：void Time::show(const Time *this)</p>
<p>成员函数不是一个普通的成员函数，而是一个 const 修饰过的常成员函数时，依然有一个隐含的参数：this 指针，但 this 指针是用 const 来修饰的，是一个常指针。通过常指针去改变该指针指向的数据，肯定是不被允许的。</p>
<h2 id="常指针和指针常量"><a href="#常指针和指针常量" class="headerlink" title="常指针和指针常量"></a>常指针和指针常量</h2><pre><code>const int* pt;          //常指针  
int* const ps;          //指针常量
const int * const pp;  //常指针常量</code></pre>
<ul>
<li><p>常指针：const修饰了int*，并未直接修饰pt，也就是说指针变量pt并不是“只读”的，而说的是pt是指向整型常量（重点）的指针，指针指向的数据不可更改，它指向常量。因此常指针的作用是保护指向的数据不被更改。如：</p>
<pre><code>  const char *P=&quot;ABCDEF&quot;;
  *P=&#39;1&#39;;//错误，视图更改指针指向的值  
  p[1]=&#39;1&#39;;//错误  
  p=NULL;//正确，视图修改指针的位置，而不是修改指针指向的内容</code></pre>
</li>
<li><p>指针常量：int* const ps中，const修饰指针ps本身，因此指针ps就是“只读”的，不能再改变指针本身的值，也即不能改变指针的指向，但指向的数据却是能更改的。如：</p>
<pre><code>  char * const p=&quot;ABCDEF&quot;; 
  p=NULL;//错误，指针常量不能再改变  
  p=&quot;1234&quot;;//错误  
  p=(char *)q;//错误</code></pre>
</li>
<li><p>常指针常量：指针不能改变，指针指向的值也不能改变</p>
<pre><code>  char *q;  
  const char * const p=&quot;ABCDEF&quot;;//定义了一个常量常指针  
  q=p;//错误，试图讲一个常指针赋值给非常指针  
  p=q;//错误，试图修改指针常量的值，如1  
  *p=‘1’；//错误，试图修改指针指向的值，如2  
  p[1]=&#39;1&#39;;//错误，如2  
  p=NULL；//错误，如1</code></pre>
</li>
</ul>
<h2 id="常引用和引用常量"><a href="#常引用和引用常量" class="headerlink" title="常引用和引用常量"></a>常引用和引用常量</h2><ul>
<li><p>实际上不存在引用常量这个说法，也不存在引用常量这个东西。</p>
</li>
<li><p>引用不占据内存空间这种说法是错的，引用实际上被解释为一个指针常量，而这也恰好符合引用本身不能更改的原则。</p>
</li>
<li><p>引用本身就被解释为指针常量，再用const修饰完全没有意义。</p>
</li>
<li><p>const引用可以延长生命周期:</p>
<p>  如:getValue()返回string值,在fun函数中调用时,可以通过const引用去接收它的返回值,会延长它的生命周期直到fun函数结束.</p>
</li>
</ul>
<h2 id="常指针和常引用"><a href="#常指针和常引用" class="headerlink" title="常指针和常引用"></a>常指针和常引用</h2><pre><code>class Coor &#123;
    public:
        Coor(int x, int y);
        int getX();
        int getY();
        void print() const;
    private:
        int m_iX;
        int m_iY;
&#125;

int Coor::getX() &#123;
    return m_iX;
&#125;

int Coor::getY() &#123;
    return m_iY;
&#125;

void Coor::print() const &#123;
    cout &lt;&lt; &quot;Hello.&quot; &lt;&lt; endl;
&#125;

int main() &#123;
    Coor coor1(3, 5);
    const Coor &amp;coor2 = coor1;
    const Coor *coor3 = &amp;coor1;
    coor1.print();      //1. right
    coor2.getX();       //2. wrong
    coor3-&gt;getY();      //3. wrong
    return 0;
&#125;

int main() &#123;
    Coor coor1(3, 5);
    Coor coor2(5, 7);
    Coor * const pCoor = &amp;coor1;
    pCoor-&gt;getX()       //4. right
    pCoor = &amp;coor2;     //5. wrong
    pCoor-&gt;print();     //6. wrong
    return 0;
&#125;</code></pre>
<ol>
<li>显然正确。</li>
<li>用coor2去调用getX()的时候，因为getX这个时候还会传入一个this指针，而这个this指针就是coor2这样的this指针,常对象不能调用非常成员变量。因为此时coor2是一个常引用，作为常引用来说，它只有读权限，而getX这里的参数this是一个要求读/写权限的参数，所以其传入的时候就会出现编译错误。</li>
<li>同理。</li>
<li>当pCoor去调用getY，而getY这里要求传入的是可读写权限的对象，而pCoor虽然用const修饰了，但是它的修饰位置是修饰的其本身（意味着这个指针不能指向其他对象），但是这个指针所指向的对象的内容本身是可变的，可见它是一个具有读写权限的指针，只限于它所指向的那个对象可读写，但是它却不能指向其他对象。所以这行代码是正确的。</li>
<li>再看下面一行代码，pCoor去指向了coor2，这个就是不允许的（因为pCoor不可以再指向其他对象了），显然这里编译器就会报错。</li>
<li>对于第三行代码，pCoor去调用print，显然也是正确的，因为print是一个常成员函数（常成员函数这里传入的this指针要求的是只读权限的），而此时的指针pCoor是具有可读写权限的，所以显然也是正确的。</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li><p>函数参数可以有默认值(有默认值的参数必须放在参数表最右端，建议函数声明处带默认值，函数定义处不要带默认值)，如</p>
<pre><code>  void fun(int x, int y = 2)</code></pre>
</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><pre><code>int add(int nLeft,int nRight);//函数定义  
int (*pf)(int,int);//简单函数指针：未初始化  
pf = add;//通过赋值使得函数指针指向某具体函数

typedef int (*PF)(int,int);  
PF pf;//此时，为指向某种类型函数的函数指针类型，而不是具体指针，用它可定义具体指针

pf(100,100);//与其指向的函数用法无异  
(*pf)(100,100);//此处*pf两端括号必不可少，两者都可以</code></pre>
<h3 id="函数指针作为形参"><a href="#函数指针作为形参" class="headerlink" title="函数指针作为形参"></a>函数指针作为形参</h3><pre><code>//第二个形参为函数类型，会自动转换为指向此类函数的指针  
Void fuc(int nValue,int pf(int,int));  

//等价的声明，显示的将形参定义为指向函数的指针  
Void fuc(int nValue,int (*pf)(int,int));  
Void fuc(int nValue,PF);  

pf = add;//pf是函数指针  
fuc(1,add);//add自动转换为函数指针  
fuc(1,pf);  </code></pre>
<h3 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h3><ul>
<li><p>使用typedef定义的函数指针类型作为返回参数</p>
<pre><code>  PF fuc2(int);//PF为函数指针类型  </code></pre>
</li>
<li><p>直接定义函数指针作为返回参数</p>
<pre><code>  int (*fuc2(int))(int,int);//显示定义  </code></pre>
</li>
</ul>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h3><h3 id="虚拟方法"><a href="#虚拟方法" class="headerlink" title="虚拟方法"></a>虚拟方法</h3><pre><code>class IDownloadSink
&#123;
public:
    virtual void OnDownloadFinished(const char* pURL, bool bOK) = 0;
&#125;;


class CMyDownloader
&#123;
public:
    CMyDownloader(IDownloadSink* pSink)
        :m_pSink(pSink)
    &#123;
    &#125;

    void DownloadFile(const char* pURL)
    &#123;
        cout &lt;&lt; &quot;downloading: &quot; &lt;&lt; pURL &lt;&lt; &quot;&quot; &lt;&lt; endl;
        if(m_pSink != NULL)
        &#123;
            m_pSink-&gt;OnDownloadFinished(pURL, true);
        &#125;
    &#125;

private:
    IDownloadSink* m_pSink;
&#125;;

class CMyFile: public IDownloadSink
&#123;
public:
    void download()
    &#123;
        CMyDownloader downloader(this);
        downloader.DownloadFile(&quot;www.sina.com&quot;);
    &#125;

    virtual void OnDownloadFinished(const char* pURL, bool bOK)
    &#123;
        cout &lt;&lt; &quot;OnDownloadFinished, URL:&quot; &lt;&lt; pURL &lt;&lt; &quot;    status:&quot; &lt;&lt; bOK &lt;&lt; endl;
    &#125;
&#125;;</code></pre>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h2><ul>
<li>书写规则：class A: public B</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基类成员访问属性</th>
<th align="center">继承方式</th>
<th align="center">派生类成员访问属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">public</td>
<td align="center">无法访问</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">public</td>
<td align="center">protected</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">public</td>
<td align="center">public</td>
</tr>
</tbody></table>
<h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><p>protected 在不涉及继承的时候表现与private相同</p>
<ul>
<li>书写规则：class A: protected B</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基类成员访问属性</th>
<th align="center">继承方式</th>
<th align="center">派生类成员访问属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">protected</td>
<td align="center">无法访问</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">protected</td>
<td align="center">protected</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">protected</td>
<td align="center">protected</td>
</tr>
</tbody></table>
<h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><ul>
<li>书写规则：class A: private B</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基类成员访问属性</th>
<th align="center">继承方式</th>
<th align="center">派生类成员访问属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">private</td>
<td align="center">无法访问</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">private</td>
<td align="center">private</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">private</td>
<td align="center">private</td>
</tr>
</tbody></table>
<h2 id="覆盖和隐藏"><a href="#覆盖和隐藏" class="headerlink" title="覆盖和隐藏"></a>覆盖和隐藏</h2><ul>
<li><p>隐藏：父子关系，成员同名</p>
<pre><code>  class Person &#123;
      public:
          void paly();
      private:
          string m_strName;
  &#125;

  class PersonA: public Person &#123;
      public:
          void paly();
          void work();
      private:
          int m_iAge;
  &#125;

  int main(int argc, char const *argv[])
  &#123;
      PersonA personA;
      personA.paly();
      personA.Person::paly();
      return 0;
  &#125;</code></pre>
</li>
</ul>
<h2 id="多继承和多重继承"><a href="#多继承和多重继承" class="headerlink" title="多继承和多重继承"></a>多继承和多重继承</h2><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><ul>
<li>友元函数、构造函数、普通函数，内联函数，static静态函数不能用virtual关键字修饰。普通成员函数和析构函数可以用virtual关键字修饰。</li>
<li>virtual的继承性：只要虚基类定义了virtual，继承类的该函数也就有virtual属性。</li>
</ul>
<h2 id="动态多态-绑定-和静态多态-绑定"><a href="#动态多态-绑定-和静态多态-绑定" class="headerlink" title="动态多态(绑定)和静态多态(绑定)"></a>动态多态(绑定)和静态多态(绑定)</h2><ul>
<li><p>绑定：把一个方法与其所在的类/对象关联起来叫做方法的绑定。绑定分为静态绑定（前期绑定）和动态绑定（后期绑定）。</p>
</li>
<li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。在程序运行前就已经知道方法是属于那个类的，在编译的时候就可以连接到类的中，定位到这个方法。在Java中，final、private、static修饰的方法以及构造函数都是静态绑定的，不需程序运行，不需具体的实例对象就可以知道这个方法的具体内容。</p>
</li>
<li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。在程序运行过程中，根据具体的实例对象才能具体确定是哪个方法。动态绑定是多态性得以实现的重要因素。对象的动态类型可以更改，但是静态类型无法更改。</p>
</li>
<li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</p>
</li>
<li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</p>
<pre><code>  class B &#123; 
      void DoSomething();  
      virtual void vfun();  
  &#125;

  class C : public B &#123;
      void DoSomething();//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。  
      virtual void vfun();
  &#125;

  class D : public B &#123;
      void DoSomething();  
      virtual void vfun();  
  &#125;

  D* pD = new D();//pD的静态类型是它声明的类型D*，动态类型也是D*  
  B* pB = pD;//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*
  C* pC = new C();
  pB = pC;//pB的动态类型是可以更改的，现在它的动态类型是C*  </code></pre>
</li>
<li><p>pD-&gt;DoSomething()和pB-&gt;DoSomething()调用的不是同一个函数，虽然pD和pB都指向同一个对象。因为函数DoSomething是一个no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。pD的静态类型是D<em>，那么编译器在处理pD-&gt;DoSomething()的时候会将它指向D::DoSomething()。同理，pB的静态类型是B</em>，那pB-&gt;DoSomething()调用的就是B::DoSomething()。</p>
</li>
<li><p>pD-&gt;vfun()和pB-&gt;vfun()调用的是同一个函数，因为vfun是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：D::vfun()。</p>
</li>
<li><p>上面都是针对对象指针的情况，对于引用（reference）的情况同样适用。</p>
</li>
<li><p><font color="#990000">只有虚函数才使用的是动态绑定，其他的全部是静态绑定</font>。</p>
</li>
<li><p>当缺省参数和虚函数一起出现的时候情况有点复杂，极易出错。我们知道，虚函数是动态绑定的，但是为了执行效率，缺省参数是静态绑定的。</p>
<pre><code>  class B &#123;  
      virtual void vfun(int i = 10);  
  &#125;  
  class D : public B &#123;  
      virtual void vfun(int i = 20);  
  &#125;

  D* pD = new D();  
  B* pB = pD;  
  pD-&gt;vfun();  
  pB-&gt;vfun();  </code></pre>
<ul>
<li><font color="#990000">缺省参数是静态绑定的</font>，pD-&gt;vfun()时，pD的静态类型是D*，所以它的缺省参数应该是20；同理，pB-&gt;vfun()的缺省参数应该是10。所以，<font color="#990000">绝不重新定义继承而来的缺省参数</font>。</li>
</ul>
</li>
</ul>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>防止内存泄漏，因为在析构函数中会释放一些资源，如对象指针等，而如果不声明为virtual类型，则在多态中可能不会执行而造成内存泄漏。</p>
<p>类的设计不不做为基类或者不不具有多态性,不不应该声明虚析构函数.</p>
<h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><ul>
<li><p>菱形继承：工人继承人，农民继承人，农民工继承工人和农民，所以农民工类里会出现两份人的成员。</p>
<pre><code>  class Worker: virtual public Person &#123;

  &#125;

  class Farmer: virtual public Person &#123;

  &#125;

  class MigrantWorker: public Worker, public Farmer &#123;

  &#125;</code></pre>
</li>
</ul>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>许多情况下，在基类中不能对虚函数给出有意义的实现，则把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<p>纯虚函数的声明格式：virtual &lt;函数返回类型说明符&gt; &lt;函数名&gt; ( &lt;参数表&gt; )=0;</p>
<p>纯虚函数的作用是为派生类提供一个一致的接口。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类是指含有纯虚函数的类(至少有一个纯虚函数)，该类不能创建对象(抽象类不能实例化)，但是可以声明指针和引用，用于基础类的接口声明和运行时的多态。</p>
<p>抽象类中，既可以有抽象方法，也可以有具体方法或者叫非抽象方法。抽象类中，既可以全是抽象方法，也可以全是非抽象方法。一个继承于抽象类的子类，只有实现了父类所有的抽象方法才能够是非抽象类。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>仅含有纯虚函数的类称为接口类。<br>定义接口的关键字是interface，例如：</p>
<pre><code>public interface MyInterface&#123;
    public void add(int x,int y);
    public void volume(int x,int y,int z);
&#125;</code></pre>
<p>继承接口的关键字是implements，相当于继承类的extends。需要注意的是，当继承一个接口时，接口里的所有函数必须全部被覆盖。<br>当想继承多个类时，开发程序不允许，报错。这样就要用到接口。因为接口允许多重继承，而类不允许（C++中可以多重继承）。所以就要用到接口。</p>
<h2 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h2><p>在这个表中，主是要一个类的虚函数的地址表.在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>这里我们着重看一下这张虚函数表。C++的编译器应该是保证<font color="#990000">虚函数表的指针存在于对象实例中最前面的位置</font>（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p>
<pre><code>class Base &#123;
    public:
        virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125;
        virtual void g() &#123; cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; &#125;
        virtual void h() &#123; cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; &#125;
&#125;;</code></pre>
<img src="base.png"/>

<ul>
<li><p>一般继承（无虚函数覆盖）</p>
<ol>
<li><p>虚函数按照其声明顺序放于表中。</p>
</li>
<li><p>父类的虚函数在子类的虚函数前面。</p>
</li>
</ol>
</li>
<li><p>一般继承（有虚函数覆盖）</p>
<ol>
<li><p>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</p>
</li>
<li><p>没有被覆盖的函数依旧。</p>
</li>
</ol>
</li>
<li><p>多重继承（无虚函数覆盖）</p>
<ol>
<li><p>每个父类都有自己的虚表。</p>
</li>
<li><p>子类的成员函数被放到了第一个父类(声明顺序)的表中。</p>
</li>
</ol>
</li>
<li><p>多重继承（有虚函数覆盖）</p>
<ol>
<li>三个父类虚函数表中的f()的位置被替换成了子类的函数指针。</li>
</ol>
</li>
</ul>
<h2 id="RTTI（Run-Time-Type-Identification）"><a href="#RTTI（Run-Time-Type-Identification）" class="headerlink" title="RTTI（Run-Time Type Identification）"></a>RTTI（Run-Time Type Identification）</h2><img src="RTTI.png" width="360"/>

<ul>
<li><p>dynamic_cast</p>
<ul>
<li>只能应用于指针的引用的转换</li>
<li>要转换的类型中必须包含虚函数</li>
<li>转换成功返回子类的地址，失败则返回NULL</li>
</ul>
</li>
<li><p>typeid</p>
<ul>
<li>返回一个type_info对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型,基类必须带有虚函数.</li>
<li>只能获取对象的实际类型</li>
</ul>
</li>
<li><p>type_info</p>
</li>
</ul>
<img src="type_info.png" width="360"/>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>void fun() &#123;
    throw 1;
&#125;

void fun1() &#123;
    throw string(&quot;Error String.&quot;);
&#125;

void fun2() &#123;
    throw new SizeException();
&#125;

int main(int argc, char const *argv[])
&#123;
    try &#123;
        fun();
        cout &lt;&lt; &quot;Hello.&quot; &lt;&lt; endl;
    &#125; catch(int) &#123;
        cout &lt;&lt; &quot;Error.&quot; &lt;&lt; endl;
    &#125;
    try &#123;
        fun1();
    &#125; catch(string &amp;s) &#123;
        cout &lt;&lt; s &lt;&lt; endl;
    &#125;
    try &#123;
        fun2();
    &#125; catch(SizeException &amp; sizeException) &#123;

    &#125; catch(Exception exception) &#123;

    &#125;
    cout &lt;&lt; &quot;Normal.&quot; &lt;&lt; endl;
    return 0;
&#125;</code></pre>
<h1 id="友元函数和友元类"><a href="#友元函数和友元类" class="headerlink" title="友元函数和友元类"></a>友元函数和友元类</h1><ul>
<li>关键字:friend</li>
</ul>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><ul>
<li><p>C++中引入友元函数，是为在该类中提供一个对外访问的窗口,在类中声明该函数可以直接访问类中的private或者protected成员。</p>
</li>
<li><p>友元函数的声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。</p>
</li>
<li><p>一个类中的成员函数可以是另外一个类的友元函数(友元成员函数)，而且一个函数可以是多个类友元函数。</p>
</li>
<li><p>友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。</p>
</li>
<li><p>友元函数在调用上同一般函数一样，不必通过对对象进行引用。</p>
<pre><code>  class Coor &#123;
      public:
          Coor(int x, int y);
          friend void printXY(Coor &amp;coor, int x);
      private:
          int m_iX;
          int m_iY;
  &#125;

  void printXY(Coor &amp;coor, int x) &#123;
      coor.m_iX = x;
  &#125;

  int main(int argc, char const *argv[])
  &#123;
      Coor coor(3, 5);
      printXY(coor);
      return 0;
  &#125;</code></pre>
</li>
<li><p>友元成员函数</p>
<p>  当用到友元成员函数时，需注意友元声明和友元定义之间的相互依赖:</p>
<p>  在该例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。</p>
<p>  更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类(友元类)和非成员函数(友元函数)来将它们设为友元。</p>
<pre><code>  class Coor;  //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类Coor的声明
  class Draw &#123;
  class C &#123;
      public:
          //引用的Coor必须事先声明或者定义
          void run(Coor &amp;coor);
  &#125;

  class Coor &#123;
      public:
          Coor(int x, int y);
          friend void Draw:run(Coor &amp;coor);
      private:
          int m_iX;
          int m_iY;
  &#125;

  void Draw:run(Coor &amp;coor) &#123; &#125;

  int main(int argc, char const *argv[])
  &#123;
      Coor coor(3, 5);
      printXY(coor);
      return 0;
  &#125;</code></pre>
</li>
</ul>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息,定义友元类的语句格式如下：</p>
<pre><code>friend class 类名;</code></pre>
<ul>
<li><p>友元关系不能被继承。</p>
</li>
<li><p>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
</li>
<li><p>友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<pre><code>  class A &#123;
  public:
      friend class C; //这是友元类的声明
  private:
      int data;
  &#125;;

  class C &#123;
  public:
      //引用的A必须事先定义或声明
      void set_show(int x, A &amp;a) &#123; &#125;
  &#125;;

  int main(void) &#123;
      class A a;
      class C c;
      c.set_show(1, a);
      return 0;
  &#125;</code></pre>
</li>
</ul>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ol>
<li><p>全局静态变量</p>
<ul>
<li>用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.</li>
<li>内存中的位置：静态存储区，在整个程序运行期间一直存在。</li>
<li>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</li>
<li>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</li>
</ul>
</li>
<li><p>局部静态变量</p>
<ul>
<li>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</li>
<li>内存中的位置：静态存储区</li>
<li>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</li>
<li>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</li>
</ul>
</li>
<li><p>静态函数</p>
<ul>
<li>在函数返回类型前加关键字static，函数就定义成静态函数,静态函数只是在声明他的文件当中可见，不能被其他文件所用；</li>
</ul>
</li>
<li><p>类的静态成员</p>
<ul>
<li>在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，其属于该类的所有成员共有，只有一个拷贝；</li>
</ul>
</li>
<li><p>类的静态成员函数</p>
<ul>
<li><p>实现的时候也不需要static的修饰，因为static是声明性关键字；类的静态函数是该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用；实际上，他就是增加了类的访问权限的全局函数；</p>
<pre><code>  void  A::func(int);</code></pre>
</li>
<li><p>静态成员函数可以继承和覆盖，但无法是虚函数；</p>
</li>
</ul>
</li>
<li><p>warning：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰.</p>
</li>
</ol>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><pre><code>template &lt;class T&gt;
//或 template &lt;typename T&gt;
T max(T a, Tb) &#123;
    return (a &gt; b)?a:b;
&#125;

int ival = max(100, 99);  //推断T的类型为int
char cval = max&lt;char&gt;(&#39;A&#39;, &#39;B&#39;);
int (*pf)(int, int) = max; //推断T的类型为int</code></pre>
<ul>
<li>成员函数模板不能是虚函数,因为c++ compiler在parse一个类的时候就要确定vtable的大小，如果允许一个虚函数是模板函数，那么compiler就需要在parse这个类之前扫描所有的代码，找出这个模板成员函数的调用（实例化），然后才能确定vtable的大小，而显然这是不可行的，除非改变当前compiler的工作机制。</li>
<li>模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译，这一过程被称为模板实例化。用户提供不同的类型参数，就会实例化出不同的代码。</li>
</ul>
<h3 id="返回值为模板参数"><a href="#返回值为模板参数" class="headerlink" title="返回值为模板参数"></a>返回值为模板参数</h3><ul>
<li><p>返回值类型与参数类型完全无关，则显式指定返回值类型.此行为与函数的默认实参相同，我们必须从左向右逐一指定。</p>
<pre><code>  template &lt;typename T1, typename T2, typename T3&gt;
  T1 sum(T2 v2, T3 v3) &#123;
      return static_cast&lt;T1&gt;(v2 + v3);
  &#125;

  int main() &#123;
      auto ret = sum&lt;float&gt;(1L, 23);
      //auto ret = sum&lt;long,long,int&gt;(1L,23);
      cout &lt;&lt; ret &lt;&lt; endl;
      return 0;
  &#125;</code></pre>
</li>
<li><p>返回值类型可以从参数类型中获得，那么把函数写成尾置返回类型的形式，就可以愉快的使用实参推断了。</p>
<pre><code>  template&lt;typename It&gt;
  auto sum(It beg, It end) -&gt; decltype(*beg) &#123;
  decltype(*beg) ret = *beg;
  for (It it = beg+1; it != end; it++) &#123;
      ret  = ret + *it;
  &#125;
  return ret;
  &#125;

  vector&lt;int&gt; v = &#123;1, 2, 3, 4&#125;;
  auto s = sum(v.begin(), v.end()); //s = 10</code></pre>
</li>
</ul>
<h3 id="函数模板重载"><a href="#函数模板重载" class="headerlink" title="函数模板重载"></a>函数模板重载</h3><p>函数模板之间，函数模板与普通函数之间可以重载。编译器会根据调用时提供的函数参数，调用能够处理这一类型的最特殊的版本。在特殊性上，一般按照如下顺序考虑：</p>
<ul>
<li><p>普通函数</p>
</li>
<li><p>特殊模板（限定了T的形式的，指针、引用、容器等）</p>
</li>
<li><p>普通模板（对T没有任何限制的）</p>
<pre><code>  template&lt;typename T&gt;
  void func(T&amp; t) &#123; //通用模板函数
      cout &lt;&lt; &quot;In generic version template &quot; &lt;&lt; t &lt;&lt; endl;
  &#125;

  template&lt;typename T&gt;
  void func(T* t) &#123; //指针版本
      cout &lt;&lt; &quot;In pointer version template &quot;&lt;&lt; *t &lt;&lt; endl;
  &#125;

  void func(string* s) &#123; //普通函数
      cout &lt;&lt; &quot;In normal function &quot; &lt;&lt; *s &lt;&lt; endl;
  &#125;yf

  int i = 10;
  func(i); //调用通用版本，其他函数或者无法实例化或者不匹配
  func(&amp;i); //调用指针版本，通用版本虽然也可以用，但是编译器选择最特殊的版本
  string s = &quot;abc&quot;;
  func(&amp;s); //调用普通函数，通用版本和特殊版本虽然也都可以用，但是编译器选择最特化的版本
  func&lt;&gt;(&amp;s); //调用指针版本，通过&lt;&gt;告诉编译器我们需要用template而不是普通函数</code></pre>
</li>
</ul>
<h3 id="模板函数特化"><a href="#模板函数特化" class="headerlink" title="模板函数特化"></a>模板函数特化</h3><pre><code>template&lt;&gt;
void func(int i) &#123;
    cout &lt;&lt; &quot;In special version for int &quot;&lt;&lt; i &lt;&lt; endl; 
&#125;
int i = 10;
func(i); //调用特化版本</code></pre>
<p>yf<br>    template <int size><br>    void display() {<br>        cout &lt;&lt; size &lt;&lt; endl;<br>    }<br>    display&lt;10&gt;();</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>为了节省资源，类模板实例化时并不是每个成员函数都实例化了，而是使用到了哪个成员函数，那个成员函数才实例化。</p>
<pre><code>//一个模板参数
template&lt;typename T&gt;
class Printer &#123;
public:
    //定义在内部
    void print() &#123;
        cout &lt;&lt; t &lt;&lt; endl;
    &#125;
private:
    T t;
&#125;;

//定义在外部
template &lt;class T&gt;
void Printer&lt;T&gt;::print()&#123;1 &#125;

Printer&lt;int&gt; printer;

//多个模板参数
template&lt;typename T, int size&gt;
class Printer &#123;
public:
    //定义在内部
    void prinyft();
private:
    T t;
&#125;;
template&lt;typename T&gt;
class Printer &#123;
public:
    //定义在内部
    void print() &#123;
        cout &lt;&lt; t &lt;&lt; endl;
    &#125;
private:
    T t;
&#125;;

//定义在外部
template &lt;class T&gt;
void Printer&lt;T&gt;::print()&#123;1 &#125;

Printer&lt;int&gt; printer;
//定义在外部
template &lt;class T, int size&gt;
void Printer&lt;T, size&gt;::print()&#123;1 &#125;</code></pre>
<p>xuexibiji<br>    Printer&lt;int, 10&gt; printer;</p>
<h3 id="类模板中的static成员"><a href="#类模板中的static成员" class="headerlink" title="类模板中的static成员"></a>类模板中的static成员</h3><p>类模板中可以声明static成员，在类外定义的时候要增加template相关的关键词。另外，需要注意的是：每个不同的模板实例都会有一个独有的static成员对象。</p>
<p>其实这个结论是显然的，static成员属于模板实例化后的类，不同的实例化当然有不同static成员。就像下面的例子一样，pi.s_value += 1只影响到了Printer<int>，而不会影响到Printer<double>。</p>
<pre><code>template&lt;typename T&gt;
class Printer &#123;
public:
    explicit Printer(const T&amp; param):t(param)&#123;&#125;
    static int s_value;
private:
    T t;
&#125;;

template&lt;typename T&gt; //注意这里的定义方式
int Printer&lt;T&gt;::s_value = 1;

Printer&lt;int&gt; pi(1);
Printer&lt;int&gt; pi2(1);
Printer&lt;double&gt; pd(1.0);
pi.s_value += 1; //pi和pi2中的改变了，pd的没改变</code></pre>
<h3 id="特化和偏特化"><a href="#特化和偏特化" class="headerlink" title="特化和偏特化"></a>特化和偏特化</h3><h2 id="标准模板库-STL"><a href="#标准模板库-STL" class="headerlink" title="标准模板库(STL)"></a>标准模板库(STL)</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul>
<li>初始化</li>
</ul>
<img src="vector-init.png" width="420"/>

<ul>
<li>常用方法</li>
</ul>
<img src="vector-api.png" width="420"/>

<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><ul>
<li>可以迭代访问标准模板库中的元素</li>
</ul>
<img src="iterator.png" width="420"/>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul>
<li>使用与vector基本相似</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><img src="map.png" width="420"/>

<h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><ul>
<li>初始化<ul>
<li>pair&lt;T1, T2&gt; p;</li>
<li>pair&lt;T1, T2&gt; p(v1, v2);</li>
<li>make_pair(v1, v2)</li>
</ul>
</li>
</ul>
<p>pair对象还有一些方法，如取出pair对象中的每一个成员的值：</p>
<ul>
<li>p.first</li>
<li>p.second</li>
</ul>
<h4 id="map元素插入"><a href="#map元素插入" class="headerlink" title="map元素插入"></a>map元素插入</h4><ul>
<li>使用下标</li>
<li>使用insert函数</li>
</ul>
<h4 id="map元素查找"><a href="#map元素查找" class="headerlink" title="map元素查找"></a>map元素查找</h4><p><strong>在map中使用下标访问不存在的元素将导致在map容器中添加一个新的元素。</strong></p>
<p>若只是查找该元素是否存在，可以使用函数count(k)，该函数返回的是k出现的次数；若是想取得key对应的值，可以使用函数find(k)，该函数返回的是指向该元素的迭代器。</p>
<h4 id="map元素删除"><a href="#map元素删除" class="headerlink" title="map元素删除"></a>map元素删除</h4><p>从map中删除元素的函数是erase()，该函数有如下的三种形式：</p>
<ul>
<li>m.erase(k)</li>
<li>m.erase(p)</li>
<li>m.erase(b, e)</li>
</ul>
<p>第一种方法删除的是m中键为k的元素，返回的是删除的元素的个数；第二种方法删除的是迭代器p指向的元素，返回的是void；第三种方法删除的是迭代器b和迭代器e范围内的元素，返回void。</p>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><h2 id="static-cast（编译时类型检查）"><a href="#static-cast（编译时类型检查）" class="headerlink" title="static_cast（编译时类型检查）"></a>static_cast（编译时类型检查）</h2><p>用法：static_cast &lt; type-id &gt; ( expression )，该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性，它主要有如下几种用法：</p>
<ol>
<li>用于基本数据类型之间的转换，如把int转换为char，把int转换成enum，但这种转换的安全性需要开发者自己保证（这可以理解为保证数据的精度，即程序员能不能保证自己想要的程序安全），如在把int转换为char时，如果char没有足够的比特位来存放int的值（int&gt;127或int&lt;-127时），那么static_cast所做的只是简单的截断，及简单地把int的低8位复制到char的8位中，并直接抛弃高位。</li>
<li>把空指针转换成目标类型的空指针</li>
<li>把任何类型的表达式类型转换成void类型</li>
<li>用于类层次结构中父类和子类之间指针和引用的转换。</li>
</ol>
<p>对于以上第（4）点，存在两种形式的转换，即上行转换（子类到父类）和下行转换（父类到子类）。对于static_cast，上行转换时安全的，而下行转换时不安全的，为什么呢？因为static_cast的转换时粗暴的，它仅根据类型转换语句中提供的信息（尖括号中的类型）来进行转换，这种转换方式对于上行转换，由于子类总是包含父类的所有数据成员和函数成员，因此从子类转换到父类的指针对象可以没有任何顾虑的访问其（指父类）的成员。而对于下行转换为什么不安全，是因为static_cast只是在编译时进行类型坚持，没有运行时的类型检查，具体原理在dynamic_cast中说明。</p>
<h2 id="dynamic-cast（运行时类型检查）"><a href="#dynamic-cast（运行时类型检查）" class="headerlink" title="dynamic_cast（运行时类型检查）"></a>dynamic_cast（运行时类型检查）</h2><p>用法：同static_cast</p>
<p>dynamic_cast主要用于类层次结构中父类和子类之间指针和引用的转换，由于具有运行时类型检查，因此可以保证下行转换的安全性，何为安全性？即转换成功就返回转换后的正确类型指针，如果转换失败，则返回NULL，之所以说static_cast在下行转换时不安全，是因为即使转换失败，它也不返回NULL。</p>
<p>对于上行转换，dynamic_cast和static_cast是一样的。</p>
<p>对于下行转换，说到下行转换，有一点需要了解的是在C++中，一般是可以用父类指针指向一个子类对象，如parent* P1 = new Children(); 但这个指针只能访问父类定义的数据成员和函数，这是C++中的静态联翩，但一般不定义指向父类对象的子类类型指针，如Children* P1 = new parent；这种定义方法不符合生活习惯，在程序设计上也很麻烦。这就解释了也说明了，在上行转换中，static_cast和dynamic_cast效果是一样的，而且都比较安全，因为向上转换的对象一般是指向子类对象的子类类型指针；而在下行转换中，由于可以定义就不同了指向子类对象的父类类型指针，同时static_cast只在编译时进行类型检查，而dynamic_cast是运行时类型检查，则需要视情况而定。下面通过代码进行说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于需要进行向下转换，因此需要定义一个父类类型的指针Base *P，但是由于子类继承与父类，父类指针可以指向父类对象，也可以指向子类对象，这就是重点所在。如果 P指向的确实是子类对象，则dynamic_cast和static_cast都可以转换成功，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base *P = <span class="keyword">new</span> Derived();</span><br><span class="line">Derived *pd1 = <span class="keyword">static_cast</span>&lt;Derived *&gt;(P);</span><br><span class="line">Derived *pd2 = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(P);</span><br></pre></td></tr></table></figure>

<p>以上转换都能成功。但是，如果 P 指向的不是子类对象，而是父类对象，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base *P = <span class="keyword">new</span> Base;</span><br><span class="line">Derived *pd3 = <span class="keyword">static_cast</span>&lt;Derived *&gt;(P);</span><br><span class="line">Derived *pd4 = <span class="keyword">dynamic_cast</span>&lt;Derived *&gt;(P);</span><br></pre></td></tr></table></figure>

<p>在以上转换中，static_cast转换在编译时不会报错，也可以返回一个子类对象指针（假想），但是这样是不安全的，在运行时可能会有问题，因为子类中包含父类中没有的数据和函数成员，这里需要理解转换的字面意思，转换是什么？转换就是把对象从一种类型转换到另一种类型，如果这时用 pd3 去访问子类中有但父类中没有的成员，就会出现访问越界的错误，导致程序崩溃。而dynamic_cast由于具有运行时类型检查功能，它能检查P的类型，由于上述转换是不合理的，所以它返回NULL。</p>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>缺陷太多.</p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr有个“引用计数”的概念，当引用计数变成0时，这个对象就被自动删除。</p>
<pre><code>std::shared_ptr&lt;std::string&gt; sp2 = std::make_shared&lt;std::string&gt;(&quot;Hello c++&quot;);
auto sp4 = std::make_shared&lt;std::string&gt;(&quot;C++11&quot;);</code></pre>
<ul>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span>  <span class="comment">//普通的函数，用来执行线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t1111\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;t22222\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(t1)</span></span>;  <span class="comment">//实例化一个线程对象th1，使用函数t1构造，然后该线程就开始执行了（t1()）</span></span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.join(); <span class="comment">//等待th1执行完</span></span><br><span class="line">    th2.join(); <span class="comment">//等待th2执行完</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;here is main\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h2><p>使用mutex是不安全的，当一个线程在解锁之前异常退出了，那么其它被阻塞的线程就无法继续下去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        m.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(t1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(t2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>使用lock_guard则相对安全，它是基于作用域的，能够自解锁，当该对象创建时，它会像m.lock()一样获得互斥锁，当生命周期结束时，它会自动析构(unlock)，不会因为某个线程异常退出而影响其他线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">20</span>;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-编码"><a href="#C-编码" class="headerlink" title="C++编码"></a>C++编码</h1><ul>
<li>宏定义的内容用括号包含</li>
<li>类的成员变量使用m_小写开头，静态全局变量使用s_小写开头，全局变量使用g_小写开头。</li>
<li>类上添加命名空间</li>
<li>头文件的包含顺序：先是我们的头文件，再是系统的头文件，这样做如果我们的头文件中少包含了一个必需的系统头文件时就能发现。</li>
<li>类的声明中先声明public，再声明private，让使用者一眼便能看到他能调用的东西。</li>
<li>如果一个类不能被复制或赋值，把拷贝构造函数和赋值操作符禁用掉</li>
<li>类的所有成员都需要初始化</li>
<li>方法中需要检查参数的合法性</li>
<li>模块内定义全局变量量应该声明为static</li>
<li>引用与指针的区别<ul>
<li>指针是一一个实体,引用用是一一个别名</li>
<li>引用用必须要初始化,指针可以任意时机初始化</li>
<li>引用用在定义初始化后不不可再改变,指针可以修改所指内容</li>
<li>引用用不不能为空,指针可以为空</li>
<li>引用用不不需要解引用用,指针需要用用*解引用用</li>
</ul>
</li>
<li>对于类类型传值的影响:<ul>
<li>调用用类的拷⻉贝构造函数构建对象的副本影响性能</li>
<li>造成对象切割</li>
</ul>
</li>
<li>头文件中不要有using namespace</li>
<li>对象初始化尽量使用初始化列表进行初始化</li>
<li>尽量以const、enum、inline替换#define</li>
</ul>
<ul>
<li>代码加注释</li>
<li>folder.cpp共享常量放在constant里</li>
<li>变量定义MessageIds有歧义</li>
<li>folder.hpp-57</li>
<li>folder.hpp-62:虚析构函数</li>
<li>folder.hpp-69:setter不需要返回值</li>
<li>folder.hpp-76:长期持有类成员变量时需要返回值,不用引用</li>
<li>folder.hpp-104:基础数据类型不需要用引用</li>
<li>folder.hpp-132:返回不能加引用(返回一个局部变量)</li>
<li>folder.hpp-218:没注释</li>
<li>folder.cpp-77:协议交换</li>
<li>folder.cpp-108:删除文件夹协议的实现</li>
<li>folder.cpp-108:debug日志,log日志,注释</li>
<li>folder.cpp-134:参数引用</li>
<li>folder.cpp-200:printf()缺少</li>
<li>folder.cpp-234:调用别人函数的结果要进行判断</li>
<li>folder.cpp-246:folder里进行实现</li>
<li>folder.cpp-300:批量操作用事务</li>
<li>floder.cpp-354:if,else去掉,无效字符会改为空字符串</li>
<li>floder.cpp-400…:if-else</li>
<li>Message.hpp-26:修改为logContent()</li>
<li>Message.hpp-30:合并到26行</li>
<li>Message.hpp-34:异步无返回值</li>
<li>Message.hpp-36:无const和&amp;</li>
<li>Message.hpp-61:指针</li>
<li>Message.cpp-51:测试在接口外面传值</li>
<li>Message.cpp-206:链式调用分行</li>
<li>Message.cpp-…:许多值写死了</li>
<li>ExchangeMessage.hpp-36:传引用</li>
<li>ExchangeMessage.hpp-74:分行,传引用</li>
<li>ExchangeMessage.hpp-60,61:指针</li>
<li>ExchangeMessage.cpp-27:重复引用</li>
<li>ExchangeMessage.cpp-43:const引用可以延长生命周期(返回为值,也可以使用const引用去接收,会延长它的生命周期直到函数结束)</li>
<li>AccountManager.cpp-33:if-else 头重脚轻</li>
<li>AccountManager.cpp-15:static定义不合适</li>
<li>AccountManager.cpp-47:使用size判断</li>
<li>AccountManager.cpp-48…:字段使用常量</li>
<li>AccountManager.cpp-65:参数使用NULL代替0</li>
<li>AccountManager.cpp-100…:函数内部逻辑拆分,重复语句</li>
<li>ExchangeSession.hpp-42:const</li>
<li>ExchangeSession.hpp-48:不加static</li>
<li>ExchangeSession.hpp-62:const &amp;</li>
<li>ExchangeSession.hpp-69:函数命名规范,函数private</li>
<li>ExchangeSession.hpp-83:成员变量命名,指针指向内存没释放</li>
<li>ExchangeSession.cpp-36:引用计数+1,在析构函数中引用计数-1</li>
<li>ExchangeSession.cpp-login:代码冗余</li>
<li>ExchangeSession.cpp-158:参数</li>
<li>ExchangeSession.cpp-320:返回</li>
<li>ExchangeSession.cpp-364:判断是否为空</li>
<li>ExchangeSession.cpp-380:参数合法性判断</li>
<li>ExchangeSession.cpp-393:返回值判断,做与操作</li>
<li>ExchangeSession.cpp-413:判断</li>
<li>ExchangeSession.cpp-…444…:日志记录</li>
<li>ExchangeSession.cpp-471:函数不清, 使用枚举</li>
<li>ExchangeSession.cpp-499:错误return</li>
<li>ExchangeSession.cpp-…:错误return</li>
<li>ExchangeSession.cpp-…:头重脚轻的代码</li>
<li>ExchangeSession.cpp-541:工具函数写在Util目录</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">158</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
