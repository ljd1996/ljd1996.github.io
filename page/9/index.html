<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:type" content="website">
<meta property="og:title" content="苍耳的博客">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="苍耳的博客">
<meta property="og:description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="苍耳叔叔">
<meta property="article:tag" content="诗歌，宋词，后台，Android，Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>苍耳的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">苍耳的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">细水长流</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EIO/" class="post-title-link" itemprop="url">操作系统-文件系统与IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-05 20:34:52" itemprop="dateCreated datePublished" datetime="2019-12-05T20:34:52+08:00">2019-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2019/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EIO/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统-文件系统与IO" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EIO/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EIO/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h1><h2 id="盘片-盘面-磁头"><a href="#盘片-盘面-磁头" class="headerlink" title="盘片/盘面/磁头"></a>盘片/盘面/磁头</h2><p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。如下图：</p>
<p><img src="%E7%9B%98%E9%9D%A2-%E7%A3%81%E5%A4%B4.webp" alt="盘片-盘面-磁头"></p>
<h2 id="扇区-磁道"><a href="#扇区-磁道" class="headerlink" title="扇区/磁道"></a>扇区/磁道</h2><p>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）</p>
<p><img src="%E6%89%87%E5%8C%BA-%E7%A3%81%E9%81%93.webp" alt="扇区-磁道"></p>
<h2 id="磁头-柱面"><a href="#磁头-柱面" class="headerlink" title="磁头/柱面"></a>磁头/柱面</h2><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。如下图：</p>
<p><img src="%E7%A3%81%E5%A4%B4-%E6%9F%B1%E9%9D%A2.webp" alt="磁头-柱面"></p>
<h2 id="磁盘容量计算"><a href="#磁盘容量计算" class="headerlink" title="磁盘容量计算"></a>磁盘容量计算</h2><p>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</p>
<p>上图中磁盘是一个3个圆盘6个磁头，7个柱面（每个盘片7个磁道）的磁盘，图3中每条磁道有12个扇区，所以此磁盘的容量为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 * 7 * 12 * 512 = 258048</span><br></pre></td></tr></table></figure>

<p>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</p>
<h2 id="磁盘读取响应时间"><a href="#磁盘读取响应时间" class="headerlink" title="磁盘读取响应时间"></a>磁盘读取响应时间</h2><ul>
<li>寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</li>
<li>旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。</li>
<li>数据传输时间：完成传输所请求的数据所需要的时间。</li>
</ul>
<p>小结一下：从上面的指标来看、其实最重要的或者说最关心的应该只有两个：寻道时间；旋转延迟。</p>
<p>读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，软件应着重考虑减少寻道时间和延迟时间。</p>
<h2 id="块-簇"><a href="#块-簇" class="headerlink" title="块/簇"></a>块/簇</h2><p>磁盘块/簇是虚拟出来的，块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。</p>
<p>通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64等的n次方个扇区。</p>
<p>优点：</p>
<ul>
<li>读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。</li>
<li>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。</li>
</ul>
<p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。</p>
<p>扇区、块/簇、page的关系：</p>
<ul>
<li>扇区：硬盘的最小读写单元</li>
<li>块/簇：是操作系统针对硬盘读写的最小单元</li>
<li>页：是内存与操作系统之间操作的最小单元。</li>
<li>扇区 &lt;= 块/簇 &lt;= page</li>
</ul>
<h1 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h1><p>固态硬盘和机械硬盘分别采用两种当下流行的持久储存方式（区别于内存断电即失去数据的储存）。</p>
<p>固态硬盘跟机械硬盘不一样。固态硬盘：是由电子芯片及电路板，没有磁头，没有磁盘（机械硬盘靠磁盘转动读取数据），固态硬盘不是机械操作的。</p>
<p>机械硬盘使用磁为介质保存数据，利用磁头读写圆盘面微小磁体的磁极来实现数据读写。</p>
<p>固态硬盘采用闪存为储存介质，和U盘的原理几乎一样，闪存外观很像CPU、内存那种芯片，也和内存一样内部没有任何活动的机械部件。</p>
<p>机械硬盘在不同位置读写时，磁头要来回运动，在同一个地方连续写入一段数据时效率更高，随机乱序读写时效率很低。而闪存不用，随机读写和顺序读写几乎没有速度区别。</p>
<p>普通U盘单个闪存芯片的读写速度无法及得上机械硬盘，而固态硬盘实际是闪存整列，利用多个闪存并行读写来达到甚至超过机械硬盘的读写速度，并行的闪存数无上限，读写速度、容量与闪存芯片数成正比，但价格也成正比。</p>
<p>固态硬盘除了速度高，还有功耗低、无噪音、低故障率的优点。理论上闪存有写次数限制，以目前技术来说同一个位置写超过3000次就会失效并故障，但固态硬盘采用不同于机械硬盘的写入策略，将写入操作平均分摊在整个空间内，所以在普通家用中几乎不会有些写坏的那一天，这也是固态硬盘与普通闪存的本质区别。</p>
<h1 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h1><h2 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h2><p>文件系统存放在磁盘上。多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。磁盘的0号扇区称为<strong>主引导记录(Master Boot Record，MBR)**，用来引导计算机。在MBR的结尾是</strong>分区表<strong>。该表给出了毎个分区的起始和结束地址。表中的一个分区被标记为</strong>活动分区<strong>。在计算机被引导时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一个块，称为</strong>引导块**(boot block)，并执行之。引导块中的程序将装载该分区中的操作系统。为统一起见，毎个分区都从一个引导块开始，即使它不含有一个可启动的操作系统。不过，未来这个分区也许会有一个操作系统的。</p>
<p>一个可能的文件系统布局如下：</p>
<p><img src="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.jpg" alt="文件系统布局"></p>
<ul>
<li>超级块：超级块包含文件系统的所有关键参数，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括：确定文件系统类型用的魔数、文件系统中块的数量以及其他重要的管理信息。</li>
<li>空闲块：可以用位图或指针列表的形式给出。</li>
<li>i节点：一个数据结构数组，每个文件一个，i节点说明了文件的方方面面。</li>
<li>根目录：存放文件系统目录树的根部。</li>
<li>目录和文件。</li>
</ul>
<h2 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h2><p>文件存储实现的关键问题是记录各个文件分别用到哪些磁盘块，不同操作系统采用不同的方法。</p>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。所以，在块大小为1KB的磁盘上，50KB的文件要分配50个连续的块。对于块大小为2KB的磁盘，将分配25个连续的块。</p>
<p>每个文件都从一个新的块开始，因此可能会在结尾浪费一些空间。</p>
<p>优点：</p>
<ul>
<li>实现简单</li>
<li>读操作性能好，因为在单个操作中就可以从磁盘上读出整个文件。只需要一次寻找（对第一个块）。之后不再需要寻道和旋转延迟，所以，数据以磁盘全带宽的速率输入。</li>
</ul>
<p>缺点：</p>
<ul>
<li>随着时间的推移，磁盘会变得零碎。因为删除文件时，会造成空洞，而挤掉这些空洞可能需要复制大量的文件，代价太高。</li>
<li>可以维护一个空洞列表，但是为了录入一个文档，用户启动了文本编辑器或字处理软件，程序首先询问最终文件的大小会是多少。如果用户为了避免这个问题而给出不实际的较大的数字作为最后文件的大小，则可能由于不存在这么大的空洞而使得创建失败。</li>
<li>空洞列表这种方式在CD-ROM上被广泛使用。在这里所有文件的大小都事先知道，并且在CD-ROM文件系统的后续使用中，这些文件的大小也不再改变。</li>
</ul>
<h3 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h3><p>存储文件的第二种方法是为每个文件构造磁盘块链表，每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。与连续分配方案不同，这一方法可以充分利用每个磁盘块。同样，在目录项中，只需要存放第一块的磁盘地址，文件的其他块就可以从这个首块地址査找到。</p>
<p>另一方面，在链表分配方案中，尽管顺序读文件非常方便，但是随机访问却相当缓慢。要获得块n，操作系统每一次都必须从头开始，并且要先读前面的块。显然，进行如此多的读操作太慢了。</p>
<p>而且，由于指针占去了一些字节，每个磁盘块存储数据的字节数不再是2的整数次幂。虽然这个问题并不是非常严重，但是也会降低系统的运行效率，因为许多程序都是以长度为2的整数次幂来读写磁盘块的。由于每个块的前几个字节被指向下一个块的指针所占据，所以要读出完整的一个块大小的信息，就需要从两个磁盘块中获得和拼接信息，这就因复制引发了额外的开销。</p>
<h3 id="文件分配表（内存）"><a href="#文件分配表（内存）" class="headerlink" title="文件分配表（内存）"></a>文件分配表（内存）</h3><p>如果取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足。</p>
<p>假设文件A依次使用了磁盘块4、7、2、10和12，文件B依次使用了磁盘块6、3、11和14。可以使用内存中的文件分配表（File Allocation Table, FAT）如下：</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.jpg" alt="文件分配表"></p>
<p>按这类方式组织，整个块都可以存放数据。进而，随机访问也容易得多。虽然仍要顺着链在文件中査找给定的偏移量，但是整个链都存放在内存中，所以不需要任何磁盘引用。与前面的方法相同，不管文件有多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。</p>
<p>这种方法的主要缺点是必须把整个表都存放在内存中，可能并不实用。</p>
<h3 id="i节点"><a href="#i节点" class="headerlink" title="i节点"></a>i节点</h3><p>最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为i节点的数据结构，其中列出了文件属性和文件块的磁盘地址。如下图：</p>
<p><img src="i%E8%8A%82%E7%82%B9.jpg" alt="i节点"></p>
<p>给定i节点，就能找到文件的所有块。相对于在内存中采用表的方式而言，这种机制具有很大的优势，即只有在对应文件打开时，其i节点才在内存中。</p>
<p>如果每个i节点只能存储固定数量的磁盘地址，那么当一个文件所含的磁盘块的数目超出了i节点所能容纳的数目时，一个解决方案是最后一个“磁盘地址”不指向数据块，而是指向一个包含额外磁盘块地址的块的地址，如上图所示。</p>
<p>更髙级的解决方案是：可以有两个或更多个包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。</p>
<h2 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h2><p>目录系统的主要功能是把ASCII文件名映射成定位文件数据所需的信息。与此密切相关的问题是在何处存放文件属性。每个文件系统维护诸如文件所有者以及创建时间等文件属性，它们必须存储在某个地方。</p>
<p>一种显而易见的方法是把文件属性直接存放在目录项中，很多系统确实是这样实现的。在这个简单设计中，目录中有一个固定大小的目录项列表，每个文件对应一项，其中包含一个（固定长度）文件名、一个文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址（至某个最大值）。</p>
<p>对于采用i节点的系统，还存在另一种更好的方法，即把文件属性存放在i节点中而不是目录项中。在这种情形下，目录项会更短：只有文件名和i节点号。</p>
<p>几乎所有的现代操作系统都支持可变长度的长文件名，有多种实现方式。</p>
<p>最简单的方法是给予文件名一个长度限制，典型值为255个字符，但是会浪费大量的空间。</p>
<p>一种替代方案是放弃“所有目录项大小一样”的想法。这种方法中，每个目录项有一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括所有者、创建时间、保护信息以及其他属性。这个固定长度的头的后面是一个任意长度的实际文件名，为了使每个目录项从字的边界开始，每个文件名被填充成整数个字。</p>
<p>这个方法的缺点是，当移走文件后，就引入了一个长度可变的空隙，而下一个进来的文件不一定正好适合这个空隙。这个问题与我们已经看到的连续磁盘文件的问题是一样的，由于整个目录在内存中，所以只有对目录进行紧凑操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页面上，在读取文件名时可能发生缺页中断。</p>
<p>处理可变长度文件名字的另一种方法是，使目录项自身都有固定长度，而将文件名放置在目录后面的堆中，这一方法的优点是，当一个文件目录项被移走后，另一个文件的目录项总是可以适合这个空隙。当然，必须要对堆进行管理，而在处理文件名时缺页中断仍旧会发生。另一个小优点是文件名不再需要从字的边界开始。</p>
<p>到目前为止，在需要査找文件名时，所有的方案都是线性地从头到尾对目录进行捜索。对于非常长的目录，线性査找就太慢了。加快査找速度的一个方法是在每个目录中使用散列表。使用散列表的优点是査找非常迅速。其缺点是需要复杂的管理。只有在预计系统中的目录经常会有成百上千个文件时，才把散列方案真正作为备用方案考虑。</p>
<p>一种完全不同的加快大型目录査找速度的方法是，将査找结果存入髙速缓存。在开始査找之前，先査看文件名是否在髙速缓存中。如果是，该文件可以立即定位。当然，只有在査询目标集中在相对小范围的文件集合的时候，髙速缓存的方案才有效果。</p>
<h2 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h2><p>存在共享文件的文件系统如下图：</p>
<p><img src="%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6.jpg" alt="共享文件"></p>
<p>C的一个文件现在也出现在B的目录下。B的目录与该共享文件的联系称为一个链接(link)。这样，文件系统本身是一个有向无环图(Directed Acyclic Graph，DAG)而不是一棵树。将文件系统组织成有向无环图使得维护复杂化，但也是必须付出的代价。</p>
<p>如果目录中包含磁盘地址，则当链接文件时，必须把C目录中的磁盘地址复制到B目录中。如果B或C随后又往该文件中添加内容，则新的数据块将只列入进行添加工作的用户的目录中。其他的用户对此改变是不知道的。所以违背了共享的目的。</p>
<p>第一种解决方案是，磁盘块不列入目录，而是列入一个与文件本身关联的小型数据结构中。目录将指向这个小型数据结构。这是UNIX系统中所采用的方法(小型数据结构即是i节点)。</p>
<p>第二种解决方案是，让系统建立一个类型为LINK的新文件，并把该文件放在B的目录下，使得B与C的一个文件存在链接。新的文件中只包含了它所链接的文件的路径名。当B读该链接文件时，操作系统査看到要读的文件是LINK类型，则找到该文件所链接的文件的名字，并且去读那个文件。与传统(硬)链接相对比起来，这一方法称为符号链接(symbolic linking)。</p>
<p>第一种方法中，当B链接到共享文件时，i节点记录文件的所有者是C。建立一个链接并不改变所有关系，但它将i节点的链接计数加1，所以系统知道目前有多少目录项指向这个文件。如果以后C试图删除这个文件，系统将面临问题。如果系统删除文件并清除i节点，B则有一个目录项指向一个无效的i节点。如果该i节点以后分配给另一个文件，则B的链接指向一个错误的文件。系统通过i节点中的计数可知该文件仍然被引用，但是没有办法找到指向该文件的全部目录项以刪除它们。指向目录的指针不能存储在i节点中，原因是有可能有无数个这样的目录。唯一能做的就是只删除C的目录项，但是将i节点保留下来，并将计数置为1，而现在的状况是，只有B有指向该文件的目录项，而该文件的所有者是C。如果系统进行记账或有配额，那么C将继续为该文件付账直到B决定删除它，如果真是这样，只有到计数变为0的时刻，才会刪除该文件。</p>
<p>对于符号链接，以上问题不会发生，因为只有真正的文件所有者才有一个指向i节点的指针。链接到该文件上的用户只有路径名，没有指向i节点的指针。当文件所有者删除文件时，该文件被销毁。以后若试图通过符号链接访问该文件将导致失败，因为系统不能找到该文件。删除符号链接根本不影响该文件。</p>
<p>符号链接的问题是需要额外的开销。必须读取包含路径的文件，然后要一个部分一个部分地扫描路径，直到找到i节点。这些操作也许需要很多次额外的磁盘访问。此外，每个符号链接都需要额外的i节点，以及额外的一个磁盘块用于存储路径，虽然如果路径名很短，作为一种优化，系统可以将它存储在i节点中。符号链接有一个优势，即只要简单地提供一个机器的网络地址以及文件在该机器上驻留的路径，就可以链接全球任何地方的机器上的文件。</p>
<p>还有另一个由链接带来的问题，在符号链接和其他方式中都存在。如果允许链接，文件有两个或多个路径。査找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的文件。例如，一个将某一目录及其子目录下的文件转储到磁带上的程序有可能多次复制一个被链接的文件。进而，如果接着把磁带读进另一台机器，除非转储程序具有智能，否则被链接的文件将被两次复制到磁盘上，而不是只是被链接起来。</p>
<h1 id="文件系统管理和优化"><a href="#文件系统管理和优化" class="headerlink" title="文件系统管理和优化"></a>文件系统管理和优化</h1><h2 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h2><p>几乎所有的文件系统都把文件分割成固定大小的块来存储，各块之间不一定相邻。</p>
<h3 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h3><h3 id="记录空闲块"><a href="#记录空闲块" class="headerlink" title="记录空闲块"></a>记录空闲块</h3><ul>
<li>磁盘块链表，链表的每个块中包含尽可能多的空闲磁盘块号。</li>
<li>位图，n个块的磁盘需要n位位图，空闲与否用二进制表示。</li>
</ul>
<h3 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h3><p>为了防止人们贪心而占有太多的磁盘空间，多用户操作系统常常提供一种强制性磁盘配额机制。其思想是系统管理员分给每个用户拥有文件和块的最大数量，操作系统确保每个用户不超过分给他们的配额。</p>
<h2 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h2><p>磁盘转储到磁带上有两种方案：物理转储和逻辑转储。</p>
<ul>
<li>物理转储是从磁盘的第0块开始，将全部的磁盘块按序输出到磁带上，直到最后一块复制完毕。</li>
<li>逻辑转储从一个或几个指定的目录开始，递归地转储其自给定基准日期。</li>
</ul>
<h2 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h2><p>影响文件系统可靠性的另一个问题是文件系统的一致性。很多文件系统读取磁盘块，进行修改后，再写回磁盘。如果在修改过的磁盘块全部写回之前系统崩溃，则文件系统有可能处于不一致状态。如果一些未被写回的块是i节点块、目录块或者是包含有空闲表的块时，这个问题尤为严重。</p>
<p>为了解决文件系统的不一致问题，很多计算机都带有一个实用程序以检验文件系统的一致性。例如，UNIX有fsck，而Windows用scandisk。系统启动时，特别是崩溃之后的重新启动，可以运行该实用程序。</p>
<p>下面介绍一下UNIX下fsck的用法。</p>
<p>一致性检査分为两种：块的一致性检査和文件的一致性检査。在检査块的一致性时，程序构造两张表，每张表中为每个块设立一个计数器，都初始化为0。第一个表中的计数器跟踪该块在文件中的出现次数，第二个表中的计数器跟踪该块在空闲表或空闲位图中的出现次数。</p>
<p>接着检验程序使用原始设备读取全部的i节点，忽略文件的结构，只返回从零开始的所有磁盘块。由i节点开始，可以建立相应文件中用到的全部块的块号表。每当读到一个块号时，该块在第一个表中的计数器加1。然后，该程序检查空闲表或位图，査找全部未使用的块。每当在空闲表中找到一个块时，就会使它在第二个表中的相应计数器加1。</p>
<p><img src="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="文件系统一致性"></p>
<p>如果文件系统一致，则每一块或者在第一个表计数器中为1，或者在第二个表计数器中为1，如图a所示。</p>
<p>但是当系统崩溃后，这两张表可能如图b所示，其中，磁盘块2没有出现在任何一张表中，这称为块丢失。尽管块丢失不会造成实际的损害，但它的确浪费了磁盘空间，减少了磁盘容量。块丢失问题的解决很容易：文件系统检验程序把它们加到空闲表中即可。</p>
<p>有可能出现的另一种情况如图c所示。其中，块4在空闲表中出现了2次（只在空闲表是真正意义上的一张表时，才会出现重复，在位图中，不会发生这类情况）。解决方法也很简单：只要重新建立空闲表即可。</p>
<p>最糟的情况是，在两个或多个文件中出现同一个数据块，如图d中的块5。如果其中一个文件被删除，块5会添加到空闲表中，导致一个块同时处于使用和空闲两种状态。若删除这两个文件，那么在空闲表中这个磁盘块会出现两次。文件系统检验程序可以采取相应的处理方法是，先分配一空闲块，把块5中的内容复制到空闲块中，然后把它插到其中一个文件之中。这样文件的内容未改变（虽然这些内容几乎可以肯定是不对的），但至少保持了文件系统的一致性。这一错误应该报告，由用户检査文件受损情况。</p>
<p>除检査每个磁盘块计数的正确性之外，文件系统检验程序还检査目录系统。此时也要用到一张计数器表，但这时是一个文件（而不是一个块）对应于一个计数器。程序从根目录开始检验，沿着目录树递归下降，检查文件系统中的每个目录。对每个目录中的每个文件，将文件使用计数器加1。要注意，由于存在硬链接，一个文件可能出现在两个或多个目录中。而遇到符号链接是不计数的，不会对目标文件的计数器加1。</p>
<p>在检验程序全部完成后，得到一张由i节点号索引的表，说明每个文件被多少个目录包含。然后，检验程序将这些数字与存储在文件i节点中的链接数目相比较。当文件创建时，这些计数器从1开始，随着每次对文件的一个（硬）链接的产生，对应计数器加1。如果文件系统一致，这两个计数应相等。但是，有可能出现两种错误，即i节点中的链接计数太大或者太小。</p>
<p>如果i节点的链接计数大于目录项个数，这时即使所有的文件都从目录中删除，这个计数仍是非0，i节点不会被删除。该错误并不严重，却因为存在不属于任何目录的文件而浪费了磁盘空间。为改正这一错误，可以把i节点中的链接计数设成正确值。</p>
<p>另一种错误则是潜在的灾难。如果同一个文件链接两个目录项，但其i节点链接计数只为1，如果删除了任何一个目录项，对应i节点链接计数变为0。当i节点计数为0时，文件系统标志该i节点为“未使用”，并释放其全部块。这会导致其中一个目录指向一未使用的i节点，而很有可能其块马上就被分配给其他文件。解决方法同样是把i节点中链接计数设为目录项的实际个数值。</p>
<h2 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h2><p>访问磁盘比访问内存慢得多，考虑到访问时间的这个差异，许多文件系统采用了各种优化措施以改善性能。</p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>管理髙速缓存有不同的算法，常用的算法是：检査全部的读请求，査看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果该块不在髙速缓存中，首先要把它读到高速缓存，再复制到所需地方。之后，对同一个块的请求都通过髙速缓存完成。</p>
<p>由于在高速缓存中有许多块，通常通过散列表查找，相同散列值的块在一个链表中连接在一起。置换高速缓存的方法与页表置换的算法类似。</p>
<h3 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h3><p>在需要用到块之前，试图提前将其写入高速缓存，从而提髙命中率。块提前读策略只适用于实际顺序读取的文件。对随机访问文件，提前读丝毫不起作用。相反，它还会帮倒忙，因为读取无用的块以及从高速缓存中删除潜在有用的块将会占用固定的磁盘带宽（如果有“脏”块的话，还需要将它们写回磁盘，这就占用了更多的磁盘带宽）。</p>
<p>文件系统通过跟踪每一个打开文件的访问方式来确定这一点。例如，可以使用与文件相关联的某个位协助跟踪该文件到底是“顺序访问方式”还是“随机访问方式”。在最初不能确定文件属于哪种存取方式时，先将该位设置成顺序访问方式。但是，査找一完成，就将该位清除。如果再次发生顺序读取，就再次设置该位。这样，文件系统可以通过合理的猜测，确定是否应该采取提前读的策略。即便弄错了一次也不会产生严重后果，不过是浪费一小段磁盘的带宽罢了。</p>
<h3 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h3><p>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻着的空闲块就困难得多。</p>
<p>不过，即使采用空闲表，也可以采用块簇技术。这里用到一个小技巧，即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有512个字节，有可能系统采用1KB的块（2个扇区），但却按每2块（4个扇区）一个单位来分配磁盘存储区。这和2KB的磁盘块并不相同，因为在高速缓存中它依然使用1KB的块，磁盘与内存数据之间传送也是以1KB为单位进行，但在一个空闲的系统上顺序读取文件，寻道的次数可以减少一半，从而使文件系统的性能大大改善。</p>
<p>在使用i节点或任何类似i节点的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：一次是访问i节点，另一次是访问块。</p>
<p>一个简单的改进方法是，在磁盘中部而不是开始处存放i节点，此时，在i节点和第一块之间的平均寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的i节点、数据块和空闲表。在文件创建时，可选取任一i节点，但选定之后，首先在该i节点所在的柱面组上査找块。如果在该柱面组中没有空闲的块，就选用与之相邻的柱面组的一个块。</p>
<p>当然，仅当磁盘中装有磁盘臂的时候，讨论寻道时间和旋转时间才是有意义的。越来越多的电脑开始装配不带移动部件的固态硬盘（SSD）。对于这些硬盘，由于采用了和闪存同样的制造技术，使得随机访问与顺序访问在传输速度上已经较为相近，传统硬盘的许多问题就消失了。不幸的是，新的问题又随之出现。例如，固态硬盘在读取、写入和删除时表现出一些特性，尤其是每一块只可写入有限次数的特征，导致使用时需要十分小心以达到均匀分散磨损的目的。</p>
<h2 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h2><p>磁盘性能可以通过如下方式恢复：移动文件使它们相邻，并把所有的（至少是大部分的）空闲空间放在一个或多个大的连续的区域内。</p>
<p>Windows有一个程序defrag就是从事这个工作的。Windows的用户应该定期使用它，当然，SSD盘除外。</p>
<p>Linux文件系统（特别是ext2和ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会遭受像Windows那样的困难，因此很少需要手动的磁盘碎片整理。</p>
<p>固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提髙性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p>
<h1 id="I-O硬件原理"><a href="#I-O硬件原理" class="headerlink" title="I/O硬件原理"></a>I/O硬件原理</h1><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p>I/O设备大致可以分为两类：块设备（block device）和字符设备（character device）。</p>
<ul>
<li>块设备把信息存储在固定大小的块中，每个块有自己的地址。通常块的大小在512字节至65536字节之间。所有传输以一个或多个完整的（连续的〉块为单位。块设备的基本特征是每个块都能独立于其他块而读写。硬盘、蓝光光盘和USB盘是最常见的块设备。</li>
<li>字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。打印机、网络接口、鼠标（用作指点设备）以及大多数与磁盘不同的设备都可看作字符设备。</li>
</ul>
<p>I/O设备一般由机械部件和电子部件两部分组成，机械部件是设备本身，电子部件称作设备控制器(device controller)或适配器(adapter)。通常可以将这两部分分开处理，以提供更加模块化和更加通用的设计。</p>
<h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>在个人计算机上，设备控制器经常以主板上的芯片的形式出现，或者以插入(PCI)扩展槽中的印刷电路板的形式出现。如果控制器和设备之间采用的是标准接口，各个公司都可以制造各种适合这个接口的控制器或设备。</p>
<h2 id="内存映射I-O"><a href="#内存映射I-O" class="headerlink" title="内存映射I/O"></a>内存映射I/O</h2><p>每个控制器有几个寄存器用来与CPU进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。</p>
<p>除了这些控制寄存器以外，许多设备还有一个操作系统可以读写的数据缓冲区。例如，在屏幕上显示像素的常规方法是使用一个视频RAM，这一RAM基本上只是一个数据缓冲区，可供程序或操作系统写入数据。</p>
<p>CPU如何与设备的控制寄存器和数据缓冲区进行通信？</p>
<ol>
<li>每个控制寄存器被分配一个I/O端口 (I/O port)号，这是一个8位或16位的整数。所有I/O端口形成I/O端口空间(I/O port space)，并且受到保护使得普通的用户程序不能对其进行访问(只有操作系统可以访问)。</li>
<li>将所有控制寄存器映射到内存空间中，每个控制寄存器被分配唯一的一个内存地址，并且不会有内存被分配这一地址。这样的系统称为内存映射I/O（memory-mapped I/O）。</li>
</ol>
<h2 id="直接存储器存取"><a href="#直接存储器存取" class="headerlink" title="直接存储器存取"></a>直接存储器存取</h2><p>无论一个CPU是否具有内存映射1/0，它都需要寻址设备控制器以便与它们交换数据。CPU可以从I/O控制器每次请求一个字节的数据，但是这样做浪费CPU的时间，所以经常用到一种称为直接存储器存取（Direct Memory Access, DMA）的不同方案。</p>
<p>为简化解释，假设CPU通过单一的系统总线访问所有的设备和内存，该总线连接CPU、内存和I/O设备，如图所示。只有硬件具有DMA控制器时操作系统才能使用DMA，而大多数系统都有DMA控制器，更加普遍的是，只有一个DMA控制器可利用（例如，在主板上），由它调控到多个设备的数据传送，而这些数据传送经常是同时发生的。</p>
<p>无论DMA控制器在物理上处于什么地方，它都能够独立于CPU而访问系统总线。它包含若干个可以被CPU读写的寄存器，其中包括一个内存地址寄存器、一个字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的I/O端口、传送方向（从I/O设备读或写到I/O设备）、传送单位（毎次一个字节或每次一个字）以及在一次突发传送中要传送的字节数。</p>
<p>为了解释DMA的工作原理，首先看一下没有使用DMA时磁盘如何读。首先，控制器从磁盘驱动器串行地、一位一位地读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区中。接着，它计算校验和，以保证没有读错误发生。然后控制器产生一个中断。当操作系统开始运行时，它重复地从控制器的缓冲区中一次一个字节或一个字地读取该块的信息，并将其存人内存中。</p>
<p><img src="DMA.jpg" alt="DMA"></p>
<p>使用DMA时，过程是不同的。首先，CPU通过设置DMA控制器的寄存器对它进行编程，所以DMA控制器知道将什么数据传送到什么地方（图中的第1步）。DMA控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区中，并且对校验和进行检验。如果磁盘控制器的缓冲区中的数据是有效的，那么DMA就可以开始了。</p>
<p>DMA控制器通过在总线上发出一个读请求到磁盘控制器而发起DMA传送（第2步）。这一读请求看起来与任何其他读请求是一样的，并且磁盘控制器并不知道或者并不关心它是来自CPU还是来自DMA控制器。一般情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器从其内部缓冲区中读取下一个字的时候，它知道将该字写到什么地方。写到内存是另一个标准总线周期（第3步）。当写操作完成时，磁盘控制器在总线上发出一个应答信号到DMA控制器（第4步）。于是，DMA控制器步增要使用的内存地址，并且步减字节计数。如果字节计数仍然大于0，则重复第2步到第4步，直到字节计数到达0。此时，DMA控制器将中断CPU以便让CPU知道传送现在已经完成了。当操作系统幵始工作时，用不着将磁盘块复制到内存中，因为它已经在内存中了。</p>
<h1 id="I-O软件原理"><a href="#I-O软件原理" class="headerlink" title="I/O软件原理"></a>I/O软件原理</h1><h2 id="I-O软件的目标"><a href="#I-O软件的目标" class="headerlink" title="I/O软件的目标"></a>I/O软件的目标</h2><p>在设计I/O软件时一个关键的概念是设备独立性（device independence）。即程序可以访问任意I/O设备而无需事先指定设备。与设备独立性密切相关的是统一命名，一个文件或一个设备的名字不应依赖于设备。在UNIX系统中，所有存储盘都能以任意方式集成到（mount）文件系统层次结构中，因此，用户不必知道哪个名字对应于哪台设备。</p>
<p>I/O软件的另一个重要问题是错误处理（error handling）。一般来说，错误应该尽可能地在接近硬件的层面得到处理。</p>
<p>另一个关键问题是同步（synchronous：即阻塞）和异步（asynchronous：即中断驱动）传输。大多数物理I/O是异步的——CPU启动传输后便转去做其他工作，直到中断发生。</p>
<p>I/O软件的另一个问题是缓冲（buffering），数据离开一个设备之后通常并不能直接存放到其最终的目的地。</p>
<p>最后一个是共享设备和独占设备的问题。</p>
<h2 id="程序控制I-O"><a href="#程序控制I-O" class="headerlink" title="程序控制I/O"></a>程序控制I/O</h2><p>I/O的最简单形式是让CPU做全部工作，这一方法称为程序控制I/O（programmed I/O）。考虑一个用户进程，该进程想通过串行接口在打印机上打印8个字符的字符串“ABCDEFGH”。</p>
<p>软件首先要在用户空间的一个缓冲区中组装字符串，然后，用户进程通过发出打开打印机一类的系统调用来获得打印机以便进行写操作。如果打印机当前被另一个进程占用，该系统调用将失败并返回一个错误代码，或者将阻塞直到打印机可用，一旦拥有打印机，用户进程就发出一个系统调用通知操作系统在打印机上打印字符串。</p>
<p>然后，操作系统（通常）将字符串缓冲区复制到内核空间中的一个数组（在这里访问更容易，因为内核可能必须修改内存映射才能到达用户空间）。一旦打印机可用，操作系统就复制第一个字符到打印机的数据寄存器中，在这个例子中使用了内存映射I/O。</p>
<p>在第一个字符打印出来后，系统已经将“B”标记为下一个待打印的字符。一旦将第一个字符复制到打印机，操作系统就要査看打印机是否就绪准备接收另一个字符。一般而言，打印机都有第二个寄存器，用于表明其状态。将字符写到数据寄存器的操作将导致状态变为非就绪。当打印机控制器处理完当前字符时，它就通过在其状态寄存器中设置某一位或者将某个值放到状态寄存器中来表示其可用性。这时，操作系统将等待打印机状态再次变为就绪。打印机就绪事件发生时，操作系统就打印下一个字符。这一循环继续进行，直到整个字符串打印完。然后，控制返回到用户进程。</p>
<p>程序控制I/O十分简单但是有缺点，即直到全部I/O完成之前要占用CPU的全部时间。</p>
<h2 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h2><p>现在我们考虑在不缓冲字符而是在每个字符到来时便打印的打印机上进行打印的情形，允许CPU在等待打印机变为就绪的同时做某些其他事情的方式就是使用中断。</p>
<p>当打印字符串的系统调用被发出时，字符串缓冲区被复制到内核空间，并且一旦打印机准备好接收一个字符时就将第一个字符复制到打印机中。这时，CPU要调用调度程序，并且某个其他进程将运行。请求打印字符串的进程将被阻塞，直到整个字符串打印完。</p>
<p>当打印机将字符打印完并且准备好接收下一个字符时，它将产生一个中断。这一中断将停止当前进程并且保存其状态。然后，打印机中断服务过程将运行。</p>
<h2 id="使用DMA的I-O"><a href="#使用DMA的I-O" class="headerlink" title="使用DMA的I/O"></a>使用DMA的I/O</h2><p>中断驱动I/O的一个明显缺点是中断发生在每个字符上。中断要花费时间，所以这一方法将浪费一定数量的CPU时间。这一问题的一种解决方法是使用DMA。</p>
<p>此处的思路是让DMA控制器一次给打印机提供一个字符，而不必打扰CPU。本质上，DMA是程序控制I/O，只是由DMA控制器而不是主CPU做全部工作。这一策略需要特殊的硬件（DMA控制器），但是使CPU获得自由从而可以在I/O期间做其他工作。</p>
<p>DMA重大的成功是将中断的次数从打印每个字符一次减少到打印每个缓冲区一次。如果有许多字符并且中断十分缓慢，那么采用DMA可能是重要的改进。另一方面，DMA控制器通常比主CPU要慢很多。如果DMA控制器不能以全速驱动设备，或者CPU在等待DMA中断的同时没有其他事情要做，那么采用中断驱动I/O甚至采用程序控制I/O也许更好。</p>
<h1 id="I-O软件层次"><a href="#I-O软件层次" class="headerlink" title="I/O软件层次"></a>I/O软件层次</h1><ul>
<li>硬件</li>
<li>中断处理程序</li>
<li>设备驱动程序</li>
<li>与设备无关的操作系统软件</li>
<li>用户级I/O软件</li>
</ul>
<h1 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h1><p>ioctl是设备驱动程序中对设备的I/O通道进行管理的函数，即对设备的一些特性进行控制，例如串口的传输波特率等。其函数原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, ...)；</span><br></pre></td></tr></table></figure>

<ul>
<li>fd：用户程序打开设备时使用open函数返回的文件描述符</li>
<li>cmd：用户程序对设备的控制命令</li>
<li>data：一些补充参数，和cmd的意义相关</li>
</ul>
<p>ioctl函数是文件结构中的一个属性分量，也就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I/O通道。</p>
<p>如果不用ioctl的话，也可以实现对设备I/O通道的控制，但很麻烦。例如，我们可以在驱动程序中实现write的时候检查一下是否有特殊约定的数据流通过，如果有的话，那么后面就跟着控制命令。如果这样做的话，会导致代码分工不明，程序结构混乱。所以才使用ioctl来实现控制的功能。用户程序所做的只是通过命令码告诉驱动程序它想做什么，至于怎么解释这些命令和怎么实现这些命令，这都是驱动程序要做的事情。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统-内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-03 20:19:20" itemprop="dateCreated datePublished" datetime="2019-12-03T20:19:20+08:00">2019-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2019/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统-内存管理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>操作系统中管理分层存储器体系的部分称为存储管理器（memory manager）。它的任务是有效地管理内存，即记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。</p>
<p>这里会研究几个不同的存储管理方案。</p>
<h1 id="无存储器抽象"><a href="#无存储器抽象" class="headerlink" title="无存储器抽象"></a>无存储器抽象</h1><p>最简单的存储器抽象就是根本没有抽象，每一个程序都直接访问物理内存。</p>
<h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>要使多个应用程序同时处于内存中并且不互相影响，需要解决两个问题：保护和重定位。不太好的解决方式：</p>
<ul>
<li>给内存块标记上一个保护键，并且比较执行进程的键和其访问的每个内存字的保护键。</li>
<li>在程序被装载时重定位程序，这是一个缓慢且复杂的解决方法。</li>
</ul>
<p>一个更好的办法是创造一个新的存储器抽象：地址空间。地址空间为程序创造了一种抽象的内存，它是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。</p>
<p>比较难的是给每个程序一个自己独有的地址空间，使得一个程序中的地址28所对应的物理地址与另一个程序中的地址28所对应的物理地址不同。有一种比较简单的方法是：<strong>基址寄存器与界限寄存器</strong>。</p>
<p>这个简单的解决办法是使用动态重定位，简单地把每个进程的地址空间映射到物理内存的不同部分。当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空闲位置且装载期间无须重定位，当一个进程运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。</p>
<p>每次一个进程访问内存，取一条指令，读或写一个数据字，CPU硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上。同时，它检査程序提供的地址是否等于或大于界限寄存器里的值。如果访问的地址超过了界限，会产生错误并中止访问。</p>
<p>使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算。比较运算可以做得很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。</p>
<p>实际上，所有进程所需的RAM数量总和通常要远远超出存储器能够支持的范围，有两种处理内存超载的通用方法：</p>
<ul>
<li><strong>交换技术</strong>，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。空闲进程主要存储在磁盘上，所以当它们不运行时就不会占用内存</li>
<li><strong>虚拟内存</strong>，该策略甚至能使程序在只有一部分被调入内存的情况下运行</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>交换技术的操作如下图所示：</p>
<p><img src="%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF.jpg" alt="交换技术"></p>
<p>开始时内存中只有进程A。之后创建进程B和C或者从磁盘将它们换入内存。图d显示A被交换到磁盘。然后D被调入，B被调出，最后A再次被调入。由于A的位置发生变化，所以在它换入的时候通过软件或者在程序运行期间(多数是这种情况)通过硬件对其地址进行重定位。例如，基址寄存器和界限寄存器就适用于这种情况。</p>
<p>交换在内存中产生了多个空闲区(hole,也称为空洞)，通过把所有的进程尽可能向下移动，有可能将这些小的空闲区合成一大块。该技术称为内存紧缩(memory compaction)，通常不进行这个操作，因为它要耗费大量的CPU时间。例如，一台有16GB内存的计算机可以每8ns复制8个字节，它紧缩全部内存大约要花费16s。</p>
<p>如果进程的数据段可以增长，例如，很多程序设计语言都允许从堆中动态地分配内存，那么当进程空间试图增长时，就会出现问题。若进程与一个全闲区相邻，那么可把该空闲区分配给进程供其增大。另一方面，若进程相邻的是另一个进程，那么要么把需要增长的进程移到内存中一个足够大的区域中去，要么把一个或多个进程交换出去，以便生成一个足够大的空闲区。若一个进程在内存中不能增长，而且磁盘上的交换区也已满了，那么这个进程只有挂起直到一些空间空闲(或者可以结束该进程)。</p>
<p>如果大部分进程在运行时都要增长，为了减少因内存区域不够而引起的进程交换和移动所产生的开销，一种可用的方法是，当换入或移动进程时为它分配一些额外的内存。然而，当进程被换出到磁盘上时，应该只交换进程实际上使用的内存中的内容，将额外的内存交换出去是一种浪费。</p>
<p>如果进程有两个可增长的段，例如，供变量动态分配和释放的作为堆使用的一个数据段，以及存放普通局部变量与返回地址的一个堆栈段，则可使用另一种安排：进程的堆栈段在进程所占内存的顶端并向下增长，紧接在程序段后面的数据段向上增长。在这两者之间的内存可以供两个段使用。如果用完了，进程或者必须移动到足够大的空闲区中（它可以被交换出内存直到内存中有足够的空间），或者结束该进程。</p>
<h2 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h2><p>在动态分配内存时，操作系统必须对其进行管理。一般而言，有两种方法跟踪内存使用情况：</p>
<ul>
<li>位图</li>
<li>空闲区链表</li>
</ul>
<p>如下图所示：</p>
<p><img src="%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.jpg" alt="空闲内存管理"></p>
<h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>使用位图方法时，内存可能被划分成小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。</p>
<p>分配单元的大小是一个重要的设计因素。分配单元越小，位图越大。若进程的大小不是分配单元的整数倍，那么在最后一个分配单元中就会有一定数量的内存被浪费了。</p>
<p>在决定把一个占n个分配单元的进程调入内存时，存储管理器必须捜索位图，在位图中找出有n个连续0的串。査找位图中指定长度的连续0串是耗时的操作（因为在位图中该串可能跨越字的边界），这是位图的缺点。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表。其中链表中的一个结点或者包含一个进程，或者是两个进程间的一块空闲区。</p>
<p>进程表中表示终止进程的结点中通常含有指向对应于其段链表结点的指针，因此段链表使用双向链表可能要比单向链表更方便。这样的结构更易于找到上一个结点，并检査是否可以合并。</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>程序大于内存的问题早在计算时代伊始就产生了，虽然存储器容量增长快速，但是软件大小的增长更快。这一发展的结果是，需要运行的程序往往大到内存无法容纳，而且必然需要系统能够支持多个程序同时运行，它们很容易超出了内存大小。交换技术并不是一个具有吸引力的解决方案，因为一个典型SATA磁盘的峰值传输率髙达每秒好几百兆，这意味着需要好几秒才能换出或换入一个1GB的程序。</p>
<p>虚拟内存的基本思想是：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一块称作一页（page），毎一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从某个角度来讲，虚拟内存是对基址寄存器和界限寄存器的一种综合。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>大部分虚拟内存系统中都使用一种称为分页(paging)的技术，当程序执行指令<code>MOV REG, 1000</code>时，它把地址为1000的内存单元的内容复制到REG中(或者相反)。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<p>由程序产生的这些地址称为<strong>虚拟地址(virtual address)**，它们构成了一个</strong>虚拟地址空间(virtual address space)<strong>。在没有</strong>虚拟内存<strong>的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到</strong>内存管理单元(Memory Management Unit，MMU)**, MMU把虚拟地址映射为物理内存地址。</p>
<p>举例如下：</p>
<p><img src="%E5%88%86%E9%A1%B5.jpg" alt="分页"></p>
<p>在这个例子中，有一台可以产生16位地址的计算机，地址范围从0到64K-1,且这些地址是虚拟地址。然而，这台计算机只有32KB的物理内存，因此，虽然可以编写64KB的程序，但它们却不能被完全调人内存运行。在磁盘上必须有一个最多64KB的程序核心映像的完整副本，以保证程序片段在需要时能被调入内存。</p>
<p>虚拟地址空间按照固定大小划分成被称为<strong>页面(page)**的若干单元。在物理内存中对应的单元称为</strong>页框(page frame)**。页面和页框的大小通常是一样的，在本例中是4KB。</p>
<p>当程序试图访问地址0时，将虚拟地址0送到MMU。MMU看到虚拟地址落在页面0(0~4095)，根据其映射结果，这一页面对应的是页框2 (8192〜12287)，因此MMU把地址变换为8192，并把地址8192送到总线上。内存对MMU无所知，它只看到一个读或写地址8192的请求并执行它。MMU从而有效地把所有从0〜4095的虚拟地址映射到了8192-12287的物理地址。</p>
<p>当程序访问了一个未映射的页面，例如访问地址32780：MMU注意到该页面没有被映射(在图中用叉号表示)，于是使CPU陷入到操作系统，这个陷阱称为**缺页中断或缺页错误(page fault)**。操作系统找到一个很少使用的页框且把它的内容写入磁盘(如果它不在磁盘上)。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表的目的是把虚拟页面映射为页框。作为一种最简单的实现，虚拟地址到物理地址的映射可以槪括如下：虚拟地址被分成<strong>虚拟页号</strong>（髙位部分）和<strong>偏移量</strong>（低位部分）两部分。例如，对于16位地址和4KB的页面大小，髙4位可以指定16个虚拟页面中的一页，而低12位接着确定了所选页面中的字节偏移量（0~4095）。</p>
<p>虚拟页号可用作页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的髙位端，以替换掉虚拟页号，形成送往内存的物理地址。</p>
<p>—个典型的页表项：<code>[Data][髙速缓存禁止位][访问位保护位][修改位][“在/不在”位][页框号]</code>。</p>
<ul>
<li>页框号：通过它找到真正的物理地址</li>
<li>“在/不在”位：表示该表项对应的虚拟页面在不在内存中，访问该页面是否会引起缺页中断</li>
<li>保护位：指出一个页允许什么类型的访问，是否启用读、写、执行该页面。</li>
<li>修改（modified）位和访问（referenced）位：在写入一页时由硬件自动设置修改位。该位在操作系统重新分配页框时是非常有用的。如果一个页面已经被修改过，则必须把它写回磁盘。如果一个页面没有被修改过，则只简单地把它丢弃就可以了，因为它在磁盘上的副本仍然是有效的。这一位有时也被称为脏位（dirty bit），因为它反映了该页面的状态。</li>
<li>高速缓存禁止位：用于禁止该页面被髙速缓存。对那些映射到设备寄存器而不是常规内存的页面而言，这个特性是非常重要的。假如操作系统正在紧张地循环等待某个I/O设备对它刚发出的命令作出响应，保证硬件是不断地从设备中读取数据而不是访问一个旧的被髙速缓存的副本是非常重要的。</li>
</ul>
<p>应该注意的是，若某个页面不在内存中，用于保存该页面的磁盘地址不是页表的组成部分。原因很简单，页表只保存把虚拟地址转换为物理地址时硬件所需要的信息。操作系统在处理缺页中断时需要把该页面的磁盘地址等信息保存在操作系统内部的软件表格中。硬件不需要它。</p>
<p>虚拟内存本质上是用来创造一个新的抽象槪念——地址空间，这个槪念是对物理内存的抽象，类似于进程是对物理处理器（CPU）的抽象。虚拟内存的实现，是将虚拟地址空间分解成页，并将每一页映射到物理内存的某个页框或者（暂时）解除映射。</p>
<p>在任何分页系统中，都需要考虑两个主要问题：</p>
<ol>
<li>虚拟地址到物理地址的映射必须非常快。</li>
<li>如果虚拟地址空间很大，页表也会很大。</li>
</ol>
<h2 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h2><h3 id="转换检测缓冲区"><a href="#转换检测缓冲区" class="headerlink" title="转换检测缓冲区"></a>转换检测缓冲区</h3><p>为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备称为转换检测缓冲区（Translation Lookaside Buffer, TLB）,有时又称为相联存储器（associate memory）或快表。</p>
<p>这种解决方案的建立基干这样一种观察：大多数程序总是对少量的页面进行多次的访问，而不是相反。因此，只有很少的页表项会被反复读取，而其他的页表项很少被访问。</p>
<p>它通常在MMU中，包含少量的表项，每个表项记录了一个页面的相关信息，包括虚拟页号、页面的修改位、保护码（读/写/执行权限）和该页所对应的物理页框。除了虚拟页号（不是必须放在页表中），这些域与页表中的域是一一对应的。另外还有一位用来记录这个表项是否有效（即是否在使用）。</p>
<h3 id="软件TLB管理"><a href="#软件TLB管理" class="headerlink" title="软件TLB管理"></a>软件TLB管理</h3><p>在过去，对TLB的管理和TLB的失效处理都完全由MMU硬件来实现，只有在内存中没有找到某个页面时，才会陷入到操作系统中。但是，许多现代的机器几乎所有的页面管理都是在软件中实现的，在这些机器上，TLB表项被操作系统显式地装载。当发生TLB访问失效时，不再是由MMU到页表中査找并取出需要的页表项，而是生成一个TLB失效并将问题交给操作系统解决。系统必须先找到该页面，然后从TLB中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。当然，所有这一切都必须在有限的几条指令中完成，因为TLB失效比缺页中断发生得更加频繁。</p>
<p>如果TLB大到（如64个表项）可以减少失效率时，TLB的软件管理就会变得足 够有效。这种方法的最主要的好处是获得了一个非常简单的MMU,这就在CPU芯片上为髙速缓存以及 其他改善性能的设计腾出了相当大的空间。</p>
<h2 id="大内存页表"><a href="#大内存页表" class="headerlink" title="大内存页表"></a>大内存页表</h2><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>一个二多级页表如下所示：</p>
<p><img src="%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.jpg" alt="多级页表"></p>
<p>考虑32位虚拟地址0x00403004，它的虚拟地址对应PT1 = 1，PT2 = 3, Offset = 4。MMU首先用PT1作为索引访问顶级页表得到表项1，它对应的地址范围是4M到8M-1。然后，它用PT2作为索引访问刚刚找到的二级页表并得到表项3，它对应的虚拟地址范围是在它的4M块内的12288〜16383（即绝对地址4206592-4 210687）。这个表项含有虚拟地址0x00403004所在页面的页框号。如果该页面不在内存中，页表项中的“在/不在”位将是0，引发一次缺页中断。如果该页面在内存中，从二级页表中得到的页框号将与偏移量（4）结合形成物理地址。该地址被放到总线上并送到内存中。</p>
<h3 id="倒排页表"><a href="#倒排页表" class="headerlink" title="倒排页表"></a>倒排页表</h3><p>当虚拟地址空间比物理内存大得多的时候，倒排页表节省了大量的空间，但是从虚拟地址到物理地址的转换会变得很困难。</p>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>“页面置换”问题在计算机设计的其他领域中也同样会发生。例如高速缓存的更换等。</p>
<p>若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了<strong>颠簸</strong>。</p>
<h2 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h2><p>该算法是这样工作的：在缺页中断发生时，有些页面在内存中，其中有一个页面（包含紧接着的下一条指令的那个页面）将很快被访问，其他页面则可能要到10、100或1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记。</p>
<p>这个算法唯一的问题就是它是无法实现的。</p>
<h2 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h2><p>为使操作系统能够收集有用的统计信息，在大部分具有虚拟内存的计算机中，系统为每一页面设置了两个状态位。当页面被访问（读或写）时设置R位：当页面被写入（即修改）时设置M位。这些位包含在每个页表项中，每次访问内存时更新这些位，因此由硬件来设置它们是必要的。一旦设置某位为1，它就一直保持1直到操作系统将它复位。</p>
<p>当启动一个进程时，它的所有页面的两个位都由操作系统设置成0, R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。当发生缺页中断时，操作系统检査所有的页面并根据它们当前的R位和M位的值，把它们分为4类：</p>
<ul>
<li>第0类：没有被访问，没有被修改</li>
<li>第1类：没有被访问，已被修改</li>
<li>第2类：已被访问，没有被修改</li>
<li>第3类：已被访问，已被修改</li>
</ul>
<p>NRU（Not Recently Used，最近未使用）算法随机地从类编号最小的非空类中挑选一个页面淘汰。这个算法隐含的意思是，在最近一个时钟滴答中（典型的时间是大约20ms）淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的“干净”页面好。NRU的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。</p>
<h2 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h2><p>另一种开销较小的页面置换算法是FIFO（First-In First-Out，先进先出）算法。由操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头。当发生缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。</p>
<h2 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h2><p>FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：检査最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉：如果是1，就将R位清0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续捜索。这一算法称为第二次机会（second chance）算法。</p>
<h2 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h2><p>尽管第二次机会算法是一个比较合理的算法，但它经常要在链表中移动页面，既降低了效率又不是很有必要。一个更好的办法是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。当发生缺页中断时，算法首先检査表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置：如果R位是1就清除R位并把表针前移一个位置。重复这个过程直到找到了一个R位为0的页面为止。</p>
<h2 id="最近最少使用页面置换算法"><a href="#最近最少使用页面置换算法" class="headerlink" title="最近最少使用页面置换算法"></a>最近最少使用页面置换算法</h2><p>最近最少使用页面置换算法（LRU）在理论上是可以实现的，但代价很髙。为了完全实现LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作，即使使用硬件实现也一样费时（假设有这样的硬件）。</p>
<p>然而，还是有一些使用特殊硬件实现LRU的方法。首先考虑一个最简单的方法，这个方法要求硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检査所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面。</p>
<h2 id="最不常用页面置换算法"><a href="#最不常用页面置换算法" class="headerlink" title="最不常用页面置换算法"></a>最不常用页面置换算法</h2><p>前面一种LRU算法虽然在理论上是可以实现的，但只有非常少的计算机拥有这种硬件。因此，需要一个能用软件实现的解决方案。一种可能的方案称为NFU（Not Frequently Used，最不常用）算法。该算法将每个页面与一个软件计数器相关联，计数器的初值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它的值是0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。</p>
<h2 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h2><p>在单纯的分页系统里，刚启动进程时，在内存中并没有页面。在CPU试图取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面。其他由访问全局数据和堆栈引起的缺页中断通常会紧接着发生。一段时间以后，进程需要的大部分页面都已经在内存了，进程开始在较少缺页中断的情况下运行。这个策略称为请求调页(demand paging)，因为页面是在需要时被调入的，而不是预先装入。</p>
<p>大部分进程都表现出一种局部性访问行为，即在进程运行的任何阶段，它都只访问较少的一部分页面。一个进程当前正在使用的页面的集合称为它的工作集，如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段(例如，编译器的下一遍扫描)之前，不会产生很多缺页中断。</p>
<p>所以不少分页系统都会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了。该方法称为工作集模型。在进程运行前预先装入其工作集页面也称为预先调页(prepaging)。</p>
<p>为了实现工作集模型，操作系统必须跟踪哪些页面在工作集中。通过这些信息可以直接推导出一个合理的页面置换算法：当发生缺页中断时，淘汰一个不在工作集中的页面。为了实现该算法，就需要一种精确的方法来确定哪些页面在工作集中。根据定义，工作集就是最近A次内存访问所使用过的页面的集合。</p>
<p>一种常见的近似方法就是，不是向后找最近A次的内存访问，而是考虑其执行时间。一个进程从它开始执行到当前所实际使用的CPU时间总数通常称作当前实际运行时间。通过这个近似的方法，进程的工作集可以被称为在过去的实际运行时间中它所访问过的页面的集合。</p>
<p>该算法工作方式如下：假定使用硬件来置R位和M位，同样，假定在每个时钟滴答中，有一个定期的时钟中断会用软件方法来清除R位。每当缺页中断发生时，扫描页表以找出一个合适的页面淘汰之。在处理毎个表项时，都需要检査R位：</p>
<ul>
<li>如果它是1，就把当前实际时间写进页表项的“上次使用时间”域，以表示缺页中断发生时该页面正在被使用。既然该页面在当前时钟滴答中已经被访问过，那么 很明显它应该出现在工作集中，并且不应该被删除。</li>
<li>如果R是0，那么表示在当前时钟滴答中，该页面还没有被访问过，则它就可以作为候选者被置换。为了知道它是否应该被置换，需要计算它的生存时间（即当前实际运行时间减去上次使用时间）。如果它的生存时间大于t，那么这个页面就不再在工作集中，而用新的页面置换它。扫描会继续进行以更新剩余的表项。</li>
</ul>
<p>然而，如果R是0同时生存时间小于或等于t，则该页面仍然在工作集中。这样就要把该页面临时保留下来，但是要记录生存时间最长（“上次使用时间”的最小值）的页面。如果扫描完整个页表却没有找到适合被淘汰的页面，也就意味着所有的页面都在工作集中。在这种情况下，如果找到了一个或者多个R = 0的页面，就淘汰生存时间最长的页面。在最坏情况下，在当前时间滴答中，所有的页面都被访问过了（也就是都有R=l），因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。</p>
<h2 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h2><p>当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。有一种改进的算法，它基于时钟算法，并且使用了工作集信息，称为WSClock（工作集时钟）算法，由于它实现简单，性能较好，所以在实际工作中得到了广泛应用。</p>
<p><img src="%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.jpg" alt="工作集时钟页面置换算法"></p>
<p>与时钟算法一样，所需的数据结构是一个以页框为元素的循环表，参见图a，最初，该表是空的。当装入第一个页面后，把它加到该表中。随着更多的页面的加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R位（已标明）和M位（未标明）。</p>
<p>与时钟算法一样，每次缺页中断时，首先检査指针指向的页面。如果R位被置为1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。该事件序列之后的状态参见图b。</p>
<p>如果R位被置为0，如果页面的生存时间大于t并且该页面是干净的，它就不在工作集中，并且在磁盘上有一个有效的副本。申请此页框，并把新页面放在其中，如图d所示。另一方面，如果此页面被修改过，就不能立即申请页框，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个旧的且干净的页面可以立即使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">最优算法</td>
<td align="center">不可实现，但可用作基准</td>
</tr>
<tr>
<td align="center">NRU（最近未使用）算法</td>
<td align="center">LRU的粗糙版</td>
</tr>
<tr>
<td align="center">FIFO（先进先出）算法</td>
<td align="center">可能抛弃重要页面</td>
</tr>
<tr>
<td align="center">第二次机会算法</td>
<td align="center">比FIFO有较大的改善</td>
</tr>
<tr>
<td align="center">时钟算法</td>
<td align="center">现实</td>
</tr>
<tr>
<td align="center">LRU（最近最少使用）算法</td>
<td align="center">很优秀，但很难实现</td>
</tr>
<tr>
<td align="center">最不经常使用算法</td>
<td align="center">LRU的相对粗略的近似</td>
</tr>
<tr>
<td align="center">老化算法</td>
<td align="center">非常近似LRU的有效算法</td>
</tr>
<tr>
<td align="center">工作集算法</td>
<td align="center">实现起来开销很大</td>
</tr>
<tr>
<td align="center">工作集时钟算法</td>
<td align="center">好的有效算法</td>
</tr>
</tbody></table>
<h1 id="分页系统的设计问题"><a href="#分页系统的设计问题" class="headerlink" title="分页系统的设计问题"></a>分页系统的设计问题</h1><h2 id="局部-全局分配策略"><a href="#局部-全局分配策略" class="headerlink" title="局部/全局分配策略"></a>局部/全局分配策略</h2><p>三个进程A、B、C构成了可运行进程的集合。假如A发生了缺页中断，页面置换算法在寻找最近最少使用的页面时是只考虑分配给A的页面呢？还是考虑所有在内存中的页面？</p>
<h2 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h2><p>即使是使用最优页面置换算法并对进程采用理想的全局页框分配，系统也可能会发生颠簸。事实上，一旦所有进程的组合工作集超出了内存容量，就可能发生颠簸。</p>
<p>减少竞争内存的进程数的一个好方法是将一部分进程交换到磁盘，并释放他们所占有的所有页面。即使是使用分页，交换也是需要的，只是现在交换是用来减少对内存潜在的需求，而不是收回它的页面。</p>
<h2 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h2><h2 id="分离的指令空间和数据空间"><a href="#分离的指令空间和数据空间" class="headerlink" title="分离的指令空间和数据空间"></a>分离的指令空间和数据空间</h2><h2 id="共享页面"><a href="#共享页面" class="headerlink" title="共享页面"></a>共享页面</h2><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>可以使用其他的粒度取代单个页面来实现共享。如果一个程序被启动两次，大多数操作系统会自动共享所有的代码页面，而在内存中只保留一份代码页面的副本。代码页面总是只读的，因此这样做不存在任何问题。</p>
<p>依赖于不同的操作系统，每个进程都拥有一份数据页面的私有副本，或者这些数据页面被共享并且被标记为只读。如果任何一个进程对一个数据页面进行修改，系统就会为此进程复制这个数据页面的一个副本，并且这个副本是此进程私有的，也就是说会执行“写时复制”。</p>
<p>现代操作系统中，有很多大型库被众多进程使用，例如，处理浏览文件以便打开文件的对话框的库和多个图形库。把所有的这些库静态地与磁盘上的每一个可执行程序绑定在一起，将会使它们变得更加庞大。</p>
<p>一个更加通用的技术是使用共享库。</p>
<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>共享库实际上是一种更为通用的机制——内存映射文件(memory-mapped file)的一个特例。这种机制的思想是：进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。在多数实现中，在映射共享的页面时不会实际读入页面的内容，而是在访问页面时才会被每次一页地读入，磁盘文件则被当作后备存储。当进程退出或显式地解除文件映射时，所有被改动的页面会被写回到磁盘文件中。</p>
<p>内存映射文件提供了一种I/O的可选模型。可以把一个文件当作一个内存中的大字符数组来访问，而不用通过读写操作来访问这个文件。在一些情况下，程序员发现这个模型更加便利。如果两个或两个以上的进程同时映射了同一个文件，它们就可以通过共享内存来通信。一个进程在共享内存上完成了写操作，此刻当另一个进程在映射到这个文件的虚拟地址空间上执行读操作时，它就可以立刻看到上一个进程写操作的结果。因此，这个机制提供了一个进程之间的高带宽通道，而且这种应用很普遍(甚至扩展到用来映射无名的临时文件)。很显然，如果内存映射文件可用，共享库就可以使用这个机制。</p>
<h2 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h2><p>如果发生缺页中断时系统中有大量的空闲页框，此时分页系统工作在最佳状态。如果每个页框都被占用，而且被修改过的话，再换入一个新页面时，旧页面应首先被写回磁盘。为保证有足够的空闲页框，很多分页系统有一个称为分页守护进程(paging daemon)的后台进程，它在大多数时候睡眠，但定期被唤醒以检査内存的状态。如果空闲页框过少，分页守护进程通过预定的页面置换算法选择页面换出内存。如果这些页面装入内存后被修改过，则将它们写回磁盘。</p>
<p>在任何情况下，页面中原先的内容都被记录下来。当需要使用一个已被淘汰的页面时，如果该页框还没有被覆盖，将其从空闲页框缓冲池中移出即可恢复该页面。保存一定数目的页框供给比使用所有内存并在需要时捜索一个页框有更好的性能。分页守护进程至少保证了所有的空闲页框是“干净”的，所以空闲页框在被分配时不必再急着写回磁盘。</p>
<p>一种实现清除策略的方法就是使用一个双指针时钟。前指针由分页守护进程控制。当它指向一个脏页面时，就把该页面写回磁盘，前指针向前移动。当它指向一个干净页面时，仅仅指针向前移动。后指针用于页面置换，就像在标准时钟算法中一样。现在，由于分页守护进程的工作，后指针命中干净页面的概率会增加。</p>
<h2 id="虚拟内存接口"><a href="#虚拟内存接口" class="headerlink" title="虚拟内存接口"></a>虚拟内存接口</h2><p>到现在为止，所有的讨论都假定虚拟内存对进程和程序员来说是透明的，也就是说，它们都可以在一台只有较少物理内存的计算机上看到很大的虚拟地址空间。对于不少系统而言这样做是对的，但对于一些髙级系统而言，程序员可以对内存映射进行控制，并可以通过非常规的方法来增强程序的行为。</p>
<p>允许程序员对内存映射进行控制的一个原因就是为了允许两个或者多个进程共享同一部分内存。如果程序员可以对内存区域进行命名，那么就有可能实现共享内存：通过让一个进程把一片内存区域的名称通知另一个进程，而使得第二个进程可以把这片区域映射到它的虚拟地址空间中去。通过两个进程(或者更多)共享同一部分页面，髙带宽的共享就成为可能——一个进程往共享内存中写内容而另一个从中读出内容。</p>
<p>页面共享也可以用来实现高性能的消息传递系统。</p>
<h1 id="虚拟内存系统的实现问题"><a href="#虚拟内存系统的实现问题" class="headerlink" title="虚拟内存系统的实现问题"></a>虚拟内存系统的实现问题</h1><h2 id="与分页相关的工作"><a href="#与分页相关的工作" class="headerlink" title="与分页相关的工作"></a>与分页相关的工作</h2><p>操作系统要在下面的四段时间里做与分页相关的工作：进程创建时，进程执行时，缺页中断时和进程终止时。</p>
<ul>
<li>当在分页系统中创建一个新进程时，操作系统要确定程序和数据在初始时有多大，并为它们创建一个页表。操作系统还要在内存中为页表分配空间并对其进行初始化。当进程被换出时，页表不需要驻留在内存中，但当进程运行时，它必须在内存中。另外，操作系统要在磁盘交换区中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。操作系统还要用程序正文和数据对交换区进行初始化，这样当新进程发生缺页中断时，可以调入需要的页面。某些系统直接从磁盘上的可执行文件对程序正文进行分页，以节省磁盘空间和初始化时间。最后，操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。</li>
<li>当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前的进程遗留的痕迹。新进程的页表必须成为当前页表，通常可以通过复制该页表或者把一个指向它的指针放进某个硬件寄存器来完成。有时，在进程初始化时可以把进程的部分或者全部页面装入内存中以减少缺页中断的发生，例如，PC（程序计数器）所指的页面肯定是需要的。</li>
<li>当缺页中断发生时，操作系统必须通过读硬件寄存器来确定是哪个虚拟地址造成了缺页中断。通过该信息，它要计算需要哪个页面，并在磁盘上对该页面进行定位。它必须找到合适的页框来存放新页面，必要时还要置换老的页面，然后把所需的页面读入页框。最后，还要回退程序计数器，使程序计数器指向引起缺页中断的指令，并重新执行该指令。</li>
<li>当进程退出的时候，操作系统必须释放进程的页表、页面和页面在硬盘上所占用的空间。如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止的时候，才可以释放内存和磁盘上的页面。</li>
</ul>
<h2 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h2><ol>
<li>硬件陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的CPU寄存器中。</li>
<li>启动一个汇编代码例程保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。</li>
<li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬件寄存器包含了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看它在缺页中断时正在做什么。</li>
<li>一旦知道了发生缺页中断的虚拟地址，操作系统检査这个地址是否有效，并检査存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。</li>
<li>如果选择的页框“脏”了，安排该页写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。</li>
<li>—旦页框“干净”后（无论是立刻还是在写回磁盘后），操作系统査找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面正在被装入时，产生缺页中断的进程仍然被挂起，并且如果有其他可运行的用户进程，则选择另一个用户进程运行。</li>
<li>当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映它的位置，页框也被标记为正常状态。</li>
<li>恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。</li>
<li>调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。</li>
<li>该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断没有发生过一样。</li>
</ol>
<h2 id="指令备份"><a href="#指令备份" class="headerlink" title="指令备份"></a>指令备份</h2><p>当程序访问不在内存中的页面时，引起缺页中断的指令会半途停止并引发操作系统的陷阱。在操作系统取出所需的页面后，它需要重新启动引起陷阱的指令。但这并不是一件容易实现的事。</p>
<h2 id="锁定内存中的页面"><a href="#锁定内存中的页面" class="headerlink" title="锁定内存中的页面"></a>锁定内存中的页面</h2><p>虚拟内存和I/O通过微妙的方式相互作用着。</p>
<p>设想一个进程刚刚通过系统调用从文件或其他设备中读取数据到其地址空间中的缓冲区。在等待I/O完成时，该进程被挂起，另一个进程被允许运行，而这个进程产生一个缺页中断。如果分页算法是全局算法，包含I/O缓冲区的页面会有很小的机会（但不是没有）被选中换出内存。如果一个I/O设备正处在对该页面进行DMA传输的过程之中，将这个页面移出将会导致部分数据写入它们所属的缓冲区中，而部分数据被写入到最新装入的页面中。</p>
<p>一种解决方法是锁住正在做I/O操作的内存中的页面以保证它不会被移出内存。锁住一个页面通常称为在内存中钉住（pinning）页面。</p>
<p>另一种方法是在内核缓冲区中完成所有的I/O操作，然后再将数据复制到用户页面。</p>
<h2 id="后备存储"><a href="#后备存储" class="headerlink" title="后备存储"></a>后备存储</h2><p>在磁盘上分配页面空间的最简单的算法是在磁盘上设置特殊的交换分区，甚至从文件系统划分一块独立的磁盘（以平衡I/O负载）。大多数UNIX是这样处理的。在这个分区里没有普通的文件系统，这样就消除了将文件偏移转换成块地址的开销。取而代之的是，始终使用相应分区的起始块号。</p>
<h2 id="策略和机制的分离"><a href="#策略和机制的分离" class="headerlink" title="策略和机制的分离"></a>策略和机制的分离</h2><p>控制系统复杂度的一种重要方法就是把策略从机制中分离出来。通过使大多数存储管理器作为用户级进程运行，就可以把该原则应用到存储管理中。</p>
<p>一个如何分离策略和机制的简单例子可以参见下图：</p>
<p><img src="%E7%AD%96%E7%95%A5%E5%92%8C%E6%9C%BA%E5%88%B6%E5%88%86%E7%A6%BB.jpg" alt="策略和机制分离"></p>
<p>其中存储管理系统被分为三个部分：</p>
<ol>
<li>一个底层MMU处理程序</li>
<li>一个作为内核一部分的缺页中断处理程序</li>
<li>一个运行在用户空间中的外部页面调度程序</li>
</ol>
<p>所有关于MMU工作的细节都被封装在MMU处理程序中，该程序的代码是与机器相关的，而且操作系统每应用到一个新平台就要被重写一次。</p>
<p>缺 页中断处理程序是与机器无关的代码，包含大多数分页机制。策略主要由作为用户进程运行的外部页面调度程序所决定。</p>
<p>当一个进程启动时，需要通知外部页面调度程序以便建立进程页面映射，如果需要的话还要在磁盘上分配后备存储。当进程正在运行时，它可能要把新对象映射到它的地址空间，所以还要再一次通知外部页面调度程序。</p>
<p>一旦进程开始运行，就有可能出现缺页中断。缺页中断处理程序找出需要哪个虚拟页面，并发送一条消息给外部页面调度程序告诉它发生了什么问题。外部页面调度程序从磁盘中读入所需的页面，把它复制到自己的地址空间的某一位置。然后告诉缺页中断处理程序该页面的位置。缺页中断处理程序从外部页面调度程序的地址空间中清除该页面的映射，然后请求MMU处理程序把它放到用户地址空间的正确位置，随后就可以重新启动用户进程了。</p>
<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例程序段、数据段等。每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间是二维的。</p>
<p>段的长度在运行期间可以动态改变，比如，堆栈段的长度在数据被压入时会增长，在数据被弹出时又会减小。</p>
<p>因为每个段都构成了一个独立的地址空间，所以它们可以独立地增长或减小而不会影响到其他的段。如果一个在某个段中的堆栈需要更多的空间，它就可以立刻得到所需要的空间，因为它的地址空间中没有任何其他东西阻挡它增长。段当然有可能会被装满，但通常情况下段都很大，因此这种情况发生的可能性很小。要在这种分段或二维的存储器中指示一个地址，程序必须提供两部分地址，一个段号和一个段内地址。</p>
<h2 id="纯分段实现"><a href="#纯分段实现" class="headerlink" title="纯分段实现"></a>纯分段实现</h2><p>分段和分页的实现本质上是不同的：页面是定长的而段不是。下图演示了使用分段的过程（最后通过内存紧缩实现）：</p>
<p><img src="%E7%BA%AF%E5%88%86%E6%AE%B5.jpg" alt="纯分段"></p>
<h2 id="分段和分页结合"><a href="#分段和分页结合" class="headerlink" title="分段和分页结合"></a>分段和分页结合</h2><p>在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。</p>
<p>段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量</p>
<p>程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。</p>
<h1 id="分段和分页的区别"><a href="#分段和分页的区别" class="headerlink" title="分段和分页的区别"></a>分段和分页的区别</h1><ul>
<li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li>
<li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定</li>
<li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li>
<li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li>
</ul>
<h1 id="内部碎片和外部碎片"><a href="#内部碎片和外部碎片" class="headerlink" title="内部碎片和外部碎片"></a>内部碎片和外部碎片</h1><ul>
<li>内部碎片（internalfragment)，通常是指将内存以固定大小的块进行分配，采用这种方案，进程所分配的内存可能比所需的大，多出来的未被使用的内存叫做内部碎片。内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间。</li>
<li>外部碎片（externalfragment)，通常是指随着进程移进移出内存，内存的空闲空间被分割成小片段，当所有的总的可用内存之和可以满足分配请求，但是却不连续，就出现了外部碎片问题。外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</li>
</ul>
<p>页式虚拟存储系统存在内部碎片，段式虚拟存储系统存在外部碎片。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">操作系统-进程与线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-02 20:05:29" itemprop="dateCreated datePublished" datetime="2019-12-02T20:05:29+08:00">2019-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统-进程与线程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程模型：</p>
<ul>
<li>进程是对正在运行程序的一个抽象。单个CPU通过轮转方式也可以实现<strong>伪并行</strong>。在CPU的一个核中，任何时候都只有一个进程在执行。</li>
</ul>
<p>进程分类：</p>
<ul>
<li>在系统中有与用户交互的<strong>前台进程</strong>，也有停留在后台处理诸如邮件，打印等活动的<strong>守护进程</strong>。</li>
</ul>
<p>进程的地址空间：</p>
<ul>
<li>在Unix/Linux中，只有一个系统调用可以用来创建新进程：fork。子进程共享父进程的所有内存，它通过<strong>写时复制（copy-on-write）</strong>的方式共享，它有机会共享父进程的其他资源，比如打开的文件等。一旦两者之一想要修改部分内存，则这块内存首先被复制，以确保发生在私有内存区域，<strong>写时的内存是不可以共享的</strong>。</li>
<li>在Windows中，一开始父进程和子进程之间的地址空间就是不同的。</li>
</ul>
<p>进程的层次结构：</p>
<ul>
<li>在UNIX中，进程和它的所有子进程以及其后裔组成一个进程组。进程不能剥夺其子进程的继承权。</li>
<li>在Windows中没有进程层次的概念，所有进程的地位是相同的。唯一类似进程层次的是在创建进程的时候，父进程会得到一个句柄，它可以用来控制子进程。但是它有权将这个句柄传送给某个进程，这样它们就不存在层次结构了。</li>
</ul>
<p>进程状态：运行态，阻塞态，就绪态。如下图：</p>
<p><img src="%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt="进程状态"></p>
<p>为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表（process table）。每个进程占用一个进程表项。该表项的部分典型字段如下：</p>
<p><img src="%E8%BF%9B%E7%A8%8B%E8%A1%A8%E9%83%A8%E5%88%86%E5%AD%97%E6%AE%B5.jpg" alt="进程表部分字段"></p>
<p>在了解这些之后，对单个CPU如何进行伪并行可以有更多的理解。当中断发生后，操作系统底层的工作步骤如下：</p>
<ol>
<li>中断硬件将程序计数器，程序状态字，寄存器等压入堆栈；</li>
<li>计算机跳转到中断向量所指示的地址（<strong>中断向量</strong>：包含中断服务程序的入口地址），硬件从中断向量装入新的程序计数器；</li>
<li>汇编语言保存寄存器值，对于当前进程而言，通常保存在进程表项中；</li>
<li>汇编语言设置新的堆栈；</li>
<li>C中断服务例程运行处理某个特定的中断类型剩下的工作（典型地读和缓存输入）；</li>
<li>调度程序决定下一个即将运行的进程；</li>
<li>C过程将控制返回至汇编代码，为当前进程装入寄存器值以及内存映射</li>
<li>汇编语言启动新的进程运行。</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程模型：</p>
<ul>
<li>线程给进程模型增加了一项内容，即在同一个进程环境中，允许彼此之间有较大的独立性的多个线程执行；</li>
<li>在同一个进程中并行运行多个线程，是对在同一台计算机上并行运行多个进程的模拟。前者多个线程共享同一个地址空间及其它资源。后者多个进程共享物理内存，磁盘，打印机等资源；</li>
<li>一个线程可以读写甚至清除另一个线程的堆栈，线程之间没有保护；</li>
<li>当多线程进程在单个CPU中运行时，线程轮流运行。</li>
</ul>
<p>在一个进程中所有线程共享的资源：</p>
<ul>
<li>地址空间</li>
<li>全局变量</li>
<li>打开文件</li>
<li>子进程</li>
<li>即将发生的定时器</li>
<li>信号与信号处理程序</li>
<li>账户信息</li>
</ul>
<p>每个线程自己的内容：</p>
<ul>
<li>程序计数器</li>
<li>寄存器</li>
<li>堆栈</li>
<li>状态</li>
</ul>
<p>POSIX线程：</p>
<ul>
<li>为了实现可移植的线程程序，IEEE定义了线程的标准。它定义个线程包为<strong>pthread</strong>；</li>
<li>大部分UNIX及UNIX-like都支持该标准；</li>
<li>pthread_create，pthread_exit，pthread_join，pthread_yield等。</li>
</ul>
<p>实现线程的方式：</p>
<ul>
<li>在用户空间实现</li>
<li>在内核空间实现</li>
<li>混合实现</li>
</ul>
<p>如下图：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.jpg" alt="线程实现方式"></p>
<p>用户空间实现线程：</p>
<ul>
<li>把线程包放在用户空间，内核对其一无所知，从内核的角度，它按照正常的方式管理，即单线程进程；</li>
<li>用户级线程可以在不支持线程的操作系统上实现；</li>
<li>在用户空间管理线程时，每个进程需要有其专用的线程表，跟进程表类似，它记录着每个线程的程序计数器，堆栈指针等。该线程表由<strong>运行时系统</strong>管理，当一个线程转换到就绪/阻塞状态时，在表中存放重启该线程所需要的信息；</li>
<li>保存线程状态和调度程序都只是本地过程，所以启动它们比进行内核调用效率更髙。另一方面，不需要陷入内核，不需要上下文切换，也不需要对内存髙速缓存进行刷新，因此非常快捷；</li>
<li>允许每个进程有自己定制的调度算法。用户级线程还具有较好的可扩展性，这是因为在内核空间中内核线程需要一些固定表格空间和堆栈空间，如果内核线程的数量非常大，就会出现问题；</li>
<li>问题一：<strong>阻塞调用问题</strong>。使用线程的一个主要目标是，允许每个线程使用阻塞调用，但是还要避免被阻塞的线程影响其他的线程。有一种可能的替代方案，就是如果某个调用会阻塞，就提前通知。只有在安全的情形下（即不会阻塞）才进行阻塞调用。否则调用就不进行，代之以运行另一个线程。这个处理方法需要重写部分系统调用库，所以效率不髙也不优雅，不过没有其他的可选方案了。</li>
<li>问题二：<strong>缺页中断问题</strong>。在对缺失的指令进行定位和读入时，相关的进程就被阻塞。如果有一个线程引起页面故障，内核由于不知道有线程的存在，通常会把整个进程阻塞直到磁盘I/O 完成为止；</li>
<li>问题三：如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。在一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程。除非某个线程能够按照自己的意志进入运行时系统，否则调度程序就没有任何机会。</li>
</ul>
<p>在内核中实现线程：</p>
<ul>
<li>内核的线程表保存了每个线程的寄存器、状态和其他信息。这些信息和在用户空间中（在运行时系统中）的线程是一样的；</li>
<li>由于在内核中创建或撒销线程的代价比较大，某些系统采取“环保”的处理方式回收其线程。当某个线程被撒销时，就把它标志为不可运行的，但是其内核数据结构没有受到影响。稍后，在必须创建一个新线程时，就重新启动某个旧线程，从而节省了一些开销；</li>
<li>当一个多线程进程创建新的进程时，新进程是拥有与原进程相同数量的线程，还是只有一个线程？在很多情况下，最好的选择取决于进程计划下一步做什么；</li>
<li>在经典模型中，信号是发给进程而不是线程的。当一个信号到达时，应该由哪一个线程处理它？线程可以“注册”它们感兴趣的某些信号，因此当一个信号到达的时候，可把它交给需要它的线程。但是如果多个线程注册了相同的信号，可能会出现问题。</li>
</ul>
<p>混合实现：</p>
<ul>
<li>内核级线程和用户级线程彼此多路复用；</li>
<li>内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</li>
</ul>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IPC，Inter Process Communication。在进程之间的通信最好使用一种结构良好的方式而不要使用中断。有三个问题：</p>
<ol>
<li>一个进程如何把信息传递给另一个进程；</li>
<li>确保多个进程在关键活动中不会出现交叉，比如说争夺资源；</li>
<li>顺序正确，比如，如果进程A产生数据而进程B打印数据，那么B在打印之前必须等待，直到A已经产生一些数据。</li>
</ol>
<p>同样的问题和解决方法也适用于线程。</p>
<h2 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h2><ul>
<li>进程隔离是为了保护操作系统中进程相互不干扰而设计的一组不同硬件和软件的技术</li>
<li>进程的隔离实现，使用了虚拟地址空间</li>
<li>进程A的虚拟地址和进程B的虚拟地址不同，这样就防止了进程A将数据信息写入进程B，也就是说进程之间的数据是不共享的，因此进程之间的交互就必须得通过IPC机制</li>
</ul>
<p>进程间通信就是在不同进程之间传播或交换信息，那么不同进程之间存在着什么双方都可以访问的介质呢？进程的用户空间是互相独立的，一般而言是不能互相访问的，唯一的例外是<font color="#990000">共享内存区</font>。但是，系统空间却是“公共场所”，所以内核显然可以提供这样的条件。除此以外，那就是双方都可以访问的外设了。在这个意义上，两个进程当然也可以通过磁盘上的普通文件交换信息，或者通过“注册表”或其它数据库中的某些表项和记录交换信息。广义上这也是进程间通信的手段，但是一般都不把这算作“进程间通信”。因为那些通信手段的效率太低了，而人们对进程间通信的要求是要有一定的实时性。</p>
<p>进程间通信主要包括管道, 系统IPC（Inter-Process Communication，进程间通信）(包括消息队列,信号量,共享存储), SOCKET.</p>
<h2 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道(pipe)"></a>管道(pipe)</h2><ol>
<li>普通管道PIPE, 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用.</li>
<li>流管道s_pipe: 去除了第一种限制,可以双向传输.</li>
<li>命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.</li>
</ol>
<p>管道单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</p>
<p>管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。</p>
<p>管道: 优点是所有的UNIX实现都支持, 并且在最后一个访问管道的进程终止后,管道就被完全删除;缺陷是管道只允许单向传输或者用于父子进程之间.并且管道在创建时分配一个page大小的内存，缓存区大小比较有限。</p>
<p>系统IPC: 优点是功能强大,能在毫不相关进程之间进行通讯; 缺陷是关键字KEY_T使用了内核标识,占用了内核资源,而且只能被显式删除,而且不能使用SOCKET的一些机制,例如select,epoll等.</p>
<h2 id="信号量-semophore"><a href="#信号量-semophore" class="headerlink" title="信号量(semophore)"></a>信号量(semophore)</h2><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h2 id="消息队列-message-queue"><a href="#消息队列-message-queue" class="headerlink" title="消息队列(message queue)"></a>消息队列(message queue)</h2><p>消息队列，就是一个消息的链表，是一系列<strong>保存在内核中消息的列表</strong>，由消息队列标识符标识。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</p>
<p>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
<h2 id="信号-sinal"><a href="#信号-sinal" class="headerlink" title="信号(sinal)"></a>信号(sinal)</h2><p>信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。</p>
<p>信号传递信息少，不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等。</p>
<h2 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存(shared memory)"></a>共享内存(shared memory)</h2><p>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。</p>
<h2 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h2><p>套接字作为更通用的接口，传输效率低，主要用于不同机器或跨网络的通信。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux是使用的虚拟内存寻址方式，有如下特性：</p>
<ul>
<li>用户空间的虚拟内存地址是映射到物理内存中的</li>
<li>对虚拟内存的读写实际上是对物理内存的读写，这个过程就是内存映射</li>
<li>这个内存映射过程是通过系统调用mmap()来实现的</li>
</ul>
<p>IPC机制通信流程【共享内存机制除外】</p>
<ul>
<li>首先，发送方进程通过系统调用将要发送的数据从用户空间copy到内核空间缓存区中</li>
<li>接着，接收方开辟一段内存空间，然后通过系统调用将内核缓存区中的数据copy到接收方的内存缓存区</li>
</ul>
<p><img src="Linux-IPC.jpg" alt="Linux-IPC"></p>
<p>这种方式存在两个问题：</p>
<ul>
<li>需要做2次数据拷贝操作</li>
<li>接收方进程在接收数据之前，需要事先分配空间来存取数据，但不知道事先要分配多大的空间，这样就可能存在一种在空间上的浪费</li>
</ul>
<p>针对Android中的Binder通信流程，在数据拷贝上有一个优化：</p>
<p><img src="binder.jpg" alt="binder"></p>
<ul>
<li>Binder借助了内存映射的方法，在内核空间和接收方用户空间的数据缓存区之间做了一层内存映射，就相当于直接拷贝到了接收方用户空间的数据缓存区，从而减少了一次数据拷贝</li>
</ul>
<h1 id="同步-互斥方式"><a href="#同步-互斥方式" class="headerlink" title="同步/互斥方式"></a>同步/互斥方式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul>
<li>互斥：是指散步在不同任务之间的若干程序片断，当某个任务运行其中一个程序片段时，其它任务就不能运行它们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。最基本的场景就是：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。</li>
<li>同步：是指散步在不同任务之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。最基本的场景就是：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。</li>
<li>竞争条件（race condition）：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>在某些时候进程可能需要访问共享内存或共享文件，或执行另外一些会导致竞争的操作，把对共享内存进行访问的程序片段称作临界区。临界区应满足这些条件：</p>
<ol>
<li>任何两个进程不能同时处于其临界区</li>
<li>不应对CPU的速度和数量做任何假设</li>
<li>临界区外运行的进程不得阻塞其他进程</li>
<li>不得使进程无限期等待进入临界区</li>
</ol>
<h2 id="忙等待的互斥"><a href="#忙等待的互斥" class="headerlink" title="忙等待的互斥"></a>忙等待的互斥</h2><p>当一个进程想进入临界区时，先检査是否允许进入，若不允许，则该进程将原地等待，直到允许为止。</p>
<p>这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。考虑一台计算机有两个进程，H优先级较髙，L优先级较低。调度规则规定，只要H处于就绪态它就可以运行。在某一时刻，L处干临界区中，此时H变到就绪态，准备运行(例如，一条I/O操作结束)。现在H开始忙等待，但由于当H就绪时L不会被调度，也就无法离开临界区，所以H将永远忙等待下去。这种情况有时被称作优先级反转问题 (priority inversion problem)。</p>
<p>在单处理器系统中，最简单的方法是使毎个进程在刚刚进入临界区后立即屏蔽所有中断，并在就要离开之前再打开中断。在屏蔽中断之后CPU将不会被切换到其他进程。于是，一旦某个进程屏蔽中断之后，它就可以检査和修改共享内存，而不必担心其他进程介入。</p>
<p>这个方案并不好，因为把屏蔽中断的权力交给用户进程是不明智的。若一个进程屏蔽中断后不再打开中断，整个系统可能会因此终止。而且，如果系统是多处理器，则屏蔽中断仅仅对执行disable指令的那个CPU有效。其他CPU仍将继续运行，并可以访问共享内存。</p>
<p>另一方面，对内核来说，当它在更新变量或列表的几条指令期间将中断屏蔽是很方便的。当就绪进程队列之类的数据状态不一致时发生中断，则将导致竞争条件。所以结论是：屏蔽中断对于操作系统本身而言是一项很有用的技术，但对于用户进程则不是一种合适的通用互斥机制。由于多核芯片的数量越来越多，即使在低端PC上也是如此。因此，通过屏蔽中断来达到互斥的可能性一甚至在内核中一变得日益减少了。</p>
<h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><p>当一个进程A访问临界区时，其他试图访问临界区的进程在无法进入临界区时将阻塞，而不是忙等待，在前一个进程处理完一个任务后，会主动唤醒其他阻塞的进程。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用<code>信号量</code>对象。它保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。如果这个计数达到了零，则所有对这个对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。</p>
<p>信号量的取值可以为0或者其他正整数，在信号量上只有三种操作可以进行：初始化，P操作和V操作，这三种操作都是原子操作。</p>
<p>P（passeren：通过）操作(递减操作)可以用于阻塞一个进程，V（vrijgeven：释放）操作(增加操作)可以用于解除阻塞一个进程。</p>
<p>信号量机制功能强大，但使用时对信号量的操作分散，而且难以控制，读写和维护都很困难。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P(S):</span><br><span class="line">    S--;</span><br><span class="line">    <span class="keyword">while</span> S&lt;<span class="number">0</span> <span class="keyword">do</span> block;</span><br><span class="line"></span><br><span class="line">V(S):</span><br><span class="line">    S++;</span><br><span class="line">    <span class="keyword">if</span> S&lt;=<span class="number">0</span> then wakeup;</span><br></pre></td></tr></table></figure>

<p>信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。信号量的值仅能由PV操作来改变。</p>
<p>一般来说，信号量S&gt;0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</p>
<p>使用PV操作实现进程互斥时应该注意的是：</p>
<ul>
<li>每个程序中用户实现互斥的P、V操作必须成对出现，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。</li>
<li>P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。</li>
<li>互斥信号量的初值一般为1。</li>
<li>分析进程间的制约关系，确定信号量种类。在保持进程间有正确的同步关系情况下，哪个进程先执行，哪些进程后执行，彼此间通过什么资源（信号量）进行协调，从而明确要设置哪些信号量。</li>
<li>信号量的初值与相应资源的数量有关，也与P、V操作在程序代码中出现的位置有关。</li>
<li>同一信号量的P、V操作要成对出现，但它们分别在不同的进程代码中。</li>
</ul>
<h3 id="C语言PV操作"><a href="#C语言PV操作" class="headerlink" title="C语言PV操作"></a>C语言PV操作</h3><ol>
<li><code>#include &lt;semaphore.h&gt;</code></li>
<li><code>int sem_init(sem_t *sem,int pshared, unsigned int value)</code><ul>
<li>函数作用：初始化信号量 </li>
<li>sem：信号量指针 </li>
<li>Pshared：决定信号量能否在几个进程间共享，一般取0 </li>
<li>Value：信号量的初始值 </li>
</ul>
</li>
<li>信号的操作<ul>
<li>P操作：<code>int sem_wait(sem_t *sem);</code></li>
<li><code>int sem_try_wait(sem_t *sem);</code></li>
<li>V操作：<code>int sempost(sem_t *sem);</code></li>
<li><code>int sem_getvalue(sem_t *sem);</code></li>
<li>销毁信号：<code>int sem_destroy(sem_t *sem);</code></li>
</ul>
</li>
</ol>
<h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><ol>
<li><p>一个生产者，一个消费者，公用一个缓冲区。定义两个同步信号量：</p>
<ul>
<li><p>empty——表示缓冲区是否为空，初值为1。</p>
</li>
<li><p>full——表示缓冲区中是否为满，初值为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者进程：</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    P(empty);</span><br><span class="line">    产品送往Buffer;</span><br><span class="line">    V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程:</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    P(full);</span><br><span class="line">    从Buffer取出一个产品;</span><br><span class="line">    V(empty);</span><br><span class="line">    消费该产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一个生产者，一个消费者，公用n个环形缓冲区。定义两个同步信号量：</p>
<ul>
<li><p>empty——表示缓冲区是否为空，初值为n。</p>
</li>
<li><p>full——表示缓冲区中是否为满，初值为0。</p>
<p>设缓冲区的编号为1～n-1，定义两个指针in和out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    P(empty);</span><br><span class="line">    产品送往buffer（in）；</span><br><span class="line">    in=(in+<span class="number">1</span>)mod n；</span><br><span class="line">    V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    P(full);</span><br><span class="line">    从buffer（out）中取出产品；</span><br><span class="line">    out=(out+<span class="number">1</span>)mod n；</span><br><span class="line">    V(empty);</span><br><span class="line">    消费该产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一组生产者，一组消费者，公用n个环形缓冲区</p>
<p> 在这个问题中，不仅生产者与消费者之间要同步，而且各个生产者之间、各个消费者之间还必须互斥地访问缓冲区。<br> 定义四个信号量：</p>
<ul>
<li><p>empty——表示缓冲区是否为空，初值为n。</p>
</li>
<li><p>full——表示缓冲区中是否为满，初值为0。</p>
</li>
<li><p>mutex1——生产者之间的互斥信号量，初值为1。</p>
</li>
<li><p>mutex2——消费者之间的互斥信号量，初值为1。</p>
<p>设缓冲区的编号为1～n-1，定义两个指针in和out，分别是生产者进程和消费者进程使用的指针，指向下一个可用的缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    生产一个产品;</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex1)；</span><br><span class="line">    产品送往buffer（in）；</span><br><span class="line">    in=(in+<span class="number">1</span>)mod n；</span><br><span class="line">    V(mutex1);</span><br><span class="line">    V(full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    P(full)</span><br><span class="line">    P(mutex2)；</span><br><span class="line">    从buffer（out）中取出产品；</span><br><span class="line">    out=(out+<span class="number">1</span>)mod n；</span><br><span class="line">    V（mutex2）；</span><br><span class="line">    V(empty);</span><br><span class="line">    消费该产品;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>题：桌上有一空盘，允许存放一只水果。爸爸可向盘中放苹果，也可向盘中放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘空时一次只能放一只水果供吃者取用，请用P、V原语实现爸爸、儿子、女儿三个并发进程的同步。</p>
<p>分析：在本题中，爸爸、儿子、女儿共用一个盘子，盘中一次只能放一个水果。当盘子为空时，爸爸可将一个水果放入果盘中。若放入果盘中的是桔子，则允许儿子吃，女儿必须等待；若放入果盘中的是苹果，则允许女儿吃，儿子必须等待。本题实际上是生产者-消费者问题的一种变形。这里，生产者放入缓冲区的产品有两类，消费者也有两类，每类消费者只消费其中固定的一类产品。</p>
<p>解：在本题中，应设置三个信号量S、So、Sa，信号量S表示盘子是否为空，其初值为l；信号量So表示盘中是否有桔子，其初值为0；信号量Sa表示盘中是否有苹果，其初值为0。同步描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> S＝<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> Sa＝<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> So＝<span class="number">0</span>;</span><br><span class="line">main() &#123;</span><br><span class="line">cobegin</span><br><span class="line">    father();      <span class="comment">/*父亲进程*/</span></span><br><span class="line">    son();        <span class="comment">/*儿子进程*/</span></span><br><span class="line">    daughter();    <span class="comment">/*女儿进程*/</span></span><br><span class="line">coend</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">father() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(S);</span><br><span class="line">        将水果放入盘中;</span><br><span class="line">        <span class="keyword">if</span>（放入的是桔子）V(So);</span><br><span class="line">        <span class="keyword">else</span>  V(Sa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">son() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(So);</span><br><span class="line">        从盘中取出桔子;</span><br><span class="line">        V(S);</span><br><span class="line">        吃桔子;</span><br><span class="line">    ｝</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">daughter() &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        P(Sa);</span><br><span class="line">        从盘中取出苹果;</span><br><span class="line">        V(S);</span><br><span class="line">        吃苹果;</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>如果不需要信号量的计数能力，有时可以使用信号量的一个简化版本，称为互斥量(mutex)。互斥量仅仅适用于管理共享资源或一小段代码。由于互斥量在实现时既容易又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个可以处于两态之一的变量：解锁和加锁。互斥量使用两个过程。当一个线程（或进程）需要访问临界区时，它调用mutex_lock，如果该互斥量当前是解锁的（即临界区可用），此调用成功，调用线程可以自由进入该临界区。另一方面，如果该互斥量已经加锁，调用线程被阻塞，直到在临界区中的线程完成并调用mutex_unlock，如果多个线程被阻塞在该互斥量上，将随机选择一个线程并允许它获得锁。</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>使用信号量时要非常小心。一处很小的错误将导致很大的麻烦。为了更易于编写正确的程序，出现了一种髙级同步原语，称为管程(monitor)。</p>
<p>其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。</p>
<p>管程有一个很重要的特性，即任一时刻管程中只能有一个活跃进程，这一特性使管程能有效地完成互斥。管程是编程语言的组成部分，编译器知道它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用。典型的处理方法是，当一个进程调用管程过程时，该过程中的前几条指令将检査在管程中是否有其他的活跃进程。如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。如果没有活跃进程在使用管程，则该调用进程可以进入。</p>
<p>进入管程时的互斥由编译器负责，但通常的做法是用一个互斥量或二元信号量。因为是由编译器而非程序员来安排互斥，所以出错的可能性要小得多。在任一时刻，写管程的人无须关心编译器是如何实现互斥的。他只需知道将所有的临界区转换成管程过程即可，决不会有两个进程同时执行临界区中的代码。</p>
<h1 id="进程-线程调度"><a href="#进程-线程调度" class="headerlink" title="进程/线程调度"></a>进程/线程调度</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>当计算机系统是多道程序设计系统时，通常就会有多个进程或线程同时竞争CPU。只要有两个或更多的进程处于就绪状态，这种情形就会发生。如果只有一个CPU可用，那么就必须选择下一个要运行的进程。在操作系统中，完成选择工作的这一部分称为调度程序(scheduler),该程序使用的算法称为调度算法(scheduling algorithm)。</p>
<p>尽管有一些不同，但许多适用于进程调度的处理方法也同样适用于线程调度。当内核管理线程的时候，调度经常是按线程级别的，与线程所属的进程基本或根本没有关联。</p>
<ul>
<li>计算密集型进程：具有较长时间的C PU集中使用和较小频度的I/O等待</li>
<li>I/O密集型进程：具有较短时间的C PU集中使用和频繁的I/O等待</li>
</ul>
<p>在不同的系统中，调度程序的优化是不同的：</p>
<ul>
<li>批处理系统</li>
<li>交互式系统</li>
<li>实时系统</li>
</ul>
<p>调度算法的目标：</p>
<ol>
<li>所有系统<ul>
<li>公平：给每个进程公平的CPU份额</li>
<li>策略强制执行：保证规定的策略被执行</li>
<li>平衡：保持系统的所有部分都忙碌</li>
</ul>
</li>
<li>批处理系统<ul>
<li>吞吐量：毎小时最大作业数</li>
<li>周转时间：从提交到终止间的最小时间</li>
<li>CPU利用率：保持CPU始终忙碌</li>
</ul>
</li>
<li>交互式系统<ul>
<li>响应时间：快速响应请求</li>
<li>均衡性：满足用户的期望</li>
</ul>
</li>
<li>实时系统<ul>
<li>满足截止时间：避免丢失数据</li>
<li>可预测性：在多媒体系统中避免品质降低</li>
</ul>
</li>
</ol>
<h2 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p>
<h3 id="最短作业-进程-优先"><a href="#最短作业-进程-优先" class="headerlink" title="最短作业(进程)优先"></a>最短作业(进程)优先</h3><p>短作业(进程)优先调度算法，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p>
<h3 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h3><p>最短作业优先的抢占式版本是最短剩余时间优先(shortest remaining time next)算法。使用这个算 法，调度程序总是选择剩余运行时间最短的那个进程运行。</p>
<h2 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h2><h3 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h3><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p>
<h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><ul>
<li>非抢占式优先权算法</li>
<li>抢占式优先权算法</li>
</ul>
<h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述：</p>
<ol>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</li>
</ol>
<h3 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h3><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互进程，那将是非常好的。</p>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>实时系统是一种时间起着主导作用的系统。典型地，一种或多种外部物理设备发给计算机一个服务请求，而计算机必须在一个确定的时间范围内恰当地做出反应。例如，在CD播放器中的计算机获得从驱动器而来的位流，然后必须在非常短的时间间隔内将位流转换为音乐。如果计算时间过长，那么音乐就会听起来有异常。</p>
<p>这种系统要求调度程序是高度可预测和有规律的。</p>
<h2 id="策略-机制分离"><a href="#策略-机制分离" class="headerlink" title="策略/机制分离"></a>策略/机制分离</h2><p>当一个进程有多个子进程并在其控制下运行时，主进程完全可能掌握哪一个子进程最重要（或最紧迫）而哪一个最不重要。但是，以上讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p>
<p>解决问题的方法是将调度机制（scheduling mechanism）与调度策略（scheduling policy）分离。也就是将调度算法以某种形式参数化，而参数可以由用户进程填写。在这里，调度机制位于内核，而调度策略则由用户进程决定。策略与机制分离是一种关键性思路。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本质差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p>
<h3 id="用户级进程"><a href="#用户级进程" class="headerlink" title="用户级进程"></a>用户级进程</h3><p>由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为A，并给予A以时间片控制。A中的线程调度程序决定哪个线程运行，假设为A1。由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程运行。</p>
<p>在进程A终于又一次运行时，线程A1会接着运行。该线程会继续耗费A进程的所有时间，直到它完成工作。不过，该线程的这种不合群的行为不会影响到其他的进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程A内部所发生的事。</p>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核选择一个特定的线程运行。它不用考虑该线程属于哪个进程，不过如果有必要的话，它可以这样做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。</p>
<p>用户级线程和内核级线程之间的差别在于性能。用户级线程的线程切换需要少量的机器指令，而内核级线程需要完整的上下文切换，修改内存映像，使髙速缓存失效，这导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在I/O上就不需要像在用户级线程中那样将整个进程挂起。</p>
<p>从进程A的一个线程切换到进程B的一个线程，其代价高于运行进程A的第2个线程（因为必须修改内存映像，清除内存髙速缓存的内容），内核对此是了解的，并可运用这些信息做出决定。例如，给定两个在其他方面同等重要的线程，其中一个线程与刚好阻塞的线程属于同一个进程，而另一个线程属于其他的进程，那么应该倾向前者。</p>
<p>另一个重要因素是用户级线程可以使用专为应用程序定制的线程调度程序。一般而言，应用定制的线程调度程序能够比内核更好地满足应用的需要。</p>
<h1 id="典型IPC问题"><a href="#典型IPC问题" class="headerlink" title="典型IPC问题"></a>典型IPC问题</h1><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>如下图所示：</p>
<p><img src="%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98.jpg" alt="哲学家就餐问题"></p>
<p>五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一盘通心粉，由于通心粉很滑，所以需要两把叉子才能夹住，相邻两个盘子之间放有一把叉子。哲学家的生活中有两种交替活动时段：即吃饭和思考。</p>
<p>当一个哲学家觉得饿了时，他就试图分两次去取其左边和右边的叉子，每次拿一把，但不分次序。如果成功地得到了两把叉子，就开始吃饭，吃完后放下叉子继续思考。关键问题是：能为每一个哲学家写一段描述其行为的程序，且决不会死锁吗？</p>
<p>哲学家就餐问题对于互斥访问有限资源的竞争问题（如I/O设备）一类的建模过程十分有用。</p>
<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>读者-写者问题为数据库访问建立了一个模型。例如，设想一个飞机订票系统，其中有许多竞争的进程试图读写其中的数据。多个进程同时读数据库是可以接受的，但如果一个进程正在更新（写）数据库，则所有的其他进程都不能访问该数据库，即使读操作也不行。如何对读者和写者进行编程？</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ol>
<li>系统资源的竞争<ul>
<li>通常系统中拥有的不可抢占资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可抢占资源的竞争才可能产生死锁，对可抢占资源的竞争是不会引起死锁的。</li>
</ul>
</li>
<li>进程推进顺序非法<ul>
<li>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。</li>
<li>信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</li>
</ul>
</li>
<li>死锁产生的必要条件，产生死锁必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。<ul>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</li>
</ul>
</li>
</ol>
<p><img src="%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6.png" alt="死锁产生条件"></p>
<h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>最简单的解决方法是鸵鸟算法：把头埋到沙子里，假装根本没有问题发生。</p>
<h2 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h2><p>系统并不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后，采取措施进行恢复。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p>
<p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。</p>
<p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。</p>
<p>下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。</p>
<img src="死锁检测.png" width="320"/>

<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><ul>
<li>利用抢占恢复：在某些情况下，可能会临时将某个资源从它的当前所有者那里转移给另一个进程。许多情况下，尤 其是对运行在大型主机上的批处理操作系统来说，需要人工进行干预。</li>
<li>利用回滚恢复，等待一段随机的时间后重试。</li>
<li>设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</li>
</ul>
<h2 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h2><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>:</span><br><span class="line">lock A</span><br><span class="line">lock B</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>:</span><br><span class="line">wait <span class="keyword">for</span> A</span><br><span class="line"><span class="function">lock <span class="title">C</span> <span class="params">(when A locked)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Thread 3:</span></span><br><span class="line"><span class="function">wait <span class="keyword">for</span> A</span></span><br><span class="line"><span class="function">wait <span class="keyword">for</span> B</span></span><br><span class="line"><span class="function">wait <span class="keyword">for</span> C</span></span><br></pre></td></tr></table></figure>

<p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p>
<p>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要事先知道所有可能会用到的锁,并对这些锁做适当的排序，但总有些时候是无法预知的。</p>
<h2 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h2><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行.加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑.</p>
<p>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span> locks A</span><br><span class="line">Thread <span class="number">2</span> locks B</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1</span> attempts to lock B but is blocked</span><br><span class="line">Thread <span class="number">2</span> attempts to lock A but is blocked</span><br><span class="line"></span><br><span class="line">Thread <span class="number">1&#x27;</span>s lock attempt on B times out</span><br><span class="line">Thread <span class="number">1</span> backs up <span class="keyword">and</span> releases A as well</span><br><span class="line">Thread 1 waits randomly (e.g. 257 millis) before retrying.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2&#x27;</span>s lock attempt on A times out</span><br><span class="line">Thread <span class="number">2</span> backs up <span class="keyword">and</span> releases B as well</span><br><span class="line">Thread 2 waits randomly (e.g. 43 millis) before retrying.</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。</p>
<p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p>
<p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。(超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题。)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">操作系统-概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-27 11:03:32" itemprop="dateCreated datePublished" datetime="2019-11-27T11:03:32+08:00">2019-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2019/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统-概论" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现代计算机系统是一个复杂的系统，为了管理这些设备，为用户程序提供一个更清晰，更简便的计算机模型，计算机安装了一层软件：<strong>操作系统</strong>。</p>
<p>用户与操作系统交互的程序有两种（用户接口程序并不属于操作系统的一部分）：</p>
<ul>
<li>Shell：基于文本；</li>
<li>GUI（Graphical User Interface）：基于图形。</li>
</ul>
<p>在计算机系统中操作系统所处的位置如下图：</p>
<p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%8D%E7%BD%AE.jpg" alt="操作系统位置"></p>
<ul>
<li>内核态的操作系统拥有对所有硬件的完全访问权，可以执行机器能够运行的任何指令；</li>
<li>用户态只使用了机器指令的一个子集。</li>
</ul>
<p>用户接口程序（Shell，GUI）允许用户运行其他程序。</p>
<h2 id="扩展机器"><a href="#扩展机器" class="headerlink" title="扩展机器"></a>扩展机器</h2><p>抽象是管理复杂性的一个关键。以SATA硬盘为例，在硬件层面其接口及其复杂，而且经过不停地修改，因此提供了一个叫做<strong>硬盘驱动</strong>的软件来与硬盘交互，这类软件提供了读写硬盘的接口，而不需要深入细节。即使在这个层面，对大多数应用来说还是太底层了，因此，所有的操作系统都提供了使用硬盘的另一层抽象：<strong>文件</strong>。</p>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><p>从这个角度看，操作系统的任务是在相互竞争的程序之间有序地控制对硬件设备资源的分配。它记录着哪个程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不同的程序和用户调解互相冲突的资源请求。</p>
<h1 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU是“Center Process Unit”缩写，CPU与电路进行电信号交换，而且对于电信号，只能识别ON和OFF两种状态。</p>
<p>如果把电信号的开（ON）/关（OFF）与数字0和1对应起来，就能将二进制数转换为电信号，同时电信号也可以转换回二进制数。因为我们可以把十进制数转换成二进制数，也能把二进制数还原成十进制数，所以人们发明了普通的计算机。</p>
<p>当给每个文字编码，将之与二进制数字对应起来，就可以把文字也转换成电信号，让CPU来处理文字。依此类推，人们接着又找到了将图像、音乐等等转换成电信号的方法，使CPU的应用范围越来越广。不过CPU还是一如既往，只能处理电信号。</p>
<p>CPU能处理的并不仅仅只有数据，还可以用电信号向CPU发出指令。我们所编写的程序最终都要转换成所谓的机器语言，这些机器语言就是以电信号的形式发送给CPU的。这些机器语言不过就是一连串的指令代码，实际上也就是一串0和1的组合而已。</p>
<p>CPU从内存中取出指令并执行，在每个CPU的周期中，计算机首先从内存中取出指令，解码以确定其类型和操作数，然后执行，然后取指，解码并执行下一条指令。</p>
<p>每种CPU都有一套专用的可执行的指令集。由于用来访问内存以得到指令的或数据的时间要比执行指令花费的时间长得多，因此CPU都有用于保存关键变量的临时数据的通用寄存器。</p>
<p>此外还有一些专用寄存器：</p>
<ul>
<li>程序计数器：指向下一条指令的地址；</li>
<li>堆栈指针：指向内存中当前栈的顶端；</li>
<li>程序状态字（Program Status Word，PSW）：包含条件码位，CPU优先级，模式（用户态/内核态），以及其他的控制位。</li>
</ul>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">典型访问时间</th>
<th align="center">典型容量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">寄存器</td>
<td align="center">1ns</td>
<td align="center">&lt;1KB</td>
</tr>
<tr>
<td align="center">高速缓存</td>
<td align="center">2ns</td>
<td align="center">4MB</td>
</tr>
<tr>
<td align="center">主存</td>
<td align="center">10ns</td>
<td align="center">1-16GB</td>
</tr>
<tr>
<td align="center">磁盘</td>
<td align="center">10ms</td>
<td align="center">1-nT</td>
</tr>
</tbody></table>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><h1 id="计算机启动"><a href="#计算机启动" class="headerlink" title="计算机启动"></a>计算机启动</h1><h2 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h2><ul>
<li>主引导扇区是硬盘0号柱面，0号磁道的第一个扇区，大小为512字节。</li>
<li>主引导记录（MBR），占用主引导扇区的前446字节，紧随其后的64字节是磁盘分区表DPT，最后还剩两个字节则恒为55AA，表示结束符号（Magic Number）。</li>
</ul>
<p>MBR，全称为Master Boot Record，即硬盘的主引导记录。MBR，共446字节，一般在操作系统安装时写入，但它并不属于操作系统。MBR就是一段引导程序，用于检测磁盘的分区合法性和加载操作系统，它的重要作用就是识别活动分区，并引导操作系统。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。</p>
<p>分区表DPT，共64字节，记录了硬盘有多少分区以及分区的各种属性。由于一个分区的信息要占用16字节，所以分区表只能定义4个分区，这就是为什么我们说硬盘一般最多只能分为4个主分区。</p>
<h2 id="主分区、扩展分区、逻辑分区"><a href="#主分区、扩展分区、逻辑分区" class="headerlink" title="主分区、扩展分区、逻辑分区"></a>主分区、扩展分区、逻辑分区</h2><p>主分区是由主引导扇区中64字节的分区表所定义的，最多只能有4个。但为了满足更多分区的需求，便产生了扩展分区。形式上，如果拥有扩展分区，就必须牺牲一个主分区，而且最多有一个扩展分区，也就是说：主分区+扩展分区&lt;=4 &amp;&amp; 扩展分区&lt;=1。因此扩展分区也可以看成一种特殊的主分区。</p>
<p>但扩展分区并不可以直接使用，扩展分区又必须以逻辑分区的形式出现，可以这样认为：扩展分区包含着若干逻辑分区，而且至少包含一个。</p>
<p>扩展分区中的逻辑分区是以链式存在的。即每一个逻辑分区都记录着下一个逻辑分区的位置信息，依次串联。事实上每一个逻辑分区都有一个和主引导扇区类似的引导扇区，引导扇区里有类似的分区表。该分区表记录了该分区的信息和一个指针，指向下一个逻辑分区的引导扇区。</p>
<p>因此，逻辑分区是借鉴了主分区的方法，相当于在一个主分区下面建立了若干级“主分区”。一个可以预测的现象是：一旦某一个逻辑分区损害，跟在它后面的所有逻辑分区都将丢失，而前面的逻辑分区去可以保留。这也是链式结果的特点。</p>
<h2 id="固件接口标准"><a href="#固件接口标准" class="headerlink" title="固件接口标准"></a>固件接口标准</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>IBM推出的业界标准的固件接口，存储于主板的ROM/EEPROM/flash中，提供的功能包括：</p>
<ul>
<li>开机自检</li>
<li>加载引导程序（MBR中的，通常是bootloader的第一级）</li>
<li>向OS提供抽象的硬件接口</li>
</ul>
<p>PS：CMOS是PC上的另一个重要的存储器，用于保存BIOS的设置结果，CMOS是RAM。</p>
<p>在每台计算机上有一块“双亲板”，其上有一个称为BIOS（Basic Input Output System）的程序。</p>
<p>在计算机启动时，BIOS开始运行。它首先检查所安装的RAM数量，键盘和其他设备是否已安装且正常响应。接着它开始扫描PCIe和PCI总线并找出连在上面的所有设备。</p>
<p>然后BIOS通过存储在CMOS存储器中的设备清单决定启动设备。用户可以在系统刚刚启动的时候进入一个BIOS配置程序，对设备清单进行修改。</p>
<p>然后操作系统询问BIOS，以获取配置信息。对于每种设备，系统检查对应的设备驱动程序是否存在。如果没有，系统要求用户插入含有该设备驱动程序的CD-ROM（由设备供应商提供）或者从网络上下载驱动程序。一旦拥有全部的设备驱动程序，操作系统将它们调入内核，然后初始化有关表格，创建需要的任何背景进程，并在每个终端上启动登录程序或者GUI。</p>
<h3 id="EFI-UEFI"><a href="#EFI-UEFI" class="headerlink" title="EFI/UEFI"></a>EFI/UEFI</h3><p>Unified Extensible Firmware Interface，架设在系统固件之上的软件接口，用于替代BIOS接口，EFI是UEFI的前称。</p>
<p>一般认为，UEFI由以下几个部分组成：</p>
<ul>
<li>Pre-EFI初始化模块</li>
<li>EFI驱动程序执行环境（DXE）</li>
<li>EFI驱动程序</li>
<li>兼容性支持模块（CSM）</li>
<li>EFI高层应用</li>
<li>GUID磁盘分区表（GPT）</li>
</ul>
<p>通常初始化模块和DXE被集成在一个ROM中；EFI驱动程序一般在设备的ROM中，或者ESP中；EFI高层应用一般在ESP中。CSM用于给不具备UEFI引导能力的操作系统提供类似于传统BIOS的系统服务。</p>
<h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="Legacy-mode"><a href="#Legacy-mode" class="headerlink" title="Legacy mode"></a>Legacy mode</h3><p>即通过MBR/BIOS进行引导的传统模式，流程如下：</p>
<ol>
<li>BIOS加电自检（Power On Self Test – POST）。</li>
<li>读取主引导记录（MBR）。BIOS根据CMOS中的设置依次检查启动设备：将相应启动设备的第一个扇区（也就是MBR扇区）读入内存。</li>
<li>检查MBR的结束标志位是否等于55AA，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。</li>
<li>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备的MBR。</li>
<li>根据MBR中的引导代码启动引导程序。</li>
</ol>
<h3 id="UEFI-mode"><a href="#UEFI-mode" class="headerlink" title="UEFI mode"></a>UEFI mode</h3><p>UEFI启动不依赖于Boot Sector（比如MBR），大致流程如下：</p>
<ol>
<li>Pre-EFI初始化模块运行，自检</li>
<li>加载DXE（EFI驱动程序执行环境），枚举并加载EFI驱动程序（设备ROM或ESP中）</li>
<li>找到ESP中的引导程序，通过其引导操作系统。</li>
</ol>
<h3 id="CSM-mode"><a href="#CSM-mode" class="headerlink" title="CSM mode"></a>CSM mode</h3><p>UEFI中的兼容性支持模块（Compatible Support Module）提供了引导UEFI固件的PC上的传统磁盘（MBR格式）的方法。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><h3 id="MBR分区表"><a href="#MBR分区表" class="headerlink" title="MBR分区表"></a>MBR分区表</h3><p>指的是512字节的Master Boot Record（主引导记录）中的分区表，由于大小限制，其中只能存有最多四个分区的描述（亦即4个主分区）。</p>
<h3 id="EBR分区表"><a href="#EBR分区表" class="headerlink" title="EBR分区表"></a>EBR分区表</h3><p>位于Extended Boot Record（扩展引导纪录）中的分区表，该分区表所描述的分区即扩展分区。每个EBR仅表示了一个扩展分区，该扩展分区紧接在它的EBR后。EBR中的四个分区描述符中的第一个表示其描述的分你去，第二个描述符则表示下一个扩展分区（如果是最后一个则为空），也就是说，各个EBR串接成了一个EBR链表。</p>
<h3 id="GPT分区表"><a href="#GPT分区表" class="headerlink" title="GPT分区表"></a>GPT分区表</h3><p>GUID Partition Table，是EFI标准的一部分，用于替代MBR分区表，相较起来有分区更大，数量更多（没有4个主分区的限制）等优势，GPT格式的硬盘结构如下，可以看到首部MBR的位置有个保护MBR（用于防止不识别GPT的硬盘工具错误识别并破坏硬盘中的数据），这个MBR中只有一个类型为0xEE的分区。</p>
<h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p>Bootloader即引导程序，用于启动操作系统或者其它引导程序（比如Grub启动Windows Bootmgr）</p>
<h3 id="Grub"><a href="#Grub" class="headerlink" title="Grub"></a>Grub</h3><p>GNU的开源引导程序，可以用于引导Linux等操作系统，或者用于链式引导其它引导程序（比如Windows Boot Manager），分为三个部分，分别称为步骤1、1.5、2，看名字就可以知道，步骤1.5是可有可没有的，这三个步骤对应的文件分别是：</p>
<ul>
<li>Boot.img：步骤1对应的文件，446个字节大小，步骤1可以引导步骤1.5也可以引导步骤2。MBR分区格式的磁盘中，放在MBR里（446也是为了符合MBR的启动代码区大小）；GPT分区格式的磁盘中，放在Protective MBR中。</li>
<li>Core.img：步骤1.5对应的文件，32256字节大小。MBR分区格式的磁盘中，放在紧邻MBR的若干扇区中；GPT分区格式的磁盘中，则放在34号扇区开始的位置（第一个分区所处的位置），而对应的GPT分区表中的第一个分区的entry被置空。通常其中包含文件系统驱动以便load步骤2的文件。</li>
<li>/boot/grub：步骤2对应的文件目录，放在系统分区或者单独的Boot分区中</li>
</ul>
<h3 id="Windows-Boot-Manager"><a href="#Windows-Boot-Manager" class="headerlink" title="Windows Boot Manager"></a>Windows Boot Manager</h3><p>是从Windows Vista开始引进的新一代开机管理程序，用以取代NTLDR。</p>
<p>当电脑运行完开机自检后，传统型BIOS会根据引导扇区查找开机硬盘中标记”引导”分区下的BOOTMGR文件；若是UEFI则是Bootmgfw.efi文件和Bootmgr.efi文件，接着管理程序会读取开机配置数据库（BCD, Boot Configuration Database）下的引导数据，接着根据其中的数据加载与默认或用户所选择的操作系统。</p>
<h1 id="操作系统大观"><a href="#操作系统大观" class="headerlink" title="操作系统大观"></a>操作系统大观</h1><ul>
<li>大型机操作系统</li>
<li>服务器操作系统</li>
<li>多处理器操作系统</li>
<li>个人计算机操作系统</li>
<li>掌上计算机操作系统</li>
<li>嵌入式操作系统</li>
<li>传感器节点操作系统</li>
<li>实时操作系统</li>
<li>智能卡操作系统</li>
</ul>
<h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h2><p>整个操作系统在内核态以单一程序的方式运行，整个操作系统以过程集合的方式编写，首先编译单个过程，然后链接成一个大型可执行二进制程序。使用这种技术，系统中的每个过程可以自由调用其他过程，但无数个不受限制地彼此调用的过程显得过于笨拙，而且任何一个过程的崩溃都会连累整个接口。</p>
<p>许多操作系统支持可装载的扩展，在UNIX中称为<strong>共享库（Shared Library，so）</strong>，在Windows中称为<strong>动态链接库（Dynamic Link Library，dll）</strong>。</p>
<p>在单体系统中也可能有一些结构存在。</p>
<h2 id="层次系统"><a href="#层次系统" class="headerlink" title="层次系统"></a>层次系统</h2><p>将单体系统中的结构进一步通用化，就变成一个层次式的系统。THE操作系统结构如下：</p>
<p><img src="THE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpg" alt="THE操作系统结构"></p>
<h2 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h2><p>微内核的设计思想：为了实现高可靠性，将操作系统划分为小的，定义良好的模块，只有其中一个模块——微内核，运行在内核态，其余的模块作为普通用户进程运行。</p>
<p>由于把每个设备驱动和文件系统分别作为普通用户进程，当这些模块发生错误时不会造成整个系统的崩溃。</p>
<p>当然，微内核由于增加了许多系统调用，因此性能上可能会有所下降。</p>
<h2 id="客户端-服务器模式"><a href="#客户端-服务器模式" class="headerlink" title="客户端-服务器模式"></a>客户端-服务器模式</h2><p>这个模式可以看成是微内核的变体。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>分层系统可延伸为虚拟机概念，虚拟机的基本思想是单个计算机的硬件抽象为几个不同的执行部件从而使得仿佛每个独立的执行环境都在自己的计算机运行一样。通过cpu调度和虚拟内存技术，操作系统能带来一种幻觉，即进程认为有自己的处理器和自己的（虚拟）内存。</p>
<ul>
<li>非虚拟机：进程→内核-硬件</li>
<li>虚拟机：进程→内核→虚拟机实现→硬件</li>
</ul>
<p>创建虚拟机的原因：最根本的是，在并行运行几个不同的执行环境（即不同的操作系统）能共享相同的硬件。</p>
<p>虚拟机方法的主要困难在于磁盘系统。解决方法是提供虚拟磁盘。</p>
<p>底层机器有两种模式：用户模式和内核模式。</p>
<p>虚拟机软件可以运行在内核模式，因为它就是操作系统，虚拟机本身只能运行在用户模式，但他必须有虚拟用户模式和虚拟内核模式。这两种模式都运行在物理用户模式。</p>
<p>虚拟模式的转换可按下述方法实现。例如，当以一个虚拟用户模式而在虚拟机上运行的程序执行系统调用时，他会在真正机器上引起一个到虚拟机监控器的转换。当虚拟机监控器获得控制，他能改变虚拟机的寄存器内容和程序计数器以模拟系统调用的效果。接着他能重新启动虚拟机，注意他现在是在虚拟机内核模式下执行。</p>
<p>实例：VMWare，Java VM</p>
<h1 id="操作系统和内核"><a href="#操作系统和内核" class="headerlink" title="操作系统和内核"></a>操作系统和内核</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>操作系统：管理计算机硬件与软件资源的系统软件，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。对我们来说，操作系统最直观的感受就是桌面系统，以及上层的应用程序，而后面的资源处理等等就是操作系统背后的黑盒。</li>
<li>内核：一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。内核是操作系统最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。直接对硬件操作是非常复杂的，所以内核通常提供一种硬件抽象的方法来完成这些操作。硬件抽象隐藏了复杂性，为应用软件和硬件提供了一套简洁，统一的接口，使程序设计更为简单。简单来说，内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。内核就是操作系统背后黑盒的核心。</li>
</ul>
<p>它们的关系如下图：</p>
<p><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%86%85%E6%A0%B8.jpg" alt="操作系统和内核"></p>
<h2 id="内核的分类"><a href="#内核的分类" class="headerlink" title="内核的分类"></a>内核的分类</h2><h3 id="宏内核（单内核）"><a href="#宏内核（单内核）" class="headerlink" title="宏内核（单内核）"></a>宏内核（单内核）</h3><p>内核管理着操作系统的内存，文件，IO，网络等等，每个功能可以看做一个模块，在宏内核中，这些模块都是集成在一起的，运行在内核进程中，模块之间的交互直接通过方法调用。如下图：</p>
<p><img src="%E5%AE%8F%E5%86%85%E6%A0%B8.jpg" alt="宏内核"></p>
<h3 id="微内核-1"><a href="#微内核-1" class="headerlink" title="微内核"></a>微内核</h3><p>在微内核中，内核只提供最核心的功能，比如任务调度，内存管理等等，其他模块被移出内核，运行在不同的进程中，这样即使某一个模块出现问题，只要重启这个模块的进程即可，不会影响到其他模块，稳定性大大增加。甚至可以在系统运行过程中替换现有模块的实现。而且由于模块独立的性质，可以做到模块的按需加载。但是模块间的相互调用需要通过进程间通信，通信效率相对较低。如下图：</p>
<p><img src="%E5%BE%AE%E5%86%85%E6%A0%B8.jpg" alt="微内核"></p>
<h3 id="混合内核"><a href="#混合内核" class="headerlink" title="混合内核"></a>混合内核</h3><p>宏内核和微内核各有千秋，也各有缺点，所以混合内核就是集中了两者的特点，让微内核中的一些核心模块运行在内核中，从而使内核效率更高一些。</p>
<h3 id="外内核"><a href="#外内核" class="headerlink" title="外内核"></a>外内核</h3><p>外内核是把硬件暴露给应用程序，应用程序可以直接访问硬件，外内核对系统提供保护。目前还在研究阶段。</p>
<h2 id="宏内核-微内核对比"><a href="#宏内核-微内核对比" class="headerlink" title="宏内核/微内核对比"></a>宏内核/微内核对比</h2><table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">宏内核</th>
<th align="center">微内核</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通信效率</td>
<td align="center">高（函数调用）</td>
<td align="center">低（进程间通信）</td>
</tr>
<tr>
<td align="center">稳定性</td>
<td align="center">低（模块集成在一起）</td>
<td align="center">高（模块间互不影响）</td>
</tr>
<tr>
<td align="center">扩展性</td>
<td align="center">低（模块集成在一起）</td>
<td align="center">高（模块间互不影响）</td>
</tr>
<tr>
<td align="center">代码量</td>
<td align="center">多（需要实现所有模块）</td>
<td align="center">少（只需要实现核心功能）</td>
</tr>
</tbody></table>
<h2 id="主流操作系统内核"><a href="#主流操作系统内核" class="headerlink" title="主流操作系统内核"></a>主流操作系统内核</h2><p>宏内核：</p>
<ul>
<li>Linux</li>
<li>Windows 9X 系列</li>
<li>MacOS 8.6 版本之前</li>
</ul>
<p>微内核：</p>
<ul>
<li>Fuchsia</li>
<li>鸿蒙</li>
<li>Minix</li>
</ul>
<p>混合内核：</p>
<ul>
<li>Windows XP</li>
<li>Windows 7</li>
<li>Mac OS X</li>
<li>XNU</li>
</ul>
<p>外内核：</p>
<ul>
<li>Nemesis</li>
</ul>
<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><h2 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h2><p>熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于内核功能，因为它要做很多底层的工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。</p>
<p>特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于 Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。</p>
<h2 id="用户态和内核态-1"><a href="#用户态和内核态-1" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。</p>
<p>虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的testfork()就不能直接调用 sys_fork()，因为前者是工作在用户态，属于用户态程序，而sys_fork()是工作在内核态，属于内核态程序。</p>
<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。</p>
<h1 id="同步-异步和阻塞-非阻塞"><a href="#同步-异步和阻塞-非阻塞" class="headerlink" title="同步/异步和阻塞/非阻塞"></a>同步/异步和阻塞/非阻塞</h1><ul>
<li>同步、异步：涉及到IO通知机制。所谓同步，就是发起调用后，被调用者处理消息，必须等处理完才直接返回结果，没处理完之前是不返回的，调用者主动等待结果；所谓异步，就是发起调用后，被调用者直接返回，但是并没有返回结果，等处理完消息后，通过状态、通知或者回调函数来通知调用者，调用者被动接收结果。</li>
<li>阻塞、非阻塞：涉及到CPU线程调度。所谓阻塞，就是调用结果返回之前，该执行线程会被挂起，不释放CPU执行权，线程不能做其它事情，只能等待，只有等到调用结果返回了，才能接着往下执行；所谓非阻塞，就是在没有获取调用结果时，不是一直等待，线程可以往下执行，如果是同步的，通过轮询的方式检查有没有调用结果返回，如果是异步的，会通知回调。</li>
<li>同步阻塞：老张在厨房用普通水壶烧水，一直在厨房等着（阻塞），盯到水烧开（同步）；</li>
<li>异步阻塞：老张在厨房用响水壶烧水，一直在厨房中等着（阻塞），直到水壶发出响声（异步），老张知道水烧开了；</li>
<li>同步非阻塞：老张在厨房用普通水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），然后时不时去厨房看看水烧开了没（轮询检查同步结果）；</li>
<li>异步非阻塞：老张在厨房用响水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），当水壶发出响声（异步），老张就知道水烧开了。</li>
</ul>
<h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><p>POSIX，<code>Portable Operating System Interface</code>（可移植操作系统接口）。是UNIX系统的一个设计标准，很多类UNIX系统也在支持兼容这个标准，如Linux，遵循这个标准的好处是软件可以跨平台。</p>
<p>从Unix之后出现了许多独立开发的与Unix类似但又不完全兼容的OS，通称Unix-like OS。局面非常混乱，为了提高兼容性和应用程序的可移植性，标准化Unix-like OS，提出了大家都应该遵守的POSIX标准。后来，Unix这个名字成为了商标，只有花钱进行POSIX标准兼容性测试并通过了的OS，才能称为Unix，其余的OS，最多称为Unix-like OS。</p>
<p>Windows从WinNT开始就有兼容POSIX的考虑，因为当年在要求严格的领域，Unix地位比Windows高。</p>
<p>一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。一个API定义了一组应用程序使用的编程接口，它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，也可以完全不使用任何系统调用。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</p>
<p>完成同一功能，不同内核提供的系统调用（也就是一个函数）是不同的，例如创建进程，linux下是fork函数，windows下是creatprocess函数。为了解决跨平台的问题，linux和windows等都要实现基本的posix标准，linux把fork函数以及windows把creatprocess函数封装成同一个函数，都声明在unistd.h里。这样，程序员编写普通应用时候，只用包含unistd.h，然后调用这个封装后的函数，程序就在源代码级别可移植了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Glide源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-18 11:17:38" itemprop="dateCreated datePublished" datetime="2019-11-18T11:17:38+08:00">2019-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
                </span>
            </span>

          
            <span id="/2019/11/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="Glide源码解析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Glide是一个快速高效的Android图片加载库，提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>
<p>Glide 支持拉取，解码和展示视频快照，图片，和GIF动画，开发者可以将 Glide 网络请求从 HttpUrlConnection 替换成如 Google Volley 和 Square OkHttp 这样的工具库。Glide 提供了多种图片格式的缓存，可以感知Activity/Fragment的生命周期。能够复用和主动回收Bitmap，以及带有高效的缓存策略，减小了内存的开销。</p>
<p>本文基于 Glide 4.11.0 版本，参考网上一些解析，结合源码对 Glide 的机制做一个分析。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/11/18/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/app-process%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/app-process%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">app_process使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-11 20:56:02" itemprop="dateCreated datePublished" datetime="2019-11-11T20:56:02+08:00">2019-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">实战</span></a>
                </span>
            </span>

          
            <span id="/2019/11/11/app-process%E4%BD%BF%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="app_process使用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/11/app-process%E4%BD%BF%E7%94%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/11/app-process%E4%BD%BF%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>app_process是Android原生的一个可执行程序，位于/system/bin目录下，zygote进程便是由这个执行文件启动的。</p>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage: app_process [java-options] cmd-dir start-class-name [options]</span><br><span class="line"></span><br><span class="line">    java-options     - 传递给 JVM 的参数</span><br><span class="line">    cmd-dir          - 命令执行路径</span><br><span class="line">    start-class-name - 程序入口， main() 方法所在的类名</span><br><span class="line">    options          - 可以是下面这些</span><br><span class="line">                        --zygote 启动 zygote 进程用的</span><br><span class="line">                        --start-system-server 启动系统服务(也是启动 zygote 进程的时候用的)</span><br><span class="line">                        --application 启动应用程序</span><br><span class="line">                        --nice-name= 启动之后的进程名称</span><br></pre></td></tr></table></figure>

<p>app_process没有帮助程序，但是可以从<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp">源代码</a>进行分析：</p>
<ul>
<li>传入 –zygote 会启动 com.android.internal.os.ZygoteInit，否则启动 com.android.internal.os.RuntimeInit。</li>
<li>–start-system-server 只在启动 zygote 时有效。</li>
<li>在非 zygote 模式中，有无 –application 的选项的区别只是是否将 stdout 和 stderr 重定向到 AndroidPrintStream。</li>
<li>只有在非 zygote 的情况下，–nice-name= 选项有效。</li>
</ul>
<p>与 Java 相似， Android 支持在环境变量 CLASSPATH 中指定类搜索路径 (CLASSPATH)，此外还可以在虚拟机参数中指定 <code>-Djava.class.path=</code> 。但是， Android 使用 ART 环境运行 Java ，传统的 Java 字节码文件(.class) 是不能直接运行的，app_process 支持在 CLASSPATH 中指定 dex 或 apk 文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 dex</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CLASSPATH=/sdcard/app.dex</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> app_process /system/bin com.hearing.Main</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> app_process -Djava.class.path=/sdcard/app.dex /system/bin com.hearing.Main</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 apk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CLASSPATH=/sdcard/app.apk</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> app_process /system/bin com.hearing.Main</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> app_process -Djava.class.path=/sdcard/app.apk /system/bin com.hearing.Main</span></span><br></pre></td></tr></table></figure>

<h1 id="实例-C-S静默卸载"><a href="#实例-C-S静默卸载" class="headerlink" title="实例-C/S静默卸载"></a>实例-C/S静默卸载</h1><p>通过adb的方式由app_process开启一个Server，客户端通过Socket与之连接并调用需要系统权限的功能。（需要手动adb启动Server，实际可行性不大，并不能实现自动化启动）（如果在代码里自动调用app_process启动Server，该Server进程并不能获得系统权限）</p>
<h2 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用looper让线程循环</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        System.out.println(<span class="string">&quot;*****************hack server starting****************&quot;</span>);</span><br><span class="line">        <span class="comment">// 开一个子线程启动服务</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> SocketService(<span class="keyword">new</span> SocketService.SocketListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">onMessage</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 接收客户端传过来的消息</span></span><br><span class="line">                        <span class="keyword">return</span> resolveMsg(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">resolveMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行客户端传过来的消息并返回执行结果</span></span><br><span class="line">        ShellUtil.ExecResult execResult = ShellUtil.execute(<span class="string">&quot;pm uninstall &quot;</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> execResult.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10500</span>;</span><br><span class="line">    <span class="keyword">private</span> SocketListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketService</span><span class="params">(SocketListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 利用ServerSocket类启动服务，然后指定一个端口</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">&quot;server running &quot;</span> + PORT + <span class="string">&quot; port&quot;</span>);</span><br><span class="line">            ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 新建一个线程池用来并发处理客户端的消息</span></span><br><span class="line">            ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">5000</span>, TimeUnit.MILLISECONDS, queue);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">// 接收到新消息</span></span><br><span class="line">                executor.execute(<span class="keyword">new</span> MsgProcess(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;SocketServer create Exception:&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MsgProcess</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MsgProcess</span><span class="params">(Socket s)</span> </span>&#123;</span><br><span class="line">            socket = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过流读取内容</span></span><br><span class="line">                BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String line = bufferedReader.readLine();</span><br><span class="line">                System.out.println(<span class="string">&quot;server receive: &quot;</span> + line);</span><br><span class="line">                PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                String repeat = listener.onMessage(line);</span><br><span class="line">                System.out.println(<span class="string">&quot;server send: &quot;</span> + repeat);</span><br><span class="line">                <span class="comment">// 服务端返回给客户端的消息</span></span><br><span class="line">                printWriter.print(repeat);</span><br><span class="line">                printWriter.flush();</span><br><span class="line">                printWriter.close();</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;socket connection error：&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SocketListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通话消息回调</span></span><br><span class="line">        <span class="function">String <span class="title">onMessage</span><span class="params">(String text)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;HackRoot SocketClient&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10500</span>;</span><br><span class="line">    <span class="keyword">private</span> SocketListener listener;</span><br><span class="line">    <span class="keyword">private</span> PrintWriter printWriter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(<span class="keyword">final</span> String cmd, SocketListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 与hackserver建立连接</span></span><br><span class="line">                    socket.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT), <span class="number">3000</span>);</span><br><span class="line">                    socket.setSoTimeout(<span class="number">3000</span>);</span><br><span class="line">                    printWriter = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;client send: &quot;</span> + cmd);</span><br><span class="line">                    <span class="comment">// 发送指令</span></span><br><span class="line">                    printWriter.println(cmd);</span><br><span class="line">                    printWriter.flush();</span><br><span class="line">                    <span class="comment">// 读取服务端返回</span></span><br><span class="line">                    readServerData(socket);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;client send fail: &quot;</span> + e.getMessage());</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readServerData</span><span class="params">(<span class="keyword">final</span> Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStreamReader ipsReader = <span class="keyword">new</span> InputStreamReader(socket.getInputStream());</span><br><span class="line">            BufferedReader bfReader = <span class="keyword">new</span> BufferedReader(ipsReader);</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = bfReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;client receive: &quot;</span> + line);</span><br><span class="line">                listener.onMessage(line);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            ipsReader.close();</span><br><span class="line">            bfReader.close();</span><br><span class="line">            printWriter.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">SocketListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ShellUtil"><a href="#ShellUtil" class="headerlink" title="ShellUtil"></a>ShellUtil</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMAND_LINE_END = <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMAND_EXIT = <span class="string">&quot;exit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runShell</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder mShellCommandSB = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(<span class="string">&quot;runShell: &quot;</span> + command);</span><br><span class="line">        mShellCommandSB.delete(<span class="number">0</span>, mShellCommandSB.length());</span><br><span class="line">        String[] cmd = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;/system/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, command&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    process.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mShellCommandSB.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;runShell result: &quot;</span> + mShellCommandSB.toString());</span><br><span class="line">            process.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (process != <span class="keyword">null</span>) &#123;</span><br><span class="line">                process.destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecResult <span class="title">execute</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> String[]&#123;command&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecResult <span class="title">execute</span><span class="params">(String[] commands)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (commands == <span class="keyword">null</span> || commands.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecResult(<span class="keyword">false</span>, <span class="string">&quot;empty command&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader sucResult = <span class="keyword">null</span>, errResult = <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sucMsg = <span class="keyword">null</span>, errMsg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取shell级别的process</span></span><br><span class="line">            process = Runtime.getRuntime().exec(<span class="string">&quot;sh&quot;</span>);</span><br><span class="line">            dataOutputStream = <span class="keyword">new</span> DataOutputStream(process.getOutputStream());</span><br><span class="line">            <span class="keyword">for</span> (String command : commands) &#123;</span><br><span class="line">                <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;execute command: &quot;</span> + command);</span><br><span class="line">                <span class="comment">// 执行指令</span></span><br><span class="line">                dataOutputStream.write(command.getBytes());</span><br><span class="line">                dataOutputStream.writeBytes(COMMAND_LINE_END);</span><br><span class="line">                <span class="comment">// 刷新</span></span><br><span class="line">                dataOutputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            dataOutputStream.writeBytes(COMMAND_EXIT);</span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">            result = process.waitFor();</span><br><span class="line">            sucMsg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            errMsg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sucResult = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()));</span><br><span class="line">            errResult = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">            String s;</span><br><span class="line">            <span class="keyword">while</span> ((s = sucResult.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sucMsg.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((s = errResult.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                errMsg.append(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 关闭资源，防止内存泄漏</span></span><br><span class="line">                <span class="keyword">assert</span> dataOutputStream != <span class="keyword">null</span>;</span><br><span class="line">                dataOutputStream.close();</span><br><span class="line">                <span class="keyword">assert</span> sucResult != <span class="keyword">null</span>;</span><br><span class="line">                sucResult.close();</span><br><span class="line">                <span class="keyword">assert</span> errResult != <span class="keyword">null</span>;</span><br><span class="line">                errResult.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            process.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        ExecResult execResult;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            execResult = <span class="keyword">new</span> ExecResult(<span class="keyword">true</span>, sucMsg.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            execResult = <span class="keyword">new</span> ExecResult(<span class="keyword">false</span>, errMsg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> execResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecResult</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExecResult</span><span class="params">(<span class="keyword">boolean</span> success, String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.success = success;</span><br><span class="line">            <span class="keyword">this</span>.message = message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.success;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul>
<li>通过app_process部署Server；</li>
<li>客户端通过调用SocketClient中的方法，向Server端发送想要执行的命令即可。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/01/Android-Security/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/01/Android-Security/" class="post-title-link" itemprop="url">Android-Security</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-01 10:39:12" itemprop="dateCreated datePublished" datetime="2019-11-01T10:39:12+08:00">2019-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
            </span>

          
            <span id="/2019/11/01/Android-Security/" class="post-meta-item leancloud_visitors" data-flag-title="Android-Security" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/11/01/Android-Security/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/11/01/Android-Security/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过将传统的操作系统安全控制机制扩展到以下用途，Android 致力于成为最安全、最实用的移动平台操作系统：</p>
<ul>
<li>保护应用和用户数据</li>
<li>保护系统资源（包括网络）</li>
<li>将应用同系统、其他应用和用户隔离开来</li>
</ul>
<p>为了实现这些目标，Android 提供了以下关键安全功能：</p>
<ul>
<li>通过 Linux 内核在操作系统级别提供的强大安全功能</li>
<li>针对所有应用的强制性应用沙盒</li>
<li>安全的进程间通信</li>
<li>应用签名</li>
<li>应用定义的权限和用户授予的权限</li>
</ul>
<h1 id="Linux安全"><a href="#Linux安全" class="headerlink" title="Linux安全"></a>Linux安全</h1><p>Linux在历经无数攻击以及成千上万的开发者的不断研究和修复之后，其安全性不言而喻，作为移动计算环境的基础，Linux 内核为 Android 提供了一些关键的安全功能，其中包括：</p>
<ul>
<li>基于用户的权限模式</li>
<li>进程隔离</li>
<li>用于实现安全 IPC 的可扩展机制</li>
<li>能够移除内核中不必要的和可能不安全的部分</li>
</ul>
<p>作为一种多用户操作系统，Linux 内核的一个基本安全目标是将用户资源彼此隔离开来。Linux 的安全理念是防范用户资源之间相互侵扰。因此，Linux 可以：</p>
<ul>
<li>防止用户 A 读取用户 B 的文件</li>
<li>确保用户 A 不会占用用户 B 的内存</li>
<li>确保用户 A 不会占用用户 B 的 CPU 资源</li>
<li>确保用户 A 不会占用用户 B 的设备（例如，电话、GPS、蓝牙）</li>
</ul>
<h1 id="应用沙盒"><a href="#应用沙盒" class="headerlink" title="应用沙盒"></a>应用沙盒</h1><p>Android 平台利用基于用户的 Linux 保护机制来识别和隔离应用资源，可将不同的应用分离开，并保护应用和系统免受恶意应用的攻击。为此，Android 会为每个 Android 应用分配一个独一无二的用户 ID (UID)，并在自己的进程中运行。</p>
<p>Android 会使用此 UID 设置一个<strong>内核级应用沙盒</strong>。内核会在进程级别利用标准的 Linux 机制（例如，分配给应用的用户 ID 和组 ID）实现应用和系统之间的安全防护。 默认情况下，应用不能彼此交互，而且对操作系统的访问权限会受到限制。例如，如果应用 A（一个单独的应用）尝试执行恶意操作，例如在没有权限的情况下读取应用 B 的数据或拨打电话，操作系统会阻止此类行为，因为应用 A 没有适当的用户权限。</p>
<p>由于应用沙盒位于内核层面，因此该安全模型的保护范围扩展到了原生代码和操作系统应用。位于更高层面的所有软件（例如，操作系统库、应用框架、应用运行时环境和所有应用）都会在应用沙盒中运行。</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/09/10/Android%E8%BF%9B%E7%A8%8B%E5%8F%8A%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">Android进程及消息机制</a></p>
<h1 id="应用签名"><a href="#应用签名" class="headerlink" title="应用签名"></a>应用签名</h1><p><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/08/26/Android%E7%AD%BE%E5%90%8D%E7%AC%94%E8%AE%B0/">Android签名</a></p>
<h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>SELinux：Security-Enhanced Linux，安全增强型 Linux，是一个 Linux 内核模块，也是 Linux 的一个安全子系统。SELinux 主要由美国国家安全局开发，2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。</p>
<p>SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。</p>
<h2 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h2><p>DAC（Discretionary Access Control，自主式访问控制）。</p>
<p>在没有使用 SELinux 的操作系统中，决定一个资源是否能被访问的因素是：依据程序的拥有者与文件资源的 rwx 权限来决定有无存取的能力，只要访问这个资源的用户符合以上的条件就可以被访问。</p>
<p>存在的问题：</p>
<ul>
<li>root 用户不受任何管制，系统上任何资源都可以无限制地访问。</li>
<li>如果不小心将某个目录的权限配置为 777 ，由于对任何人的权限会变成 rwx ，因此该目录的文件就会被任何人所任意存取执行。</li>
</ul>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC（Mandatory Access Control，委任式访问控制）。</p>
<p>在使用了 SELinux 的操作系统中，决定一个资源是否能被访问的因素除了上述因素之外，还需要判断每一类进程是否拥有对某一类资源的访问权限。这样一来，即使进程是以 root 身份运行的，也需要判断这个进程的类型以及允许访问的资源类型才能决定是否允许访问某个资源。进程的活动空间也可以被压缩到最小。即使是以 root 身份运行的服务进程，一般也只能访问到它所需要的资源。即使程序出了漏洞，影响范围也只有在其允许访问的资源范围内，安全性大大增加。</p>
<p>如此一来，我们针对控制的『主体』变成了『程序』而不是『使用者』了。此外，这个主体程序也不能任意使用系统文件资源，因为每个文件资源也有针对该主体程序配置可取用的权限，如此一来，控制项目就细的多了，但整个系统程序那么多、文件那么多，一项一项控制非常麻烦，所以 SELinux 也提供一些默认的策略 (Policy) ，并在该策略内提供多个rule，让你可以选择是否激活该控制rule。</p>
<p>在委任式存取控制的配置下，我们的程序能够活动的空间就变小了。举例来说，默认情况下，httpd 仅能在 /var/www/ 这个目录底下存取文件，如果 httpd 这个程序想要到其他目录去存取数据时，除了rule配置要开放外，目标目录也得要配置成 httpd 可读取的模式 (type) 才行。所以，即使不小心 httpd 被 cracker 取得了控制权，他也无权浏览 /etc/shadow 等重要的配置档。</p>
<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><ul>
<li>主体 (Subject)：SELinux 主要管理的就是程序，即process；</li>
<li>目标 (Object)：主体程序能否存取的『目标资源』一般就是文件系统；</li>
<li>政策 (Policy)：由於程序与文件数量庞大，因此 SELinux 会依据某些服务来制订基本的存取安全性政策。这些政策内还会有详细的守则 (rule) 来指定不同的服务开放某些资源的存取与否。</li>
<li>安全性上下文 (security context)：主体能不能存取目标除了政策指定之外，主体与目标的安全性上下文必须一致才能够顺利存取。这个安全性上下文 (security context) 有点类似文件系统的 rwx 啦，安全性上下文如果配置错误，你的某些服务(主体程序)就无法存取文件系统(目标资源)，就会一直出现『权限不符』的错误信息了。</li>
</ul>
<p>在目前的 CentOS 5.x 里面仅有提供两个主要的政策，分别是：</p>
<ol>
<li>targeted：针对网络服务限制较多，针对本机限制较少，是默认的政策；</li>
<li>strict：完整的 SELinux 限制，限制方面较为严格。</li>
</ol>
<p>建议使用默认的 targeted 政策即可。</p>
<p><img src="SELinux%E7%BB%84%E4%BB%B6.gif" alt="SELinux组件"></p>
<p>由上图我们可以发现，主体程序必须要通过 SELinux 政策内的守则放行后，就可以与目标资源进行安全性本文的比对，若比对失败则无法存取目标，若比对成功则可以开始存取目标。问题是，最终能否存取目标还是与文件系统的 rwx 权限配置有关,如此一来，加入了 SELinux 之后，出现权限不符的情况时，我们就得要一步一步的分析可能的问题了。</p>
<h1 id="sharedUserId"><a href="#sharedUserId" class="headerlink" title="sharedUserId"></a>sharedUserId</h1><p>Android给每个APK进程分配一个单独的空间，manifest中的userid就是对应一个分配的Linux用户ID，并且为它创建一个沙箱，以防止影响其他应用程序（或者其他应用程序影响它）。用户ID在应用程序安装到设备中时被分配，并且在这个设备中保持它的永久性。</p>
<p>通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，在保障了程序运行的稳定。然后在有些时候，我们自己开发了多个APK并且需要他们之间互相共享资源，那么就需要通过设置shareUserId来实现这一目的。</p>
<p>通过Shared User id，拥有同一个User id的多个APK可以配置成运行在同一个进程中。所以默认就是可以互相访问任意数据。也可以配置成运行成不同的进程，同时可以访问其他APK的数据目录下的数据库和文件。就像访问本程序的数据一样。</p>
<p>用法也很简单：</p>
<p>在需要共享资源的项目的每个AndroidMainfest.xml中添加shareuserId的标签。android:sharedUserId=”com.example”，id名自由设置，但必须保证每个项目都使用了相同的sharedUserId。一个mainfest只能有一个Shareuserid标签。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/29/Termux-AAB%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/29/Termux-AAB%E5%88%86%E4%BA%AB/" class="post-title-link" itemprop="url">Termux-AAB分享</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-29 09:42:30" itemprop="dateCreated datePublished" datetime="2019-10-29T09:42:30+08:00">2019-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">分享</span></a>
                </span>
            </span>

          
            <span id="/2019/10/29/Termux-AAB%E5%88%86%E4%BA%AB/" class="post-meta-item leancloud_visitors" data-flag-title="Termux-AAB分享" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/29/Termux-AAB%E5%88%86%E4%BA%AB/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/29/Termux-AAB%E5%88%86%E4%BA%AB/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Termux"><a href="#Termux" class="headerlink" title="Termux"></a>Termux</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Termux是一个Android下一个高级的终端模拟器，开源且不需要root，支持apt管理软件包，拥有自己的apt仓库源，可以十分方便地安装软件包，可以实现支持Python,PHP,Ruby,Go,Nodejs,MySQL等功能环境。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/termux/termux-app">仓库地址</a></p>
<h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><p>linux/unix下的哲学核心思想是<strong>一切皆文件</strong>。它指的是，对所有文件（目录、字符设备、块设备、套接字、打印机、进程、线程、管道等）操作，读写都可用<code>fopen()/fclose()/fwrite()/fread()</code>等函数进行处理，屏蔽了硬件的区别，所有设备都抽象成文件，提供统一的接口给用户，虽然类型各不相同，但是对其提供的却是同一套操作界面，更进一步，对文件的操作也可以跨文件系统执行。</p>
<p>操作一个已经打开的文件：使用文件描述符（file descriptor），简称fd，它是一个对应某个已经打开的文件的索引（非负整数）。</p>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</p>
<p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p>
<h2 id="Termux工作方式"><a href="#Termux工作方式" class="headerlink" title="Termux工作方式"></a>Termux工作方式</h2><h3 id="apt-amp-dpkg"><a href="#apt-amp-dpkg" class="headerlink" title="apt&amp;dpkg"></a>apt&amp;dpkg</h3><p>在Linux平台下使用源代码进行软件编译可以具有定制化的设置，但对于Linux distribution的发行商来说，毕竟不是每个人都会进行源代码编译的，这个问题将会严重的影响linux平台上软件的发行与推广。</p>
<p>为了解决上述的问题，厂商先在他们的系统上面编译好了用户所需要的软件，然后将这个编译好并可执行的软件直接发布给用户安装。不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营：Debian 的”.deb”，和 Red Hat的”.rpm”。</p>
<p>dpkg是Debian的一个底层包管理工具，主要用于对已下载到本地和已安装的软件包进行管理。</p>
<p>虽然我们在使用dpkg时，已经解决掉了软件安装过程中的大量问题，但是当依赖关系不满足时，仍然需要手动解决，而apt这个工具解决了这样的问题，linux distribution 先将软件放置到对应的服务器中，然后分析软件的依赖关系，并且记录下来，然后当客户端有安装软件需求时，通过清单列表与本地的dpkg以存在的软件数据相比较，就能从网络端获取所有需要的具有依赖属性的软件了。</p>
<p>Termux在它自己维护的apt源中有它编译好的deb软件包，这些deb针对的是 applicationId为 <code>com.termux</code> 的应用。</p>
<h3 id="Termux提供了什么"><a href="#Termux提供了什么" class="headerlink" title="Termux提供了什么"></a>Termux提供了什么</h3><ul>
<li>在Android Linux内核的基础上，提供了一些更为丰富的命令以及它们的依赖，比如说 bash（Android系统自带的shell是位于/system/bin下的sh，sh支持的功能比较有限），apt（可以说是对Android sh最为强大的扩展，通过apt可以安装编译好的各种软件，包括Python）。</li>
<li>通过在app的进程中fork子进程，通过文件操作开启一个终端，然后通过返回的文件描述符对终端进行操作，首先执行login（termux）或者bash（termux）或者sh（/system/bin/sh）命令，得到一个可执行shell操作的环境。后续才可继续进行安装python等操作。</li>
<li>为了支持这些扩展的命令，需要配置一些环境变量（包括Path等）。</li>
</ul>
<h2 id="修改包名"><a href="#修改包名" class="headerlink" title="修改包名"></a>修改包名</h2><p>为什么需要修改依赖的包名？</p>
<ul>
<li>termux-app 的 默认applicationId是 <code>com.termux</code>，如果需要修改applicationId的话，则需要重新编译所有的deb包以及提供一个apt源，并且重新生成bootstraps.zip</li>
</ul>
<p>Python官网的deb解包后目录结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">└─data</span><br><span class="line">    ├─usr</span><br><span class="line">    │  ├─bin</span><br><span class="line">    │  ├─lib</span><br><span class="line">    │  │  └─valgrind</span><br><span class="line">    │  └─share</span><br><span class="line">    │      ├─apps</span><br><span class="line">    │      │  └─konsole</span><br><span class="line">    │      ├─doc</span><br><span class="line">    │      │  └─python</span><br><span class="line">    │      ├─lintian</span><br><span class="line">    │      │  └─overrides</span><br><span class="line">    │      ├─man</span><br><span class="line">    │      │  └─man1</span><br><span class="line">    │      └─pixmaps</span><br></pre></td></tr></table></figure>

<p>termux 编译后的目录结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├─data</span><br><span class="line">│  └─data</span><br><span class="line">│      └─$pkg</span><br><span class="line">│          └─files</span><br><span class="line">│              └─usr</span><br><span class="line">│                  ├─bin</span><br><span class="line">│                  ├─include</span><br><span class="line">│                  │  └─python2.7</span><br><span class="line">│                  ├─lib</span><br><span class="line">│                  │  ├─pkgconfig</span><br><span class="line">│                  │  └─python2.7</span><br><span class="line">│                  └─share</span><br><span class="line">│                      ├─doc</span><br><span class="line">│                      │  └─python2</span><br><span class="line">│                      └─man</span><br><span class="line">│                          └─man1</span><br><span class="line">└─_</span><br></pre></td></tr></table></figure>

<p>修改方法：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/08/08/termux-app%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D">Termux修改包名</a></li>
</ul>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>流程图:</p>
<p><img src="Termux%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B.jpg" alt="Termux流程图"></p>
<h3 id="setupIfNeeded"><a href="#setupIfNeeded" class="headerlink" title="setupIfNeeded"></a>setupIfNeeded</h3><p>bootstraps.zip目录结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bootstrap-aarch64</span><br><span class="line">    ├── SYMLINKS.txt</span><br><span class="line">    ├── bin</span><br><span class="line">    ├── etc</span><br><span class="line">    ├── include</span><br><span class="line">    ├── lib</span><br><span class="line">    ├── libexec</span><br><span class="line">    ├── repo.asc</span><br><span class="line">    ├── share</span><br><span class="line">    ├── tmp</span><br><span class="line">    └── var</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILES_PATH = <span class="string">&quot;/data/data/$pkg/files&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX_PATH = FILES_PATH + <span class="string">&quot;/usr&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOME_PATH = FILES_PATH + <span class="string">&quot;/home&quot;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupIfNeeded</span><span class="params">(<span class="keyword">final</span> Activity activity, <span class="keyword">final</span> Runnable whenDone)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Termux can only be run as the primary user (device owner) since only that</span></span><br><span class="line">    <span class="comment">// account has the expected file system paths. Verify that:</span></span><br><span class="line">    UserManager um = (UserManager) activity.getSystemService(Context.USER_SERVICE);</span><br><span class="line">    <span class="keyword">boolean</span> isPrimaryUser = um.getSerialNumberForUser(android.os.Process.myUserHandle()) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isPrimaryUser) &#123;</span><br><span class="line">        Termux.mInstance.setInstalled(<span class="keyword">false</span>);</span><br><span class="line">        Termux.mInstance.getTermuxHandle().initFail();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File PREFIX_FILE = <span class="keyword">new</span> File(Termux.PREFIX_PATH);</span><br><span class="line">    <span class="keyword">if</span> (PREFIX_FILE.isDirectory()) &#123;</span><br><span class="line">        whenDone.run();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> String STAGING_PREFIX_PATH = Termux.FILES_PATH + <span class="string">&quot;/usr-staging&quot;</span>;</span><br><span class="line">                <span class="keyword">final</span> File STAGING_PREFIX_FILE = <span class="keyword">new</span> File(STAGING_PREFIX_PATH);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (STAGING_PREFIX_FILE.exists()) &#123;</span><br><span class="line">                    deleteFolder(STAGING_PREFIX_FILE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8096</span>];</span><br><span class="line">                <span class="keyword">final</span> List&lt;Pair&lt;String, String&gt;&gt; symlinks = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> URL zipUrl = determineZipUrl();</span><br><span class="line">                <span class="keyword">try</span> (ZipInputStream zipInput = <span class="keyword">new</span> ZipInputStream(zipUrl.openStream())) &#123;</span><br><span class="line">                    ZipEntry zipEntry;</span><br><span class="line">                    <span class="keyword">while</span> ((zipEntry = zipInput.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (zipEntry.getName().equals(<span class="string">&quot;SYMLINKS.txt&quot;</span>)) &#123;</span><br><span class="line">                            BufferedReader symlinksReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(zipInput));</span><br><span class="line">                            String line;</span><br><span class="line">                            <span class="keyword">while</span> ((line = symlinksReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                String[] parts = line.split(<span class="string">&quot;←&quot;</span>);</span><br><span class="line">                                <span class="keyword">if</span> (parts.length != <span class="number">2</span>)</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Malformed symlink line: &quot;</span> + line);</span><br><span class="line">                                String oldPath = parts[<span class="number">0</span>];</span><br><span class="line">                                String newPath = STAGING_PREFIX_PATH + <span class="string">&quot;/&quot;</span> + parts[<span class="number">1</span>];</span><br><span class="line">                                symlinks.add(Pair.create(oldPath, newPath));</span><br><span class="line"></span><br><span class="line">                                ensureDirectoryExists(<span class="keyword">new</span> File(newPath).getParentFile());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            String zipEntryName = zipEntry.getName();</span><br><span class="line">                            File targetFile = <span class="keyword">new</span> File(STAGING_PREFIX_PATH, zipEntryName);</span><br><span class="line">                            <span class="keyword">boolean</span> isDirectory = zipEntry.isDirectory();</span><br><span class="line"></span><br><span class="line">                            ensureDirectoryExists(isDirectory ? targetFile : targetFile.getParentFile());</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!isDirectory) &#123;</span><br><span class="line">                                <span class="keyword">try</span> (FileOutputStream outStream = <span class="keyword">new</span> FileOutputStream(targetFile)) &#123;</span><br><span class="line">                                    <span class="keyword">int</span> readBytes;</span><br><span class="line">                                    <span class="keyword">while</span> ((readBytes = zipInput.read(buffer)) != -<span class="number">1</span>)</span><br><span class="line">                                        outStream.write(buffer, <span class="number">0</span>, readBytes);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (zipEntryName.startsWith(<span class="string">&quot;bin/&quot;</span>) || zipEntryName.startsWith(<span class="string">&quot;libexec&quot;</span>) || zipEntryName.startsWith(<span class="string">&quot;lib/apt/methods&quot;</span>)) &#123;</span><br><span class="line">                                    <span class="comment">//noinspection OctalInteger</span></span><br><span class="line">                                    Os.chmod(targetFile.getAbsolutePath(), <span class="number">0700</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (symlinks.isEmpty())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No SYMLINKS.txt encountered&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (Pair&lt;String, String&gt; symlink : symlinks) &#123;</span><br><span class="line">                    Os.symlink(symlink.first, symlink.second);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!STAGING_PREFIX_FILE.renameTo(PREFIX_FILE)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to rename staging folder&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                activity.runOnUiThread(whenDone);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">                Log.e(EmulatorDebug.LOG_TAG, <span class="string">&quot;Bootstrap error&quot;</span>, e);</span><br><span class="line">                Termux.mInstance.setInstalled(<span class="keyword">false</span>);</span><br><span class="line">                Termux.mInstance.getTermuxHandle().initFail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createSession"><a href="#createSession" class="headerlink" title="createSession"></a>createSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TerminalSession <span class="title">createSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> File(HOME_PATH).mkdirs();</span><br><span class="line"></span><br><span class="line">    String[] env = BackgroundJob.buildEnvironment(<span class="keyword">false</span>, HOME_PATH);</span><br><span class="line">    String executablePath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String shellBinary : <span class="keyword">new</span> String[]&#123;<span class="string">&quot;login&quot;</span>, <span class="string">&quot;bash&quot;</span>, <span class="string">&quot;zsh&quot;</span>&#125;) &#123;</span><br><span class="line">        File shellFile = <span class="keyword">new</span> File(PREFIX_PATH + <span class="string">&quot;/bin/&quot;</span> + shellBinary);</span><br><span class="line">        <span class="keyword">if</span> (shellFile.canExecute()) &#123;</span><br><span class="line">            executablePath = shellFile.getAbsolutePath();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executablePath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        XLLog.d(TermuxDebug.TAG, <span class="string">&quot;fall back to system shell&quot;</span>);</span><br><span class="line">        executablePath = <span class="string">&quot;/system/bin/sh&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] processArgs = BackgroundJob.setupProcessArgs(executablePath, <span class="keyword">null</span>);</span><br><span class="line">    executablePath = processArgs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> lastSlashIndex = executablePath.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    String processName = <span class="string">&quot;-&quot;</span> +</span><br><span class="line">            (lastSlashIndex == -<span class="number">1</span> ? executablePath : executablePath.substring(lastSlashIndex + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    String[] args = <span class="keyword">new</span> String[processArgs.length];</span><br><span class="line">    args[<span class="number">0</span>] = processName;</span><br><span class="line">    <span class="keyword">if</span> (processArgs.length &gt; <span class="number">1</span>)</span><br><span class="line">        System.arraycopy(processArgs, <span class="number">1</span>, args, <span class="number">1</span>, processArgs.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    TerminalSession session = <span class="keyword">new</span> TerminalSession(executablePath, HOME_PATH, args, env);</span><br><span class="line">    session.initializeEmulator(Integer.MAX_VALUE, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mShellPath: /data/data/$pkg/files/usr/bin/login</span><br><span class="line">mCwd: /data/data/$pkg/files/home</span><br><span class="line">mArgs: [-login]</span><br><span class="line">mEnv: [TERM=xterm-256color, HOME=/data/data/$pkg/files/home, PREFIX=/data/data/$pkg/files/usr, BOOTCLASSPATH/system/framework/com.qualcomm.qti.camera.jar:/system/framework/QPerformance.jar:/system/framework/core-oj.jar:/system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/bouncycastle.jar:/system/framework/apache-xml.jar:/system/framework/legacy-test.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/android.hidl.base-V1.0-java.jar:/system/framework/android.hidl.manager-V1.0-java.jar:/system/framework/tcmiface.jar:/system/framework/WfdCommon.jar:/system/framework/oem-services.jar:/system/framework/qcom.fmradio.jar:/system/framework/telephony-ext.jar:/system/app/miui/miui.apk:/system/app/miuisystem/miuisystem.apk, ANDROID_ROOT=/system, ANDROID_DATA=/data, EXTERNAL_STORAGE=/sdcard, LD_LIBRARY_PATH=/data/data/$pkg/files/usr/lib, LANG=en_US.UTF-8, PATH=/data/data/$pkg/files/usr/bin:/data/data/$pkg/files/usr/bin/applets, PWD=/data/data/$pkg/files/home, TMPDIR=/data/data/$pkg/files/usr/tmp]</span><br><span class="line">mShellPid: 15381</span><br><span class="line">mTerminalFileDescriptor: 54</span><br></pre></td></tr></table></figure>

<h3 id="操作terminal"><a href="#操作terminal" class="headerlink" title="操作terminal"></a>操作terminal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A queue written to from a separate thread when the process outputs, and read by main thread to process by</span></span><br><span class="line"><span class="comment">    * terminal emulator.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteQueue mProcessToTerminalIOQueue = <span class="keyword">new</span> ByteQueue(<span class="number">4096</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A queue written to from the main thread due to user interaction, and read by another thread which forwards by</span></span><br><span class="line"><span class="comment">    * writing to the &#123;<span class="doctag">@link</span> #mTerminalFileDescriptor&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ByteQueue mTerminalToProcessIOQueue = <span class="keyword">new</span> ByteQueue(<span class="number">4096</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeEmulator</span><span class="params">(<span class="keyword">int</span> columns, <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] processId = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    mTerminalFileDescriptor = JNI.createSubprocess(mShellPath, mCwd, mArgs, mEnv, processId, rows, columns);</span><br><span class="line">    mShellPid = processId[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FileDescriptor terminalFileDescriptorWrapped = wrapFileDescriptor(mTerminalFileDescriptor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;TermSessionInputReader[pid=&quot;</span> + mShellPid + <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> (InputStream termIn = <span class="keyword">new</span> FileInputStream(terminalFileDescriptorWrapped)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> read = termIn.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (read == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!mProcessToTerminalIOQueue.write(buffer, <span class="number">0</span>, read)) <span class="keyword">return</span>;</span><br><span class="line">                    mMainThreadHandler.sendEmptyMessage(MSG_NEW_INPUT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// Ignore, just shutting down.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;TermSessionOutputWriter[pid=&quot;</span> + mShellPid + <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">try</span> (FileOutputStream termOut = <span class="keyword">new</span> FileOutputStream(terminalFileDescriptorWrapped)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> bytesToWrite = mTerminalToProcessIOQueue.read(buffer, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (bytesToWrite == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">                    termOut.write(buffer, <span class="number">0</span>, bytesToWrite);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;TermSessionWaiter[pid=&quot;</span> + mShellPid + <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> processExitCode = JNI.waitFor(mShellPid);</span><br><span class="line">            mMainThreadHandler.sendMessage(mMainThreadHandler.obtainMessage(MSG_PROCESS_EXITED, processExitCode));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createSubprocess"><a href="#createSubprocess" class="headerlink" title="createSubprocess"></a>createSubprocess</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_subprocess</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span> <span class="keyword">const</span>* cmd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span> <span class="keyword">const</span>* cwd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span>* <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">char</span>** envp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>* pProcessId,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint rows,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint columns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptm = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (ptm &lt; <span class="number">0</span>) <span class="keyword">return</span> throw_runtime_exception(env, <span class="string">&quot;Cannot open /dev/ptmx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LACKS_PTSNAME_R</span></span><br><span class="line">    <span class="keyword">char</span>* devname;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">char</span> devname[<span class="number">64</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (grantpt(ptm) || unlockpt(ptm) ||</span><br><span class="line">#ifdef LACKS_PTSNAME_R</span><br><span class="line">            (devname = ptsname(ptm)) == <span class="literal">NULL</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">            ptsname_r(ptm, devname, <span class="keyword">sizeof</span>(devname))</span><br><span class="line">#endif</span><br><span class="line">       ) &#123;</span><br><span class="line">        <span class="keyword">return</span> throw_runtime_exception(env, <span class="string">&quot;Cannot grantpt()/unlockpt()/ptsname_r() on /dev/ptmx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable UTF-8 mode and disable flow control to prevent Ctrl+S from locking up the display.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">tios</span>;</span></span><br><span class="line">    tcgetattr(ptm, &amp;tios);</span><br><span class="line">    tios.c_iflag |= IUTF8;</span><br><span class="line">    tios.c_iflag &amp;= ~(IXON | IXOFF);</span><br><span class="line">    tcsetattr(ptm, TCSANOW, &amp;tios);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Set initial winsize. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">sz</span> = &#123;</span> .ws_row = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) rows, .ws_col = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) columns &#125;;</span><br><span class="line">    ioctl(ptm, TIOCSWINSZ, &amp;sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> throw_runtime_exception(env, <span class="string">&quot;Fork failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *pProcessId = (<span class="keyword">int</span>) pid;</span><br><span class="line">        <span class="keyword">return</span> ptm;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Clear signals which the Android java process may have blocked:</span></span><br><span class="line">        <span class="keyword">sigset_t</span> signals_to_unblock;</span><br><span class="line">        sigfillset(&amp;signals_to_unblock);</span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;signals_to_unblock, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        close(ptm);</span><br><span class="line">        setsid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pts = open(devname, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (pts &lt; <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        dup2(pts, <span class="number">0</span>);</span><br><span class="line">        dup2(pts, <span class="number">1</span>);</span><br><span class="line">        dup2(pts, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        DIR* self_dir = opendir(<span class="string">&quot;/proc/self/fd&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (self_dir != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> self_dir_fd = dirfd(self_dir);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span>;</span></span><br><span class="line">            <span class="keyword">while</span> ((entry = readdir(self_dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = atoi(entry-&gt;d_name);</span><br><span class="line">                <span class="keyword">if</span>(fd &gt; <span class="number">2</span> &amp;&amp; fd != self_dir_fd) close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            closedir(self_dir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        clearenv();</span><br><span class="line">        <span class="keyword">if</span> (envp) <span class="keyword">for</span> (; *envp; ++envp) putenv(*envp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (chdir(cwd) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>* error_message;</span><br><span class="line">            <span class="comment">// No need to free asprintf()-allocated memory since doing execvp() or exit() below.</span></span><br><span class="line">            <span class="keyword">if</span> (asprintf(&amp;error_message, <span class="string">&quot;chdir(\&quot;%s\&quot;)&quot;</span>, cwd) == <span class="number">-1</span>) error_message = <span class="string">&quot;chdir()&quot;</span>;</span><br><span class="line">            perror(error_message);</span><br><span class="line">            fflush(<span class="built_in">stderr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        execvp(cmd, argv);</span><br><span class="line">        <span class="comment">// Show terminal output about failing exec() call:</span></span><br><span class="line">        <span class="keyword">char</span>* error_message;</span><br><span class="line">        <span class="keyword">if</span> (asprintf(&amp;error_message, <span class="string">&quot;exec(\&quot;%s\&quot;)&quot;</span>, cmd) == <span class="number">-1</span>) error_message = <span class="string">&quot;exec()&quot;</span>;</span><br><span class="line">        perror(error_message);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些问题和思考"><a href="#一些问题和思考" class="headerlink" title="一些问题和思考"></a>一些问题和思考</h2><ul>
<li>最开始的版本使用的bootstrap.zip中打包进了包括bash以及apt在内的许多命令及依赖，大小有16M左右，它提供了一个比较完整的shell功能，后续可以通过apt去下载python然后获取youtube-dl，一个流程下载需要26M左右的流量</li>
<li>由于deb包以及bootstrap.zip都是我们自己编译后放在自己的服务器上的，因此在安装python时可以按照dpkg本地安装的方式，python.deb的获取通过http的方式从服务器下载，在编译bootstrap.zip时只添加dpkg以及其依赖，其余的apt和bash都不提供，使用Android系统内部的shell客户端————sh，虽然sh功能有限，使用不方便，但是可以满足基本的一些需求。按照这种方式，打包的bootstrap.zip只包括dpkg，大小为3M，然后加上下载的python以及youtube-dl，总共13M左右（而且免去了<code>apt update</code>等所需的流量）。</li>
<li>由于dpkg按照python.deb的方式需要手动解决依赖包的问题，需要手动下载许多的deb依赖包，因此最后直接在打包bootstrap.zip的时候，去掉dpkg，直接加上python的依赖，将其打包进bootstrap.zip，在客户端下载配置完bootstrap.zip后，即可直接使用python的pip下载youtube-dl，操作上方便了许多，并且避免了不同Android系统可能存在的兼容性问题。</li>
</ul>
<h1 id="Android-App-Bundle"><a href="#Android-App-Bundle" class="headerlink" title="Android App Bundle"></a>Android App Bundle</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Android App Bundle是Google推出的Apk动态打包，动态组件化的技术，与Instant App不同，AAB是借助Split Apk完成动态加载，使用AAB动态下发方式，可以大幅度减少应用体积。只须在 Android Studio 中构建一个应用 (app bundle)，就可以将应用所需的全部内容 (适用于所有设备) 都涵盖在内：所有语言、所有设备屏幕大小、所有硬件架构。它本身并不支持动态化，只是动态化的一个载体文件，真正实现逻辑并不是它。</p>
<img src="aab.gif"/>

<h2 id="Split-APK"><a href="#Split-APK" class="headerlink" title="Split APK"></a>Split APK</h2><p>Split APK是Google为解决65536上限，以及APK安装包越来越大等问题，在Android L中引入的机制。它可以将一个庞大的APK，按屏幕密度，ABI等形式拆分成多个独立的APK，在应用程序更新时，不必下载整个APK，只需单独下载某个模块即可安装更新。Split APK将原来一个APK中多个模块共享同一份资源的模型分离成多个APK使用各自的资源，并且可以继承Base APK中的资源，多个APK有相同的data，cache目录，多个dex文件，相同的进程，在Settings.apk中只显示一个APK，并且使用相同的包名。</p>
<h2 id="Building-App-Bundles"><a href="#Building-App-Bundles" class="headerlink" title="Building App Bundles"></a>Building App Bundles</h2><p>在gradle中配置Split的维度：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    bundle &#123;</span><br><span class="line">        language &#123;</span><br><span class="line">            enableSplit = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        density &#123;</span><br><span class="line">            enableSplit = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        abi &#123;</span><br><span class="line">            enableSplit = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过Android Studio/Gradle/Bundletool生成.aab文件。</p>
<h2 id="Test-Android-App-Bundle"><a href="#Test-Android-App-Bundle" class="headerlink" title="Test Android App Bundle"></a>Test Android App Bundle</h2><p>可以通过两种方法测试aab：</p>
<ol>
<li>在本地使用 bundletool 命令行工具</li>
<li>将 bundle上传到 Google Play Console，然后使用新的内部测试轨道</li>
</ol>
<h3 id="bundletool"><a href="#bundletool" class="headerlink" title="bundletool"></a>bundletool</h3><p>在 <a target="_blank" rel="noopener" href="https://github.com/google/bundletool/releases">Github 仓库</a> 中下载 bundletool 工具。</p>
<p>从 app bundle 生成一组 APK：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar bundletool-all-0.3.3.jar build-apks --bundle=[aab file] --output=[output file name].apks</span><br></pre></td></tr></table></figure>

<h4 id="解压-apks"><a href="#解压-apks" class="headerlink" title="解压.apks"></a>解压.apks</h4><p>解压 <code>.apks</code> 文件：<code>unzip app.apks -d tmp</code>，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Archive:  app.apks</span><br><span class="line">extracting: tmp/base-hdpi.apk       </span><br><span class="line">extracting: tmp/base-mdpi.apk       </span><br><span class="line">extracting: tmp/base-ldpi.apk       </span><br><span class="line">extracting: tmp/base-xhdpi.apk      </span><br><span class="line">extracting: tmp/base-xxxhdpi.apk    </span><br><span class="line">extracting: tmp/base-xxhdpi.apk     </span><br><span class="line">extracting: tmp/base-tvdpi.apk      </span><br><span class="line">extracting: tmp/base-ca.apk         </span><br><span class="line">extracting: tmp/base-da.apk         </span><br><span class="line">extracting: tmp/base-fa.apk         </span><br><span class="line">extracting: tmp/base-ja.apk         </span><br><span class="line">extracting: tmp/base-ka.apk         </span><br><span class="line">extracting: tmp/base-pa.apk         </span><br><span class="line">extracting: tmp/base-ta.apk         </span><br><span class="line">extracting: tmp/base-nb.apk         </span><br><span class="line">extracting: tmp/base-be.apk         </span><br><span class="line">extracting: tmp/base-de.apk         </span><br><span class="line">extracting: tmp/base-ne.apk         </span><br><span class="line">extracting: tmp/base-te.apk         </span><br><span class="line">extracting: tmp/base-af.apk         </span><br><span class="line">extracting: tmp/base-bg.apk         </span><br><span class="line">extracting: tmp/base-th.apk         </span><br><span class="line">extracting: tmp/base-fi.apk         </span><br><span class="line">extracting: tmp/base-si.apk         </span><br><span class="line">extracting: tmp/base-hi.apk         </span><br><span class="line">extracting: tmp/base-vi.apk         </span><br><span class="line">extracting: tmp/base-kk.apk         </span><br><span class="line">extracting: tmp/base-mk.apk         </span><br><span class="line">extracting: tmp/base-sk.apk         </span><br><span class="line">extracting: tmp/base-uk.apk         </span><br><span class="line">extracting: tmp/base-el.apk         </span><br><span class="line">extracting: tmp/base-master.apk     </span><br><span class="line">extracting: tmp/base-gl.apk</span><br><span class="line">extracting: tmp/base-nl.apk</span><br><span class="line">extracting: tmp/base-ml.apk</span><br><span class="line">extracting: tmp/base-pl.apk</span><br><span class="line">extracting: tmp/base-sl.apk</span><br><span class="line">extracting: tmp/base-tl.apk</span><br><span class="line">extracting: tmp/base-am.apk</span><br><span class="line">extracting: tmp/base-km.apk</span><br><span class="line">extracting: tmp/base-bn.apk</span><br><span class="line">extracting: tmp/base-in.apk</span><br><span class="line">extracting: tmp/base-kn.apk</span><br><span class="line">extracting: tmp/base-mn.apk</span><br><span class="line">extracting: tmp/base-ko.apk</span><br><span class="line">extracting: tmp/base-lo.apk</span><br><span class="line">extracting: tmp/base-ro.apk</span><br><span class="line">extracting: tmp/base-sq.apk</span><br><span class="line">extracting: tmp/base-ar.apk</span><br><span class="line">extracting: tmp/base-fr.apk</span><br><span class="line">extracting: tmp/base-hr.apk</span><br><span class="line">extracting: tmp/base-mr.apk</span><br><span class="line">extracting: tmp/base-or.apk</span><br><span class="line">extracting: tmp/base-sr.apk</span><br><span class="line">extracting: tmp/base-tr.apk</span><br><span class="line">extracting: tmp/base-ur.apk</span><br><span class="line">extracting: tmp/base-as.apk</span><br><span class="line">extracting: tmp/base-bs.apk</span><br><span class="line">extracting: tmp/base-cs.apk</span><br><span class="line">extracting: tmp/base-es.apk</span><br><span class="line">extracting: tmp/base-is.apk</span><br><span class="line">extracting: tmp/base-ms.apk</span><br><span class="line">extracting: tmp/base-et.apk</span><br><span class="line">extracting: tmp/base-it.apk</span><br><span class="line">extracting: tmp/base-lt.apk</span><br><span class="line">extracting: tmp/base-pt.apk</span><br><span class="line">extracting: tmp/base-gu.apk</span><br><span class="line">extracting: tmp/base-eu.apk</span><br><span class="line">extracting: tmp/base-hu.apk</span><br><span class="line">extracting: tmp/base-ru.apk</span><br><span class="line">extracting: tmp/base-lv.apk</span><br><span class="line">extracting: tmp/base-zu.apk</span><br><span class="line">extracting: tmp/base-sv.apk</span><br><span class="line">extracting: tmp/base-iw.apk</span><br><span class="line">extracting: tmp/base-sw.apk</span><br><span class="line">extracting: tmp/base-hy.apk</span><br><span class="line">extracting: tmp/base-ky.apk</span><br><span class="line">extracting: tmp/base-my.apk</span><br><span class="line">extracting: tmp/base-az.apk</span><br><span class="line">extracting: tmp/base-uz.apk</span><br><span class="line">extracting: tmp/base-en.apk</span><br><span class="line">extracting: tmp/base-zh.apk</span><br><span class="line">extracting: tmp/base-armeabi_v7a.apk  </span><br><span class="line">extracting: tmp/base-arm64_v8a.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_mdpi.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_ldpi.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_hdpi.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_xhdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_ldpi.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_xxxhdpi.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_xxhdpi.apk  </span><br><span class="line">extracting: tmp/standalone-arm64_v8a_tvdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_mdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_xhdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_xxhdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_hdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_xxxhdpi.apk  </span><br><span class="line">extracting: tmp/standalone-armeabi_v7a_tvdpi.apk  </span><br><span class="line">inflating: tmp/toc.pb              </span><br></pre></td></tr></table></figure>

<p>可以使用如下命令安装多个 split apks：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install-multiple -r 1.apk 2.apk</span><br></pre></td></tr></table></figure>

<h3 id="Google-Play-Console"><a href="#Google-Play-Console" class="headerlink" title="Google Play Console"></a>Google Play Console</h3><p>使用内部测试方式。</p>
<h2 id="Dynamic-Delivery"><a href="#Dynamic-Delivery" class="headerlink" title="Dynamic Delivery"></a>Dynamic Delivery</h2><ul>
<li>基本 APK</li>
<li>配置 APK</li>
<li>动态功能 APK</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>从非GP的渠道下载base.apk：采用Google官方的方法，即提示用户跳转GP安装最新版</li>
<li>从Apk更新到aab：测试之后发现可以正常更新</li>
<li>分享apk：Instant Apps/茄子快传分享Split Apk时可以组装成一个完整的apk</li>
<li>Google Play签名计划会使用我们自己的签名文件去签名(而不是我们手动签名)(v1，v2)</li>
</ul>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/08/27/Termux%E8%A7%A3%E6%9E%90/">Termux解析</a></li>
<li><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/08/08/termux-app%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D/">termux-app修改包名</a></li>
<li><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/09/16/Android-App-Bundle%E7%AC%94%E8%AE%B0/">Android-App-Bundle笔记</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/app-bundle/">Android App Bundles</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Android-init-zygote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Android-init-zygote/" class="post-title-link" itemprop="url">Android-init-zygote</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 16:35:56" itemprop="dateCreated datePublished" datetime="2019-10-21T16:35:56+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          
            <span id="/2019/10/21/Android-init-zygote/" class="post-meta-item leancloud_visitors" data-flag-title="Android-init-zygote" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/21/Android-init-zygote/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/Android-init-zygote/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>注：本文基于Android 9.0源码，为了文章的简洁性，引用源码的地方可能有所删减。</p>
<p>本文主要分析Android系统在启动之后系统服务之间的关系以及各个关键进程的启动逻辑，Android系统简要启动流程如下(图片来源网络，总结得非常好)：</p>
<p><img src="android-boot.jpg" alt="android-boot"></p>
<h2 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h2><p>当电源按下时引导芯片代码会从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。</p>
<h2 id="引导程序BootLoader"><a href="#引导程序BootLoader" class="headerlink" title="引导程序BootLoader"></a>引导程序BootLoader</h2><p>它是Android操作系统开始运行前的一个小程序，主要将操作系统OS拉起来并进行。</p>
<h2 id="Linux内核启动"><a href="#Linux内核启动" class="headerlink" title="Linux内核启动"></a>Linux内核启动</h2><p>当内核启动时，会设置缓存、加载驱动等。此外，还启动了Kernel的swapper进程(pid = 0)和kthreadd进程(pid = 2)：</p>
<ul>
<li>swapper进程：又称为idle进程，系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Binder Driver、Display、Camera Driver等相关工作。</li>
<li>kthreadd进程：Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。</li>
</ul>
<p>当内核完成系统设置时，它首先在系统中寻找init.rc文件，并启动init进程。init进程是一个由内核启动的第一个用户级进程，它的进程号是1，父进程id号是0。init进程是所有用户空间的鼻祖, 它会启动servicemanager(binder服务管家，其功能为查询和注册服务), Zygote进程(Java进程的鼻祖). Zygote进程会创建 system_server进程以及各种app进程。</p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><h2 id="init-cpp"><a href="#init-cpp" class="headerlink" title="init.cpp"></a>init.cpp</h2><p>init进程的入口函数是<code>system/core/init/init.cpp</code>的main函数，它的代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    add_environment(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：内核态</span></span><br><span class="line">    <span class="comment">// 第二阶段：用户态</span></span><br><span class="line">    <span class="keyword">bool</span> is_first_stage = (getenv(<span class="string">&quot;INIT_SECOND_STAGE&quot;</span>) == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">        <span class="comment">// Clear the umask，与Linux系统权限有关</span></span><br><span class="line">        umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">        <span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line">        mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">        mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">&quot;init first stage started!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to mount required partitions early ...&quot;</span>;</span><br><span class="line">            panic();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up SELinux(Security-Enhanced Linux), loading the SELinux policy.</span></span><br><span class="line">        selinux_initialize(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We&#x27;re in the kernel domain, so re-exec init to transition to the init domain now</span></span><br><span class="line">        <span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line">        <span class="comment">// 按selinux policy要求，重新设置init文件属性</span></span><br><span class="line">        <span class="keyword">if</span> (restorecon(<span class="string">&quot;/init&quot;</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 失败的话会reboot</span></span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;restorecon failed&quot;</span>;</span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setenv(<span class="string">&quot;INIT_SECOND_STAGE&quot;</span>, <span class="string">&quot;true&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        setenv(<span class="string">&quot;INIT_STARTED_AT&quot;</span>, StringPrintf(<span class="string">&quot;%&quot;</span> PRIu64, start_ms).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次调用init的main函数，启动用户态的init进程</span></span><br><span class="line">        <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">char</span>* args[] = &#123; path, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        execv(path, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">        <span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二阶段：用户态</span></span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">&quot;init second stage started!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    property_init();  <span class="comment">// 初始化属性服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行内核命令</span></span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    property_set(<span class="string">&quot;ro.boottime.init&quot;</span>, getenv(<span class="string">&quot;INIT_STARTED_AT&quot;</span>));</span><br><span class="line">    property_set(<span class="string">&quot;ro.boottime.init.selinux&quot;</span>, getenv(<span class="string">&quot;INIT_SELINUX_TOOK&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置之前使用过的一些环境变量</span></span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_SECOND_STAGE&quot;</span>);</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_STARTED_AT&quot;</span>);</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_SELINUX_TOOK&quot;</span>);</span><br><span class="line">    unsetenv(<span class="string">&quot;INIT_AVB_VERSION&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    selinux_initialize(<span class="literal">false</span>);</span><br><span class="line">    selinux_restore_context();</span><br><span class="line"></span><br><span class="line">    signal_handler_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启属性服务</span></span><br><span class="line">    start_property_service();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析init.rc</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认会休眠直到有事件唤醒</span></span><br><span class="line">        <span class="keyword">int</span> epoll_timeout_ms = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重启一些挂掉的进程，例如Zygote</span></span><br><span class="line">        <span class="keyword">if</span> (!(waiting_for_prop || ServiceManager::GetInstance().IsWaitingForExec())) &#123;</span><br><span class="line">            restart_processes();</span><br><span class="line">            <span class="comment">// If there&#x27;s a process that needs restarting, wake up in time for that.</span></span><br><span class="line">            <span class="keyword">if</span> (process_needs_restart_at != <span class="number">0</span>) &#123;</span><br><span class="line">                epoll_timeout_ms = (process_needs_restart_at - time(<span class="literal">nullptr</span>)) * <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">if</span> (epoll_timeout_ms &lt; <span class="number">0</span>) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there&#x27;s more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        epoll_event ev;</span><br><span class="line">        <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, epoll_timeout_ms));</span><br><span class="line">        <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">&quot;epoll_wait failed&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一阶段：</p>
<ul>
<li>判断及增加环境变量</li>
<li>创建文件系统目录并挂载相关的文件系统</li>
<li>重定向输入输出/内核Log系统</li>
<li>挂载一些分区设备</li>
<li>完成SELinux相关工作</li>
<li>is_first_stage 收尾 </li>
</ul>
<p>第二阶段：</p>
<ul>
<li>初始化属性域，清空环境变量</li>
<li>完成SELinux相关工作</li>
<li>启动属性服务</li>
<li>解析init.rc配置文件，执行各个阶段的动作，创建Zygote的工作就是在其中的某个阶段完成的。</li>
<li>init进入一个无限循环，并且等待一些事情的发生。</li>
</ul>
<p>下面给出 init.rc 部分内容(Mi Max3–MIUI 10–Android 9)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">on init</span><br><span class="line">on property:sys.boot_from_charger_mode=1</span><br><span class="line">on load_persist_props_action</span><br><span class="line">on firmware_mounts_complete</span><br><span class="line">on late-init</span><br><span class="line">on post-fs      // mount file system</span><br><span class="line">    start logd</span><br><span class="line">    mount rootfs rootfs / ro remount</span><br><span class="line">    mount rootfs rootfs / shared rec</span><br><span class="line">    mount none /mnt/runtime/default /storage slave bind rec</span><br><span class="line">    // ...</span><br><span class="line">// ...</span><br><span class="line">on post-fs-data  // mount /data/</span><br><span class="line">    // 启动 logd</span><br><span class="line">    start logd</span><br><span class="line">    // 启动 vold, 用于管理Android外部存储介质的后台进程，包括SD卡的插拔等</span><br><span class="line">    start vold</span><br><span class="line">    // ...</span><br><span class="line">// ...</span><br><span class="line">on boot</span><br><span class="line">    // ...</span><br><span class="line">    class_start core</span><br></pre></td></tr></table></figure>

<h2 id="启动service"><a href="#启动service" class="headerlink" title="启动service"></a>启动service</h2><p>在 init.zygote64_32.rc 文件中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure>

<p>通过 init_parser.cpp 完成整个 service 解析工作，此处就不详细展开讲解析过程。</p>
<p>zygote所对应的可执行文件是<code>/system/bin/app_process</code>，通过调用<code>pid = fork()</code>创建子进程，通过<code>execve(svc-&gt;args[0], (char**)svc-&gt;args, (char**) ENV)</code>，进入app_main.cpp的main()函数。故zygote是通过fork和execv共同创建的。</p>
<p>流程如下：</p>
<p><img src="zygote%E5%90%AF%E5%8A%A8.jpg" alt="zygote启动"></p>
<p>当init子进程退出时，会产生 SIGCHLD 信号，并发送给init进程，通过socket套接字传递数据，调用到 wait_for_one_process() 方法，根据是否是oneshot，来决定是重启子进程，还是放弃启动。surfaceflinger, servicemanager, zygote 以及 system_server 进程被杀都会触发Zygote重启。</p>
<h2 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h2><p>我们知道，Windows平台上有一个叫注册表的东西。注册表可以存储一些类似key/value的键值对。一般而言，系统或某些应用程序会把自己的一些属性存储在注册表中，即使下次系统重启或应用程序重启，它还能够根据之前在注册表中设置的属性，进行相应的初始化工作。</p>
<p>Android平台也提供了一个类型机制，可称之为属性服务（property service）。应用程序可通过这个属性机制，查询或设置属性。当某个进程A修改属性值后，init进程会检查访问权限，当权限满足要求后，则更改相应的属性值，属性值一旦改变则会触发相应的触发器(即rc文件中的on开头的语句)，</p>
<p><strong>属性服务初始化：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_property_area();<span class="comment">//初始化属性存储区域</span></span><br><span class="line">    <span class="comment">//加载default.prop文件</span></span><br><span class="line">    load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 properyty_init 函数中，先调用 init_property_area 函数，创建一块用于存储属性的存储区域(共享内存)，然后加载 default.prop 文件中的内容。</p>
<p><strong>访问方法：</strong></p>
<ul>
<li>Native: <code>property_get/property_set</code></li>
<li>Java: <code>SystemProperties</code></li>
<li>Shell: <code>adb shell getprop</code></li>
</ul>
<h1 id="zygote进程"><a href="#zygote进程" class="headerlink" title="zygote进程"></a>zygote进程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是app_main.cpp，进程名为zygote。</p>
<p>当Zygote进程启动后, 便会执行到frameworks/base/cmds/app_process/app_main.cpp文件的main()方法。整个调用流程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app_main.main</span><br><span class="line">    AndroidRuntime.start</span><br><span class="line">        AndroidRuntime.startVm</span><br><span class="line">        AndroidRuntime.startReg</span><br><span class="line">        ZygoteInit.main (首次进入Java世界)</span><br><span class="line">            registerServerSocketFromEnv</span><br><span class="line">            preload</span><br><span class="line">            forkSystemServer</span><br><span class="line">            runSelectLoop</span><br></pre></td></tr></table></figure>

<p>Zygote进程创建Java虚拟机，并注册JNI方法，真正成为Java进程的母体，用于孵化Java进程。在创建完system_server进程后，zygote功成身退，调用runSelectLoop()随时待命，当接收到创建新进程请求时立即唤醒并执行相应工作。Zygote进程共做了如下几件事：</p>
<ol>
<li>创建AppRuntime并调用其start方法，启动Zygote进程。</li>
<li>创建DVM（ART）并为DVM注册JNI。</li>
<li>通过JNI调用ZygoteInit的main函数进入Zygote的Java框架层。</li>
<li>通过registerServerSocketFromEnv函数创建服务端Socket，并通过runSelectLoop函数等待ActivityManagerService的请求来创建新的应用程序进程。</li>
<li>启动SystemServer进程。</li>
</ol>
<h2 id="app-main-cpp"><a href="#app-main-cpp" class="headerlink" title="app_main.cpp"></a>app_main.cpp</h2><p>Zygote本身是一个Native的应用程序，和驱动、内核等均无关系。Zygote是由init进程根据init.rc文件中的配置项而创建的。zygote最初的名字叫“app_process”，这个名字是在Android.mk文件中被指定的，但app_process在运行过程中，通过Linux下的pctrl系统调用将自己的名字换成了“zygote”，所以我们通过ps命令看到的进程名是“zygote”。</p>
<p>zygote的原型app_process所对应的源文件是<code>framework/base/cmds/app_process/app_main.cpp</code>，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --zygote : Start in zygote mode</span></span><br><span class="line">    <span class="comment">// --start-system-server : Start the system server.</span></span><br><span class="line">    <span class="comment">// --application : Start in application (stand alone, non zygote) mode.</span></span><br><span class="line">    <span class="comment">// --nice-name : The nice name for this process.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--zygote&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;  <span class="comment">// zygote64 or zygote</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--start-system-server&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">&quot;--application&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--nice-name=&quot;</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">&quot;--&quot;</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re not in zygote mode</span></span><br><span class="line">        <span class="comment">// 需要传递给RuntimeInit的唯一参数是application参数，剩余的args传递给启动类main</span></span><br><span class="line">        args.add(application ? String8(<span class="string">&quot;application&quot;</span>) : String8(<span class="string">&quot;tool&quot;</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We&#x27;re in zygote mode.</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">&quot;start-system-server&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: Unable to determine ABI list from property %s.&quot;</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">&quot;--abi-list=&quot;</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AppRuntime类的声明和实现均在app_main.cpp中，它是从AndroidRuntime类派生出来的，上述start函数使用的是基类AndroidRuntime的start。</p>
<h2 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime.start"></a>AndroidRuntime.start</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/AndroidRuntime.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rootDir = <span class="string">&quot;/system&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!hasDir(<span class="string">&quot;/system&quot;</span>)) &#123;</span><br><span class="line">            LOG_FATAL(<span class="string">&quot;No root directory specified, and /android does not exist.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        setenv(<span class="string">&quot;ANDROID_ROOT&quot;</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为后续Java世界用到的一些函数是采用native方式来实现的，所以必须提前注册这些函数</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to register all android natives\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将参数封装到strArray里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;</span>, slashClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到ZygoteInit类的static main函数的jMethodId</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;</span>, className);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用ZygoteInit.main函数后，Zygote便进入了Java世界</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h2><p>CallStaticVoidMethod最终将调用com.android.internal.os.ZygoteInit的main函数，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boolean startSystemServer = <span class="literal">false</span>;</span><br><span class="line">        String socketName = <span class="string">&quot;zygote&quot;</span>;</span><br><span class="line">        String abiList = null;</span><br><span class="line">        boolean enableLazyPreload = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;start-system-server&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;--enable-lazy-preload&quot;</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unknown command line argument: &quot;</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个Zygote的Socket接口，用来和AMS等通信</span></span><br><span class="line">        zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            <span class="comment">// 预加载一些类和资源，这是导致Android系统启动慢的原因之一</span></span><br><span class="line">            <span class="comment">// 应用程序都从Zygote孵化出来，应用程序都会继承Zygote的所有内容，如果在Zygote启动的时候加载这些类和资源，</span></span><br><span class="line">            <span class="comment">// 这些孵化的应用程序就继承Zygote的类和资源，这样启动引用程序的时候就不需要加载类和资源了，启动的速度就会快很多。</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">            <span class="comment">// 子进程（system_server）</span></span><br><span class="line">            <span class="keyword">if</span> (r != null) &#123;</span><br><span class="line">                <span class="comment">// 调用com.android.server.SystemServer.main方法</span></span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;System zygote died with exception&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;re in the child process and have exited the select loop. Proceed to execute the command.</span></span><br><span class="line">    <span class="keyword">if</span> (caller != null) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有三个重要的调用：</p>
<ul>
<li>registerServerSocketFromEnv用来创建一个Zygote的Socket接口，用来和AMS等通信</li>
<li>forkSystemServer用来fork创建system_server进程；</li>
<li>runSelectLoop用来处理客户端连接与请求，包括AMS请求创建app进程。</li>
</ul>
<h1 id="system-server进程"><a href="#system-server进程" class="headerlink" title="system_server进程"></a>system_server进程</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>SyetemServer在启动时做了如下工作：</p>
<ol>
<li>启动Binder线程池，这样就可以与其他进程进行通信。</li>
<li>创建SystemServiceManager用于对系统的服务进行创建、启动和生命周期管理。</li>
<li>启动各种系统服务。AMS，PMS，以及WMS等都是运行在system_server这个进程中的线程。</li>
</ol>
<h2 id="ZygoteInit-forkSystemServer"><a href="#ZygoteInit-forkSystemServer" class="headerlink" title="ZygoteInit.forkSystemServer"></a>ZygoteInit.forkSystemServer</h2><p>在上节中，ZygoteInit.main方法首次进入Java世界，然后调用了forkSystemServer方法创建system_server进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1024,1032,1065,3001,3002,3003,3006,3007,3009,3010&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--capabilities=&quot;</span> + capabilities + <span class="string">&quot;,&quot;</span> + capabilities,</span><br><span class="line">        <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--runtime-args&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--target-sdk-version=&quot;</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                <span class="string">&quot;dalvik.vm.profilesystemserver&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (profileSystemServer) &#123;</span><br><span class="line">            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.runtimeFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里设置了system_server进程的uid，gid和groups，nice-name等，有两个重要的调用：</p>
<ul>
<li>Zygote.forkSystemServer()函数用来fork一个新的进程，如果pid==0，表示已经进入SystemServer子进程，于是先关闭“Zygote”socket，因为系统服务进程system_server也继承了Socket，不用所以close它；</li>
<li>调用了handleSystemServerProcess()方法，返回Runnable对象到ZygoteInit.main并调用，其实是调用到了com.android.server.SystemServer.main方法。</li>
</ul>
<h2 id="Zygote-forkSystemServer"><a href="#Zygote-forkSystemServer" class="headerlink" title="Zygote.forkSystemServer"></a>Zygote.forkSystemServer</h2><p>首先看看Zygote.forkSystemServer方法，它调用的是nativeForkSystemServer方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permittedCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                        runtime_flags, rlimits,</span><br><span class="line">                                        permittedCapabilities, effectiveCapabilities,</span><br><span class="line">                                        MOUNT_EXTERNAL_DEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">true</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkAndSpecializeCommon</span><span class="params">(<span class="comment">/* ... */</span>)</span> </span>&#123;</span><br><span class="line">    SetSignalHandlers();</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork(); <span class="comment">// fork子进程</span></span><br><span class="line">    UnsetChldSignalHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig_chld</span> = &#123;</span>&#125;;</span><br><span class="line">    sig_chld.sa_handler = SigChldHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sig_chld, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Error setting SIGCHLD handler: %s&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig_hup</span> = &#123;</span>&#125;;</span><br><span class="line">    sig_hup.sa_handler = SIG_IGN;</span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sig_hup, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Error setting SIGHUP handler: %s&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets the SIGCHLD handler back to default behavior in zygote children.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnsetChldSignalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sa, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;Error unsetting SIGCHLD handler: %s&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SigChldHandler</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*signal_number*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == gSystemServerPid) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Exit zygote because system server (%d) has terminated&quot;</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ForkAndSpecializeCommon中有个逻辑是如果SystemServer进程停止工作，那么首先通过getpid()来获取Zygote进程的pid，然后调用kill函数杀死它，即SystemServer停止工作之后，Zygote进程自杀，然后在Init进程的main()函数中有一个死循环，如果它的子进程Zygote停止工作，就会去重启子进程。</p>
<h2 id="handleSystemServerProcess"><a href="#handleSystemServerProcess" class="headerlink" title="handleSystemServerProcess"></a>handleSystemServerProcess</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteConnection.Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">    Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">    <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行Binder驱动程序初始化的相关工作，它调用之后system_server进程就可以进行Binder进程通信</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获得com.android.server.SystemServer的main方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    Method m = cl.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里可以知道ZygoteInit.main方法中的<code>Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</code>返回的r即是MethodAndArgsCaller，在子进程中调用r.run方法便是调用了com.android.server.SystemServer.main方法。</p>
<h2 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer#main"></a>SystemServer#main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先初始化SystemServer对象，再调用对象的run()方法</span></span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepareMainLooper();<span class="comment">// 准备主线程looper</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    createSystemContext(); <span class="comment">//初始化系统上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一直循环执行</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.main</span><br><span class="line">    SystemServer.run</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        createSystemContext</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        Looper.loop();</span><br></pre></td></tr></table></figure>

<p>LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。</p>
<p>首先看看启动引导服务的方法startBootstrapServices：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞等待与installd建立socket通道</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In some cases after launching an app we need to access device identifiers,</span></span><br><span class="line">    <span class="comment">// therefore register the device identifier policy before the activity manager.</span></span><br><span class="line">    mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);</span><br><span class="line"></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(RecoverySystemService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have the bare essentials of the OS up and running, take</span></span><br><span class="line">    <span class="comment">// note that we just booted, which might send out a rescue party if</span></span><br><span class="line">    <span class="comment">// we&#x27;re stuck in a runtime restart loop.</span></span><br><span class="line">    RescueParty.noteBoot(mSystemContext);</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Package manager isn&#x27;t started yet; need to use SysProp not hardware feature</span></span><br><span class="line">    <span class="keyword">if</span> (SystemProperties.getBoolean(<span class="string">&quot;config.enable_sidekick_graphics&quot;</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        mSystemServiceManager.startService(WEAR_SIDEKICK_SERVICE_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the default display before we can initialize the package manager.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当设备正在加密时，仅运行core apps</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">&quot;vold.decrypt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Detected encryption in progress - only parsing core apps&quot;</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Device encrypted - only parsing core apps&quot;</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the package manager.</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line">    mSystemServiceManager.startService(<span class="keyword">new</span> OverlayManagerService(mSystemContext, installer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动传感器服务</span></span><br><span class="line">    startSensorService();</span><br></pre></td></tr></table></figure>

<p>该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务等。</p>
<p>然后是启动核心服务startCoreServices：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动服务BatteryService，用于统计电池电量，需要LightService.</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务UsageStatsService，用于统计应用使用情况</span></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WEBVIEW)) &#123;</span><br><span class="line">        <span class="comment">// 启动服务WebViewUpdateService</span></span><br><span class="line">        mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinderCallsStatsService.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务BatteryService，UsageStatsService，WebViewUpdateService等。</p>
<p>启动其它服务的startOtherServices方法比较长，主要是启动一系列的服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ServiceManager.addService(<span class="string">&quot;sec_key_att_app_id_provider&quot;</span>, <span class="keyword">new</span> KeyAttestationApplicationIdProviderService(context));</span><br><span class="line">    mSystemServiceManager.startService(KeyChainSystemService.class);</span><br><span class="line">    ServiceManager.addService(<span class="string">&quot;scheduling_policy&quot;</span>, <span class="keyword">new</span> SchedulingPolicyService());</span><br><span class="line">    mSystemServiceManager.startService(TelecomLoaderService.class);</span><br><span class="line">    telephonyRegistry = <span class="keyword">new</span> TelephonyRegistry(context);</span><br><span class="line">    ServiceManager.addService(<span class="string">&quot;telephony.registry&quot;</span>, telephonyRegistry);</span><br><span class="line">    mEntropyMixer = <span class="keyword">new</span> EntropyMixer(context);</span><br><span class="line"></span><br><span class="line">    mContentResolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);</span><br><span class="line">    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备好window, power, package, display服务</span></span><br><span class="line">    wm.systemReady();</span><br><span class="line">    mPowerManagerService.systemReady(...);</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    mDisplayManagerService.systemReady(...);</span><br><span class="line">    mActivityManagerService.systemReady(...);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此, System_server主线程的启动工作总算完成, 进入Looper.loop()状态，等待其他线程通过handler发送消息到主线再处理。</p>
<p>与system_server进程的Application相关的解析可见：<a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/12/16/Android-Application/">Android-Application</a>。</p>
<h1 id="app进程"><a href="#app进程" class="headerlink" title="app进程"></a>app进程</h1><h2 id="AMS发送请求"><a href="#AMS发送请求" class="headerlink" title="AMS发送请求"></a>AMS发送请求</h2><p>ActivityManagerService也是由SystemServer创建的。假设通过startActivity来启动一个新的Activity，而这个Activity附属于一个还未启动的进程，则会启动一个新的进程，调用startActivity的进程通过Binder调用到ActivityManagerService中的方法，然后经过层层调用（具体可见<a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/03/18/Android-Activity%E5%8E%9F%E7%90%86/">Android-Activity启动原理</a>），会调用到Process.start()方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">            runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">            abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的参数processClass为“android.app.ActivityThread”，它是传进去的第一个参数，也就是程序初始化进程时要加载的主文件Java类。当应用进程启动之后，会把这个类加载到进程，调用它的main()方法作为应用程序进程的入口。Process类的start()直接调用了ZygoteProcess类的start()方法，该start()方法调用了ZygoteProcess类的startViaZygote()方法，下面看看该方法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass, <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid, <span class="keyword">final</span> <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> targetSdkVersion, String seInfo, String abi, String instructionSet,String appDataDir, </span></span></span><br><span class="line"><span class="function"><span class="params">    String invokeWith, String[] extraArgs)</span> throws ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--runtime-args&quot;</span>);</span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--setuid=&quot;</span> + uid);</span><br><span class="line">    argsForZygote.add(<span class="string">&quot;--setgid=&quot;</span> + gid);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    synchronized(mLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先给它设置值，包括uid、gid等。接着调用openZygoteSocketIfNeeded()方法来连接“zygote”Socket，链接Socket成功之后，就会调用zygoteSendArgsAndGetResult()方法来进一步处理。</p>
<p>先来看看openZygoteSocketIfNeeded()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法中的mSocket的值是“zygote”，通过connect()方法去连接“zygote”Socket。接着看看zygoteSendArgsAndGetResult()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Socket写入流writer把前面传过来的那些参数写进去，Socket即ZygoteServer类的runSelectLoop()方法监听。写入这些数据之后，ZygoteServer类的runSelectLoop()方法就能被监听到。</p>
<h2 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForkChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mIsForkChild = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;poll failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ZygoteConnection connection = peers.get(i);</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">// 通过mIsForkChild变量控制父进程接着死循环/子进程返回command</span></span><br><span class="line">                    <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re in the child. We should always have a command to run at this</span></span><br><span class="line">                        <span class="comment">// stage if processOneCommand hasn&#x27;t called &quot;exec&quot;.</span></span><br><span class="line">                        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;command == null&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> command;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We&#x27;re in the server - we should never have any commands to run.</span></span><br><span class="line">                        <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;command != null&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                            connection.closeSocket();</span><br><span class="line">                            peers.remove(i);</span><br><span class="line">                            fds.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mIsForkChild) &#123;</span><br><span class="line">                        ZygoteConnection conn = peers.remove(i);</span><br><span class="line">                        conn.closeSocket();</span><br><span class="line">                        fds.remove(i);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入ZygoteConnection类的processOneCommand()方法后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">            parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">            parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,</span><br><span class="line">            parsedArgs.appDataDir);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            zygoteServer.setForkChild();</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>此处通过Zygote.forkAndSpecialize()来fork新的应用进程，而启动systemserver进程是通过Zygote.forkSystemServer()来fork SystemServer进程。</li>
<li>此处通过handleChildProc()方法处理，而之前是用handleSystemServerProcess()来处理。</li>
</ul>
<p>通过fork新的应用程序进程之后，返回pid等于0就表示进入子进程，于是调用handleChildProc()方法进一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,FileDescriptor pipeFd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ZygoteInit.zygoteInit中会创建Binder线程池，</span></span><br><span class="line">    <span class="comment">// 也就是说每个进程无论是否包含任何activity等组件，一定至少会包含一个Binder线程</span></span><br><span class="line">    <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,<span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此处，后面便和上面一样的了，唯一不同的是，SystemServer进程启动之后进入的是主类SystemServer.java的main()函数，而这里应用程序启动起来后进入的是主类是ActivityThread.java的main()函数，进入ActivityThread.main()方法后，会创建Application实例，具体可见：<a target="_blank" rel="noopener" href="https://ljd1996.github.io/2019/12/16/Android-Application/">Android-Application</a>。</p>
<p>接下来就只剩下forkAndSpecialize方法的解析了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] fdsToIgnore, <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 停止Zygote的4个Daemon子线程的运行，等待并确保Zygote是单线程（用于提升fork效率），</span></span><br><span class="line">    <span class="comment">// 并等待这些线程的停止，初始化gc堆的工作</span></span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    <span class="comment">// Resets nice priority for zygote process.</span></span><br><span class="line">    resetNicePriority();</span><br><span class="line">    <span class="comment">// 调用fork()创建新进程，设置新进程的主线程id，重置gc性能数据，设置信号处理函数</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">                uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">                fdsToIgnore, startChildZygote, instructionSet, appDataDir);</span><br><span class="line">    <span class="comment">// 在fork新进程后，启动Zygote的4个Daemon线程，java堆整理等。</span></span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeForkAndSpecialize()方法是一个Native方法，最终调用的是frameworks/base/core/jni/com_android_internal_os_Zygote.cpp#com_android_internal_os_Zygote_nativeForkAndSpecialize()方法，该方法又调用的是ForkAndSpecializeCommon方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> kZygoteClassName[] = <span class="string">&quot;com/android/internal/os/Zygote&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_Zygote</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    gZygoteClass = MakeGlobalRefOrDie(env, FindClassOrDie(env, kZygoteClassName));</span><br><span class="line">    gCallPostForkChildHooks = GetStaticMethodIDOrDie(env, gZygoteClass, <span class="string">&quot;callPostForkChildHooks&quot;</span>, <span class="string">&quot;(IZZLjava/lang/String;)V&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> RegisterMethodsOrDie(env, <span class="string">&quot;com/android/internal/os/Zygote&quot;</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig_chld</span> = &#123;</span>&#125;;</span><br><span class="line">    sig_chld.sa_handler = SigChldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets the SIGCHLD handler back to default behavior in zygote children.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnsetChldSignalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = SIG_DFL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SigChldHandler</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*signal_number*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If the just-crashed process is the system_server, bring down zygote</span></span><br><span class="line">        <span class="comment">// so that it is restarted by init and system server will be restarted</span></span><br><span class="line">        <span class="comment">// from there.</span></span><br><span class="line">        <span class="keyword">if</span> (pid == gSystemServerPid) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Exit zygote because system server (%d) has terminated&quot;</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray javaGids, jint runtime_flags, </span></span></span><br><span class="line"><span class="function"><span class="params">    jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">    jint mount_external, jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> is_system_server, jintArray fdsToClose, jintArray fdsToIgnore,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> is_child_zygote, jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置子进程的signal信号处理函数</span></span><br><span class="line">    SetSignalHandlers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        PreApplicationInit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理所有必须立即关闭的描述符</span></span><br><span class="line">        <span class="keyword">if</span> (!DetachDescriptors(env, fdsToClose, &amp;error_msg)) &#123;</span><br><span class="line">            fail_fn(error_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Re-open all remaining open file descriptors so that they aren&#x27;t shared</span></span><br><span class="line">        <span class="comment">// with the zygote across a fork.</span></span><br><span class="line">        <span class="keyword">if</span> (!gOpenFdTable-&gt;ReopenOrDetach(&amp;error_msg)) &#123;</span><br><span class="line">            fail_fn(error_msg);</span><br><span class="line">        &#125;</span><br><span class="line">        MountEmulatedStorage(uid, mount_external, use_native_bridge, &amp;error_msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this zygote isn&#x27;t root, it won&#x27;t be able to create a process group,</span></span><br><span class="line">        <span class="comment">// since the directory is owned by root.</span></span><br><span class="line">        <span class="keyword">if</span> (!is_system_server &amp;&amp; getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// selinux上下文</span></span><br><span class="line">        rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str == <span class="literal">NULL</span> &amp;&amp; is_system_server) &#123;</span><br><span class="line">            se_name_c_str = <span class="string">&quot;system_server&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            SetThreadName(se_name_c_str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unset the SIGCHLD handler, but keep ignoring SIGHUP (rationale in SetSignalHandlers).</span></span><br><span class="line">        UnsetChldSignalHandler();</span><br><span class="line">        <span class="comment">// 等价于调用zygote.callPostForkChildHooks()</span></span><br><span class="line">        env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                                is_system_server, is_child_zygote, instructionSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着进入zygote.callPostForkChildHooks()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callPostForkChildHooks</span><span class="params">(<span class="keyword">int</span> runtimeFlags, <span class="keyword">boolean</span> isSystemServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isZygote, String instructionSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用ZygoteHooks.postForkChild()</span></span><br><span class="line">    VM_HOOKS.postForkChild(runtimeFlags, isSystemServer, isZygote, instructionSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZygoteHooks.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkChild</span><span class="params">(<span class="keyword">int</span> runtimeFlags, <span class="keyword">boolean</span> isSystemServer, <span class="keyword">boolean</span> isZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instructionSet)</span> </span>&#123;</span><br><span class="line">    nativePostForkChild(token, runtimeFlags, isSystemServer, isZygote, instructionSet);</span><br><span class="line">    <span class="comment">// 设置了新进程Random随机数种子为当前系统时间，也就是在进程创建的那一刻就决定了未来随机数的情况，也就是伪随机。</span></span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativePostForkChild通过JNI最终调用调用如下方法：art/runtime/native/dalvik_system_ZygoteHooks.cc#ZygoteHooks_nativePostForkChild()：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteHooks_nativePostForkChild</span><span class="params">(JNIEnv* env, jclass, jlong token, jint debug_flags, jstring instruction_set)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处token记录着当前线程</span></span><br><span class="line">    Thread* thread = <span class="keyword">reinterpret_cast</span>&lt;Thread*&gt;(token);</span><br><span class="line">    <span class="comment">// 设置新进程的主线程id</span></span><br><span class="line">    thread-&gt;InitAfterFork();</span><br><span class="line">    <span class="keyword">if</span> (instruction_set != <span class="literal">nullptr</span> &amp;&amp; !is_system_server) &#123;</span><br><span class="line">        <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instruction_set)</span></span>;</span><br><span class="line">        InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">        Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">        <span class="keyword">if</span> (isa != InstructionSet::kNone &amp;&amp; isa != kRuntimeISA) &#123;</span><br><span class="line">            action = Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime::Current()-&gt;InitNonZygoteOrPostFork(env, is_system_server, action, isa_string.c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Runtime::Current()-&gt;InitNonZygoteOrPostFork(env, is_system_server,</span><br><span class="line">            Runtime::NativeBridgeAction::kUnload, <span class="literal">nullptr</span>, profile_system_server);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用了art/runtime/runtime.cc#InitNonZygoteOrPostFork方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Runtime::InitNonZygoteOrPostFork</span><span class="params">(JNIEnv* env, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">    NativeBridgeAction action, <span class="keyword">const</span> <span class="keyword">char</span>* isa, <span class="keyword">bool</span> profile_system_server)</span> </span>&#123;</span><br><span class="line">    is_zygote_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_native_bridge_loaded_) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> NativeBridgeAction::kUnload:</span><br><span class="line">                UnloadNativeBridge(); <span class="comment">// 卸载用于跨平台的桥连库</span></span><br><span class="line">                is_native_bridge_loaded_ = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> NativeBridgeAction::kInitialize:</span><br><span class="line">                InitializeNativeBridge(env, isa); <span class="comment">// 初始化用于跨平台的桥连库</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Java堆处理的线程池</span></span><br><span class="line">    heap_-&gt;CreateThreadPool();</span><br><span class="line">    <span class="comment">// 重置gc性能数据，以保证进程在创建之前的GCs不会计算到当前app上。</span></span><br><span class="line">    heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!safe_mode_ &amp;&amp; (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp; jit_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建JIT</span></span><br><span class="line">        CreateJit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    StartSignalCatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>init进程(pid=1)是Linux系统中用户空间的第一个进程，主要工作如下：</p>
<ul>
<li>初始化环境变量及挂载文件;</li>
<li>解析并执行init.rc文件;</li>
<li>处理子进程的退出(signal方式);</li>
<li>创建一块共享的内存空间用于属性服务器，并启动属性服务进程;</li>
<li>进入无限循环状态，执行如下流程：<ul>
<li>检查是否需要重启的进程，若有则将其重新启动;</li>
<li>进入等待状态，直到系统属性变化事件(property_set改变属性值)，或者收到子进程的信号SIGCHLD，或者keychord 键盘输入事件等，则会退出等待状态，执行相应的回调函数。</li>
</ul>
</li>
</ul>
<p>可见init进程在开机之后的核心工作就是响应property变化事件和回收僵尸进程以及重启进程。</p>
<ul>
<li>当某个进程改变了一个系统属性值时，系统会通过socket向init进程发送一个property变化的事件通知，那么init进程会触发相关回调。</li>
<li>回收僵尸进程，在Linux内核中，如父进程不等待子进程的结束直接退出，会导致子进程在结束后变成僵尸进程，占用系统资源。为此，init进程专门安装了SIGCHLD信号接收器，当某些子进程退出时发现其父进程已经退出，则会向init进程发送SIGCHLD信号，init进程回收僵尸子进程。</li>
</ul>
<p>Zygote启动过程的调用流程：</p>
<ul>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；</li>
<li>registerServerSocketFromEnv()方法建立socket通道，zygote作为通信的服务端，用于响应客户端请求；</li>
<li>preload()预加载通用类、相关资源，共享库等，用于提高app启动效率；</li>
<li>接下来再通过startSystemServer()，fork出system_server进程，也是上层framework的运行载体；</li>
<li>zygote调用runSelectLoop()方法等待，当接收到创建新进程请求时唤醒并执行相应工作。</li>
</ul>
<p>zygote预加载了一些资源，通过它来 fork system_server 进程，则 system_server 可以直接使用这些加载好的资源如 JNI 函数，常用的方法，共享库，资源等。此外，选择使用 zygote 进程来 fork 应用程序而不是使用 system_server 来 fork 是因为 system_server 有自己的工作要处理，其内有许多线程如 AMS, WMS, PKMS 等，这种多线程的父进程 fork 子进程可能会导致死锁。</p>
<p>在 Linux 系统中 fork 子进程会复制父进程用户空间的数据到子进程(copy-on-write)，然后复制当前线程到子进程，而父进程中的其它线程在子进程中都”蒸发”了。如果在fork之前，一个线程持有了某个锁，然后另外一个线程调用了fork创建子进程，在子进程中持有那个锁的线程却”蒸发”了，从子进程的角度来看，这个锁被“永久”的上锁了，因为它的持有者“蒸发”了。如果子进程中的任何一个线程对这个已经被持有的锁进行lock操作，就会发生死锁。</p>
<p>将整个流程总结为下图：</p>
<p><img src="init-zygote.jpg" alt="init-zygote总结"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Java%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="苍耳叔叔">
      <meta itemprop="description" content="梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苍耳的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/Java%E5%8F%8D%E5%B0%84/" class="post-title-link" itemprop="url">Java反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-21 15:42:50" itemprop="dateCreated datePublished" datetime="2019-10-21T15:42:50+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 14:14:57" itemprop="dateModified" datetime="2021-05-14T14:14:57+08:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2019/10/21/Java%E5%8F%8D%E5%B0%84/" class="post-meta-item leancloud_visitors" data-flag-title="Java反射" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/10/21/Java%E5%8F%8D%E5%B0%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/Java%E5%8F%8D%E5%B0%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>反射机制就是允许编程人员在程序运行时来改变程序的结构或者变量的类型。通过这个特性，我们可以在运行时得知某个类的所有成员，包括其属性和方法，同时也能够调用这些方法。请注意反射机制的特殊之处就在于可以使用编译期间完全未知的类,也就是通过反射机制可以加载一个在运行时才得知名字的类，从而取得其内部的成员函数并调用。</p>
<ol>
<li><p>动态语言：</p>
<p> 一般认为在程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。尽管这样，JAVA有着一个非常突出的动态相关机制：反射（Reflection）。运用反射我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载在运行时才得知名称的class，获悉其完整构造方法，并生成其对象实体、或对其属性设值、或唤起其成员方法。</p>
</li>
<li><p>反射：</p>
<p> 要让Java程序能够运行，就得让Java类被Java虚拟机加载。Java类如果不被Java虚拟机加载就不能正常运行。正常情况下，我们运行的所有的程序在编译期时候就已经把那个类被加载了。Java的反射机制是在编译时并不确定是哪个类被加载了，而是在程序运行的时候才加载。使用的是在编译期并不知道的类。这样的编译特点就是java反射。</p>
</li>
<li><p>反射的作用:</p>
<p> 如果有AB两个程序员合作，A在写程序的时需要使用B所写的类，但B并没完成他所写的类。那么A的代码是不能通过编译的。此时，利用Java反射的机制，就可以让A在没有得到B所写的类的时候，来使自身的代码通过编译。</p>
</li>
<li><p>反射的实质:</p>
<p> 反射就是把Java类中的各种存在给解析成相应的Java类。要正确使用Java反射机制就得使用Class（C大写） 这个类。它是Java反射机制的起源。当一个类被加载以后，Java虚拟机就会自动产生一个Class对象。通过这个Class对象我们就能获得加载到虚拟机当中这个Class对象对应的方法、成员以及构造方法的声明和定义等信息。</p>
</li>
<li><p>反射机制的优点与缺点:</p>
<ul>
<li><p>静态编译：在编译时确定类型，绑定对象,即通过。</p>
</li>
<li><p>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，降低类之间的藕合性。</p>
<p>一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用安装，只需要在运行时才动态的创建和编译，就可以实现该功能。它的缺点是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>在面向对象的世界里，万事万物皆对象。在java语言中，静态的成员，普通数据类型不是对象。</p>
<p>类是对象，类是java.lang.Class类的实例对象。这个对象的表示方式有三种：</p>
<ul>
<li><p>第一种表示方式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Foo.class;<span class="comment">//任何一个类都有一个隐含的静态成员变量class</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种表示方式：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = foo1.getClass();<span class="comment">//已知该类的对象，通过getClass方法得到这个实例类的class(类类型)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种表达方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">&quot;imooc.reflect.Foo&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  可以通过类类型创建该类的类对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Foo.class;<span class="comment">//c1就是类类型</span></span><br><span class="line">Foo foo=(Foo)c1.newInstance();<span class="comment">//需要有无参数的构造方法。</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="静态动态加载类"><a href="#静态动态加载类" class="headerlink" title="静态动态加载类"></a>静态动态加载类</h1><p>编译时刻加载类是静态加载类，运行时刻是动态加载类。</p>
<p>new创建对象是静态加载类，在编译时刻就需要加载所有可能用到的类。如果创建了一个可以使用的C1对象和不可使用的C2对象，即使C1可用，由于C2不可以而编译不过使得C1不可用。用动态加载类可以解决该问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> <span class="keyword">implements</span> <span class="title">OfficeAble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Word...start...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//动态加载类，在运行时加载</span></span><br><span class="line">        Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//通过类类型，创建该对象</span></span><br><span class="line">        OfficeAble oa = (OfficeAble) c.newInstance();</span><br><span class="line">        oa.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取类的方法"><a href="#获取类的方法" class="headerlink" title="获取类的方法"></a>获取类的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先获取类的类类型</span></span><br><span class="line">Class cl = object.getClass();</span><br><span class="line"><span class="comment">//获取类的名称/简称</span></span><br><span class="line">System.out.println(<span class="string">&quot;名称:&quot;</span> + cl.getName() + <span class="string">&quot; 简称:&quot;</span> + cl.getSimpleName());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Method类，方法对象，一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment">* getMethods获取的是所有public方法，包括从父类继承而来的</span></span><br><span class="line"><span class="comment">* getDeclaredMethods获取的是所有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Method[] methods = cl.getMethods();<span class="comment">//cl.getDeclaredMethods()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++)&#123;</span><br><span class="line">    <span class="comment">//得到方法的返回值类型的类类型</span></span><br><span class="line">    Class returnType = methods[i].getReturnType();</span><br><span class="line">    System.out.print(returnType.getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">//得到方法的名称</span></span><br><span class="line">    System.out.print(methods[i].getName() + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="comment">//获取参数列表的类型的类类型</span></span><br><span class="line">    Class[] params = methods[i].getParameterTypes();</span><br><span class="line">    <span class="keyword">for</span> (Class c: params)&#123;</span><br><span class="line">        System.out.print(c.getName() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取类的属性"><a href="#获取类的属性" class="headerlink" title="获取类的属性"></a>获取类的属性</h1><p>在使用反射获取或者修改一个变量的值时，编译器不会进行自动装/拆箱。因此我们无法给一个 Integer 类型的变量赋整型值，必须给它赋一个 Integer 对象才可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getFields获取的是所有public属性，包括从父类继承而来的</span></span><br><span class="line"><span class="comment">* getDeclaredFields获取的是所有该类自己定义的属性，不问访问权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Field[] fields = cl.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++)&#123;</span><br><span class="line">    <span class="comment">//得到成员变量的类型的类类型</span></span><br><span class="line">    Class fieldType = fields[i].getType();</span><br><span class="line">    System.out.println(fieldType.getName());</span><br><span class="line">    System.out.println(fields[i].getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 final 修饰的字段：</p>
<p><strong>构造方法赋值：</strong></p>
<ul>
<li>构造方法赋值在JVM编译期不会优化，运行时决定字段的值，修改后通过反射和其他方式访问到的都是新值。</li>
</ul>
<p><strong>直接赋值：</strong></p>
<ul>
<li>基本类型、String类型：JVM编译期会优化成常量，导致修改后的值通过反射可以访问到新值，其他方式访问到的仍是旧值。</li>
<li>对象类型：JVM编译期不会优化，运行时决定字段的值，修改后通过反射和其他方式访问到的都是新值。</li>
</ul>
<p><strong>间接赋值：</strong></p>
<ul>
<li>间接赋值在JVM编译期不会优化，运行时决定字段的值，修改后通过反射和其他方式访问到的都是新值。</li>
</ul>
<p><strong>小结</strong></p>
<p>如果final字段值是运行时赋值的，则修改后无论通过何种方式访问获得的都是新值；基本类型、String类型直接赋值时由于JVM编译优化，编译时期用到字段的地方会直接被字段值替换，导致通过反射修改字段值后用到字段的地方仍是原值，但通过反射访问获取到的是新值（给人的错觉是没修改成功）。</p>
<h1 id="获取类的构造方法"><a href="#获取类的构造方法" class="headerlink" title="获取类的构造方法"></a>获取类的构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* getConstructors获取的是所有public的构造函数，包括从父类继承而来的</span></span><br><span class="line"><span class="comment">* getDeclaredConstructors获取的是所有该类自己定义的构造函数，不问访问权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Constructor[] constructor = cl.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>

<h1 id="方法反射"><a href="#方法反射" class="headerlink" title="方法反射"></a>方法反射</h1><p>使用method.invok();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">Class c = a.getClass();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = c.getMethod(<span class="string">&quot;print&quot;</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//方法的反射操作是指用method对象进行操作</span></span><br><span class="line">    <span class="comment">//方法如果没有返回值则返回null， 有返回值则返回返回值</span></span><br><span class="line">    method.invoke(a, <span class="keyword">new</span> Object[]&#123;<span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"><span class="comment">//method.invoke(a, 20, 30);</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="属性反射"><a href="#属性反射" class="headerlink" title="属性反射"></a>属性反射</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">    f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f.set(object, args...);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h1><p>编译之后集合的泛型是去泛型化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">Class c1 = list.getClass();</span><br><span class="line">Class c2 = list1.getClass();</span><br><span class="line">System.out.println(c1 == c2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**反射都是编译之后的操作（字节码）</span></span><br><span class="line"><span class="comment">* 返回true说明编译之后集合的泛型是去泛型化的</span></span><br><span class="line"><span class="comment">* Java中集合的泛型，是防止错误输入的，只在编译阶段有效</span></span><br><span class="line"><span class="comment">* 验证：通过方法的反射来给list1加入int类型的数据，绕过编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Method method = c2.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">    method.invoke(list1, <span class="number">20</span>);</span><br><span class="line">    method.invoke(list1, <span class="string">&quot;string&quot;</span>);</span><br><span class="line">    System.out.println(list1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="MethodHandle"><a href="#MethodHandle" class="headerlink" title="MethodHandle"></a>MethodHandle</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>java7增加了对动态类型语言的支持，使java也可以像C语言那样将方法作为参数传递，其实现在lava.lang.invoke包中。MethodHandle作用类似于反射中的Method类，但它比Method类要更加灵活和轻量级。通过MethodHandle进行方法调用一般需要以下几步：</p>
<ol>
<li>创建MethodType对象，指定方法的签名；</li>
<li>在MethodHandles.Lookup中查找类型为MethodType的MethodHandle；</li>
<li>传入方法参数并调用MethodHandle.invoke或者MethodHandle.invokeExact方法。</li>
</ol>
<h2 id="MethodType"><a href="#MethodType" class="headerlink" title="MethodType"></a>MethodType</h2><p>创建方法：</p>
<p>1.通过MethodType.methodType及其重载方法，需要指定返回值类型以及0到多个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">methodType</span><span class="params">(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">methodType</span><span class="params">(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.MethodType.genericMethodType，需要指定参数的个数，类型都为Object：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">genericMethodType</span><span class="params">(<span class="keyword">int</span> objectArgCount, <span class="keyword">boolean</span> finalArray)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">genericMethodType</span><span class="params">(<span class="keyword">int</span> objectArgCount)</span></span></span><br></pre></td></tr></table></figure>

<p>3.fromMethodDescriptorString，通过方法描述来创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">fromMethodDescriptorString</span><span class="params">(String descriptor, ClassLoader loader)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="MethodHandles-Lookup"><a href="#MethodHandles-Lookup" class="headerlink" title="MethodHandles.Lookup"></a>MethodHandles.Lookup</h2><p>MethodHandles.Lookup相当于MethodHandle工厂类，通过findxxx方法可以得到相应的MethodHandle，还可以配合反射API创建MethodHandle，对应的方法有unreflect、unreflectSpecial等。</p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p>在得到MethodHandle后就可以进行方法调用了，有三种调用形式：</p>
<ol>
<li>invokeExact: 调用此方法与直接调用底层方法一样，需要做到参数类型精确匹配；</li>
<li>invoke: 参数类型松散匹配，通过asType自动适配；</li>
<li>invokeWithArguments: 直接通过方法参数来调用。其实现是先通过genericMethodType方法得到MethodType，再通过MethodHandle的asType转换后得到一个新的MethodHandle，最后通过新MethodHandle的invokeExact方法来完成调用。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;s = &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodHandle methodHandle = getMethodType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = (String) methodHandle.invokeExact(<span class="string">&quot;hearing&quot;</span>);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// String s = (String) methodHandle.bindTo(...).invokeWithArguments(&quot;hearing-2&quot;);</span></span><br><span class="line">            String s = (String) methodHandle.invokeWithArguments(<span class="string">&quot;hearing-2&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getMethodType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodType methodType = MethodType.methodType(String.class, String.class);</span><br><span class="line">        MethodHandle methodHandle = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodHandle = MethodHandles.lookup().findStatic(Main.class, <span class="string">&quot;hello&quot;</span>, methodType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methodHandle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苍耳叔叔"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">苍耳叔叔</p>
  <div class="site-description" itemprop="description">梦里寻她千百度，蓦然回首，那人却在，灯火阑珊处。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">100</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ljd1996" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljd1996" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hearing1996@gmail.com" title="E-Mail → mailto:hearing1996@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">苍耳叔叔</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'pCnIlzs46HJGpubm7D3TnrBC-gzGzoHsz',
      appKey     : '7LzW4wBI9lY5DtVFNkFWcjs0',
      placeholder: "欢迎评论交流！",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
